<?xml version="1.0" encoding="UTF-8" ?>
<testsuites name="vitest tests" tests="1980" failures="1" errors="0" time="35.787012388">
    <testsuite name="src/gemini.test.tsx" timestamp="2025-09-29T17:17:41.646Z" hostname="codespaces-4e4548" tests="8" failures="0" errors="0" skipped="0" time="0.026188988">
        <testcase classname="src/gemini.test.tsx" name="gemini.tsx main function &gt; should throw InvalidConfigurationError if settings have errors" time="0.005770544">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="gemini.tsx main function &gt; should log unhandled promise rejections and open debug console on first error" time="0.011042557">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return &quot;ipv4first&quot; when the input is &quot;ipv4first&quot;" time="0.000706407">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return &quot;verbatim&quot; when the input is &quot;verbatim&quot;" time="0.0004345">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return the default &quot;ipv4first&quot; when the input is undefined" time="0.000377664">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return the default &quot;ipv4first&quot; and log a warning for an invalid string" time="0.000620767">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="startInteractiveUI &gt; should render the UI with proper React context and exitOnCtrlC disabled" time="0.003568222">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="startInteractiveUI &gt; should perform all startup tasks in correct order" time="0.001374612">
        </testcase>
    </testsuite>
    <testsuite name="src/nonInteractiveCli.test.ts" timestamp="2025-09-29T17:17:41.649Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="0" time="0.037188782">
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should process input and write text output" time="0.012312802">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle a single tool call and respond" time="0.006477785">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle error during tool execution and should send error back to the model" time="0.00480654">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit with error if sendMessageStream throws initially" time="0.004772767">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should not exit if a tool is not found, and should send error back to model" time="0.001731247">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit when max session turns are exceeded" time="0.003059744">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should preprocess @include commands before sending to the model" time="0.001621773">
        </testcase>
    </testsuite>
    <testsuite name="src/validateNonInterActiveAuth.test.ts" timestamp="2025-09-29T17:17:41.651Z" hostname="codespaces-4e4548" tests="13" failures="0" errors="0" skipped="0" time="0.02070017">
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; exits if no auth type is configured or env vars set" time="0.00732833">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set" time="0.001834981">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_GEMINI if GEMINI_API_KEY is set" time="0.000671733">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_OPENAI if OPENAI_API_KEY is set" time="0.000614185">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses configured QWEN_OAUTH if provided" time="0.000613383">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true (with GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION)" time="0.000527523">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true and GOOGLE_API_KEY is set" time="0.000528875">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set, even with other env vars" time="0.000648139">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if both GEMINI_API_KEY and GOOGLE_GENAI_USE_VERTEXAI are set" time="0.000850956">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_GEMINI if GOOGLE_GENAI_USE_VERTEXAI is false, GEMINI_API_KEY is set, and project/location are available" time="0.001900286">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses configuredAuthType if provided" time="0.000874259">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; exits if validateAuthMethod returns error" time="0.000961172">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; skips validation if useExternalAuth is true" time="0.00118001">
        </testcase>
    </testsuite>
    <testsuite name="src/__tests__/env-persist.test.ts" timestamp="2025-09-29T17:17:41.654Z" hostname="codespaces-4e4548" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/__tests__/env-persist.test.ts" name="src/__tests__/env-persist.test.ts" time="0">
            <failure message="Failed to resolve import &quot;../../config/auth.js&quot; from &quot;src/__tests__/env-persist.test.ts&quot;. Does the file exist?" type="Error">
Error: Failed to resolve import &quot;../../config/auth.js&quot; from &quot;src/__tests__/env-persist.test.ts&quot;. Does the file exist?
  Plugin: vite:import-analysis
  File: /workspaces/LowCal-Code/packages/cli/src/__tests__/env-persist.test.ts:4:32
  2  |  import * as path from &quot;node:path&quot;;
  3  |  import { tmpdir } from &quot;node:os&quot;;
  4  |  import { setOpenAIApiKey } from &quot;../../config/auth.js&quot;;
     |                                   ^
  5  |  describe(&quot;env persistence&quot;, () =&gt; {
  6  |    test(&quot;writes to discovered .env file and returns the path&quot;, () =&gt; {
 ❯ TransformPluginContext._formatLog ../../node_modules/vite/dist/node/chunks/dep-Bsx9IwL8.js:31446:43
 ❯ TransformPluginContext.error ../../node_modules/vite/dist/node/chunks/dep-Bsx9IwL8.js:31443:14
 ❯ normalizeUrl ../../node_modules/vite/dist/node/chunks/dep-Bsx9IwL8.js:29992:18
 ❯ ../../node_modules/vite/dist/node/chunks/dep-Bsx9IwL8.js:30050:32
 ❯ TransformPluginContext.transform ../../node_modules/vite/dist/node/chunks/dep-Bsx9IwL8.js:30018:4
 ❯ EnvironmentPluginContainer.transform ../../node_modules/vite/dist/node/chunks/dep-Bsx9IwL8.js:31260:14
 ❯ loadAndTransform ../../node_modules/vite/dist/node/chunks/dep-Bsx9IwL8.js:26434:26
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp.test.ts" timestamp="2025-09-29T17:17:41.656Z" hostname="codespaces-4e4548" tests="3" failures="0" errors="0" skipped="0" time="0.015070653">
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should have correct command definition" time="0.002362294">
        </testcase>
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should have exactly one option (help flag)" time="0.006119186">
        </testcase>
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should register add, remove, and list subcommands" time="0.004577644">
        </testcase>
    </testsuite>
    <testsuite name="src/config/auth.test.ts" timestamp="2025-09-29T17:17:41.657Z" hostname="codespaces-4e4548" tests="8" failures="0" errors="0" skipped="0" time="0.011797651">
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for LOGIN_WITH_GOOGLE" time="0.004056502">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for CLOUD_SHELL" time="0.000918712">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return null if GEMINI_API_KEY is set" time="0.000851558">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return an error message if GEMINI_API_KEY is not set" time="0.000942838">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION are set" time="0.000843713">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_API_KEY is set" time="0.000680418">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return an error message if no required environment variables are set" time="0.00066503">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return an error message for an invalid auth method" time="0.000624925">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.integration.test.ts" timestamp="2025-09-29T17:17:41.659Z" hostname="codespaces-4e4548" tests="19" failures="0" errors="0" skipped="0" time="0.656704754">
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load default file filtering settings" time="0.057124972">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load custom file filtering settings from configuration" time="0.001302348">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should merge user and workspace file filtering settings" time="0.000914484">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle partial configuration objects gracefully" time="0.000905468">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle empty configuration objects gracefully" time="0.000892022">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle missing configuration sections gracefully" time="0.000963466">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a security-focused configuration" time="0.000825418">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a CI/CD environment configuration" time="0.000839074">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Checkpointing Configuration &gt; should enable checkpointing when the setting is true" time="0.001129666">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should have an empty array for extension context files by default" time="0.001769298">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should correctly store and return extension context file paths" time="0.001063253">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=auto-edit correctly through the full argument parsing flow" time="0.501773176">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=plan correctly through the full argument parsing flow" time="0.007914802">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=yolo correctly through the full argument parsing flow" time="0.005345284">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=default correctly through the full argument parsing flow" time="0.006787522">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse legacy --yolo flag correctly" time="0.005181429">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject invalid approval mode values during argument parsing" time="0.03154961">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Invalid values:
  Argument: approval-mode, Given: &quot;invalid_mode&quot;, Choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject conflicting --yolo and --approval-mode flags" time="0.018057129">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Cannot use both --yolo (-y) and --approval-mode together. Use --approval-mode=yolo instead.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should handle backward compatibility with mixed scenarios" time="0.005475757">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.test.ts" timestamp="2025-09-29T17:17:41.663Z" hostname="codespaces-4e4548" tests="125" failures="0" errors="0" skipped="1" time="0.67866637">
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --prompt and --prompt-interactive are used together" time="0.047568346">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -p and -i together" time="0.012649239">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt without --prompt-interactive" time="0.003761572">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt-interactive without --prompt" time="0.003192471">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow -i flag as alias for --prompt-interactive" time="0.003384269">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --yolo and --approval-mode are used together" time="0.017299125">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -y and --approval-mode together" time="0.016996212">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --approval-mode without --yolo" time="0.006586858">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --yolo without --approval-mode" time="0.004389364">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should reject invalid --approval-mode values" time="0.018056219">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to true when --show-memory-usage flag is present" time="0.064937659">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false when --memory flag is not present" time="0.005361685">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false by default from settings if CLI flag is not present" time="0.004423872">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should prioritize CLI flag over settings for showMemoryUsage (CLI true, settings false)" time="0.00932377">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should leave proxy to empty by default" time="0.004986344">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [https_proxy]" time="0.004501501">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [http_proxy]" time="0.003780867">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTPS_PROXY]" time="0.002959998">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTP_PROXY]" time="0.003907193">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy when --proxy flag is present" time="0.0028111">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should prioritize CLI flag over environment variable for proxy (CLI http://localhost:7890, environment variable http://localhost:7891)" time="0.003968868">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false by default when no flag or setting is present" time="0.004472837">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to true when --telemetry flag is present" time="0.02174803">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false when --no-telemetry flag is present" time="0.004663843">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings true)" time="0.004037807">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings false)" time="0.004153622">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry CLI flag (true) over settings (false)" time="0.004161818">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry CLI flag (false) over settings (true)" time="0.004253088">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP endpoint from settings if CLI flag is not present" time="0.005786005">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-endpoint CLI flag over settings" time="0.004290468">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default endpoint if no OTLP endpoint is provided via CLI or settings" time="0.003824139">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry target from settings if CLI flag is not present" time="0.003537955">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-target CLI flag over settings" time="0.004209998">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default target if no target is provided via CLI or settings" time="0.003913746">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry log prompts from settings if CLI flag is not present" time="0.003680611">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-log-prompts CLI flag (true) over settings (false)" time="0.004262305">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry-log-prompts CLI flag (false) over settings (true)" time="0.004339309">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default log prompts (true) if no value is provided via CLI or settings" time="0.004110082">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP protocol from settings if CLI flag is not present" time="0.003972515">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-protocol CLI flag over settings" time="0.004102638">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default protocol if no OTLP protocol is provided via CLI or settings" time="0.003940887">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should reject invalid --telemetry-otlp-protocol values" time="0.015529518">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should pass extension context file paths to loadServerHierarchicalMemory" time="0.007215537">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should correctly use mocked homedir for global path" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeMcpServers &gt; should not modify the original settings object" time="0.003176612">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use default systemPromptMappings when not provided in settings" time="0.000836419">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use custom systemPromptMappings when provided in settings" time="0.000599968">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should merge excludeTools from settings and extensions" time="0.00372288">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between settings and extensions" time="0.00289161">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between extensions" time="0.003775498">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return an empty array when no excludeTools are specified and it is interactive" time="0.002766497">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return default excludes when no excludeTools are specified and it is not interactive" time="0.002601219">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle settings with excludeTools but no extensions" time="0.002651984">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle extensions with excludeTools but no settings" time="0.002526881">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should not modify the original settings object" time="0.003022914">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with default approval mode" time="0.004256414">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with plan approval mode" time="0.003893127">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with explicit default approval mode" time="0.003244859">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude only shell tools in non-interactive mode with auto-edit approval mode" time="0.004799036">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with yolo approval mode" time="0.006328845">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with legacy yolo flag" time="0.003362588">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should not exclude interactive tools in interactive mode regardless of approval mode" time="0.023963289">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should merge approval mode exclusions with settings exclusions in auto-edit mode" time="0.003859614">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should throw an error for invalid approval mode values in loadCliConfig" time="0.000859292">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow all MCP servers if the flag is not provided" time="0.003360083">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow only the specified MCP server" time="0.004729987">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow multiple specified MCP servers" time="0.004188268">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should handle server names that do not exist" time="0.004357352">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow no MCP servers if the flag is provided but empty" time="0.004118437">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read allowMCPServers from settings" time="0.0038787">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read excludeMCPServers from settings" time="0.008047629">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should override allowMCPServers with excludeMCPServers if overlapping" time="0.004276291">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize mcp server flag if set" time="0.004604704">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize CLI flag over both allowed and excluded settings" time="0.004011398">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should not filter extensions if --extensions flag is not used" time="0.003993574">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should filter extensions if --extensions flag is used" time="0.004152591">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects a model from settings.json if provided" time="0.003890623">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; uses the default gemini model if nothing is set" time="0.00332054">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; always prefers model from argvs" time="0.003331941">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects the model from argvs if provided" time="0.003280166">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be false by default" time="0.002594606">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be true when settings.folderTrustFeature is true" time="0.002772388">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is false" time="0.002569309">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is true and folderTrust is false" time="0.003462785">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is true" time="0.00286474">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be true when folderTrustFeature is true and folderTrust is true" time="0.004549127">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with includeDirectories &gt; should combine and resolve paths from settings and CLI arguments" time="0.004330983">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should pass chatCompression settings to the core config" time="0.003603206">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should have undefined chatCompression if not in settings" time="0.003306013">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false by default when useRipgrep is not set in settings" time="0.00262831">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be true when useRipgrep is set to true in settings" time="0.002468471">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false when useRipgrep is explicitly set to false in settings" time="0.003097143">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode without YOLO" time="0.004194489">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode with YOLO" time="0.004403338">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should exclude interactive tools in non-interactive mode without YOLO" time="0.004178098">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in non-interactive mode with YOLO" time="0.004427684">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if isTTY and no prompt" time="0.00274105">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if prompt-interactive is set" time="0.002460597">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if not isTTY and no prompt" time="0.002416755">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if prompt is set" time="0.002503467">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should default to DEFAULT approval mode when no flags are set" time="0.004209497">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set PLAN approval mode when --approval-mode=plan" time="0.003134092">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --yolo flag is used" time="0.003522606">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when -y flag is used" time="0.004277975">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set DEFAULT approval mode when --approval-mode=default" time="0.004170645">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set AUTO_EDIT approval mode when --approval-mode=auto-edit" time="0.00305243">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --approval-mode=yolo" time="0.004015395">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should use approval mode from settings when CLI flags are not provided" time="0.003194765">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should normalize approval mode values from settings" time="0.002619693">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should throw when approval mode in settings is invalid" time="0.002600557">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should prioritize --approval-mode over --yolo when both would be valid (but validation prevents this)" time="0.003001244">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should fall back to --yolo behavior when --approval-mode is not set" time="0.003825351">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=yolo to DEFAULT" time="0.004642143">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=auto-edit to DEFAULT" time="0.00448436">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --yolo flag to DEFAULT" time="0.00326146">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should remain DEFAULT when --approval-mode=default" time="0.004783126">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should allow PLAN approval mode in untrusted folders" time="0.004312078">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace trusted -&gt; behave as trusted" time="0.00520793">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace not trusted -&gt; behave as trusted" time="0.003538927">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.003635306">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.0035299">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace not trusted -&gt; behave as trusted" time="0.002348527">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trusted -&gt; is trusted" time="0.002341846">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace NOT trusted -&gt; is NOT trusted" time="0.002313673">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trust unknown -&gt; is unknown" time="0.002356864">
        </testcase>
    </testsuite>
    <testsuite name="src/config/extension.test.ts" timestamp="2025-09-29T17:17:41.690Z" hostname="codespaces-4e4548" tests="26" failures="0" errors="0" skipped="0" time="0.136368859">
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should include extension path in loaded extension" time="0.021455785">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should load context file path when QWEN.md is present" time="0.005136204">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should load context file path from the extension config" time="0.002529886">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should filter out disabled extensions" time="0.004428285">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should hydrate variables" time="0.004815156">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark all extensions as active if no enabled extensions are provided" time="0.000959238">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark only the enabled extensions as active" time="0.001158881">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark all extensions as inactive when &quot;none&quot; is provided" time="0.000830428">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should handle case-insensitivity" time="0.000784141">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should log an error for unknown extensions" time="0.001725908">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should install an extension from a local path" time="0.013228627">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should throw an error if the extension already exists" time="0.006919088">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should throw an error and cleanup if qwen-extension.json is missing" time="0.003629655">
            <system-err>
Warning: extension directory /tmp/qwen-code-test-home-qF3rMC/bad-extension does not contain a config file /tmp/qwen-code-test-home-qF3rMC/bad-extension/qwen-extension.json.

            </system-err>
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should install an extension from a git URL" time="0.005280844">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should uninstall an extension by name" time="0.005382012">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should uninstall an extension by name and retain existing extensions" time="0.008221446">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should throw an error if the extension does not exist" time="0.000983844">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="performWorkspaceExtensionMigration &gt; should install the extensions in the user directory" time="0.013301345">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="performWorkspaceExtensionMigration &gt; should return the names of failed installations" time="0.004238551">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="updateExtension &gt; should update a git-installed extension" time="0.010473183">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should disable an extension at the user scope" time="0.001901144">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should disable an extension at the workspace scope" time="0.00212981">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should handle disabling the same extension twice" time="0.001851331">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should throw an error if you request system scope" time="0.000757281">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="enableExtension &gt; should enable an extension at the user scope" time="0.005148146">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="enableExtension &gt; should enable an extension at the workspace scope" time="0.005707589">
        </testcase>
    </testsuite>
    <testsuite name="src/config/keyBindings.test.ts" timestamp="2025-09-29T17:17:41.695Z" hostname="codespaces-4e4548" tests="3" failures="0" errors="0" skipped="0" time="0.009493105">
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have bindings for all commands" time="0.003923835">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have valid key binding structures" time="0.0033317">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should export all required types" time="0.00027347">
        </testcase>
    </testsuite>
    <testsuite name="src/config/settings.test.ts" timestamp="2025-09-29T17:17:41.696Z" hostname="codespaces-4e4548" tests="63" failures="0" errors="0" skipped="0" time="0.088984323">
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load empty settings if no files exist" time="0.007480945">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load system settings if only system file exists" time="0.004292161">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load user settings if only user file exists" time="0.00154474">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load workspace settings if only workspace file exists" time="0.001296516">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge user and workspace settings, with workspace taking precedence" time="0.002062524">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge system, user and workspace settings, with system taking precedence over workspace, and workspace over user" time="0.002615956">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly migrate a complex legacy (v1) settings file" time="0.001606996">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly merge and migrate legacy array properties from multiple scopes" time="0.003577298">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge all settings files with the correct precedence" time="0.001984309">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should ignore folderTrust from workspace settings" time="0.000800703">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should use system folderTrust over user setting" time="0.000814548">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle contextFileName correctly when only in user settings" time="0.000769645">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle contextFileName correctly when only in workspace settings" time="0.000695256">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle excludedProjectEnvVars correctly when only in user settings" time="0.005038242">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle excludedProjectEnvVars correctly when only in workspace settings" time="0.000715183">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge excludedProjectEnvVars with workspace taking precedence over user" time="0.000929011">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should default contextFileName to undefined if not in any settings file" time="0.000855585">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load telemetry setting from user settings" time="0.00478551">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load telemetry setting from workspace settings" time="0.000675339">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should prioritize workspace telemetry setting over user setting" time="0.000777239">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have telemetry as undefined if not in any settings file" time="0.000623001">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge MCP servers correctly, with workspace taking precedence" time="0.003432228">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle MCP servers when only in user settings" time="0.000824477">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle MCP servers when only in workspace settings" time="0.000703261">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have mcpServers as empty object if not in any settings file" time="0.000534397">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge MCP servers from system, user, and workspace with system taking precedence" time="0.001065476">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge mcp allowed/excluded lists with system taking precedence over workspace" time="0.001050237">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge chatCompression settings, with workspace taking precedence" time="0.003141066">
            <system-out>
{ contextPercentageThreshold: [33m0.5[39m }

            </system-out>
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle chatCompression when only in user settings" time="0.000763784">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have chatCompression as an empty object if not in any settings file" time="0.000659149">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should ignore chatCompression if contextPercentageThreshold is invalid" time="0.001133002">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should deep merge chatCompression settings" time="0.000701487">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge includeDirectories from all scopes" time="0.000957204">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle JSON parsing errors gracefully" time="0.001935829">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in user settings" time="0.000959028">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in workspace settings" time="0.000863249">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly resolve and merge env variables from different scopes" time="0.001504945">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly merge dnsResolutionOrder with workspace taking precedence" time="0.000842721">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should use user dnsResolutionOrder if workspace is not defined" time="0.000672554">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should leave unresolved environment variables as is" time="0.000787167">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve multiple environment variables in a single string" time="0.000799631">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in arrays" time="0.000868348">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly pass through null, boolean, and number types, and handle undefined properties" time="0.001382027">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve multiple concatenated environment variables in a single string value" time="0.000752373">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; when QWEN_CODE_SYSTEM_SETTINGS_PATH is set &gt; should load system settings from the path specified in the environment variable" time="0.001325991">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should exclude DEBUG and DEBUG_MODE from project .env files by default" time="0.000792608">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should respect custom excludedProjectEnvVars from user settings" time="0.000870062">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should merge excludedProjectEnvVars with workspace taking precedence" time="0.000930054">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; with workspace trust &gt; should merge workspace settings when workspace is trusted" time="0.000802987">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; with workspace trust &gt; should NOT merge workspace settings when workspace is not trusted" time="0.000784562">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle an empty object" time="0.000583648">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should migrate a simple v2 settings object to v1" time="0.000434951">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle nested properties correctly" time="0.000395247">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve mcpServers at the top level" time="0.000431174">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should carry over unrecognized top-level properties" time="0.000407409">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle a complex object with mixed properties" time="0.000592584">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should not migrate a v1 settings object" time="0.000409133">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should migrate a full v2 settings object to v1" time="0.000740671">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle partial v2 settings" time="0.000467792">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle settings with different data types" time="0.000441924">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve unrecognized top-level keys" time="0.000463975">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle an empty v2 settings object" time="0.000377895">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should correctly handle mcpServers at the top level" time="0.000443678">
        </testcase>
    </testsuite>
    <testsuite name="src/config/settingsSchema.test.ts" timestamp="2025-09-29T17:17:41.710Z" hostname="codespaces-4e4548" tests="14" failures="0" errors="0" skipped="0" time="0.028815129">
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should contain all expected top-level settings" time="0.004617457">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct structure for each setting" time="0.011372004">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct nested setting structure" time="0.001145114">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have accessibility nested properties" time="0.000228265">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have checkpointing nested properties" time="0.000227254">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have fileFiltering nested properties" time="0.000283148">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have unique categories" time="0.001727531">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have consistent default values for boolean settings" time="0.003185378">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have showInDialog property configured" time="0.000953968">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should infer Settings type correctly" time="0.001194767">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have includeDirectories setting in schema" time="0.000339933">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have loadMemoryFromIncludeDirectories setting in schema" time="0.000304698">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have folderTrustFeature setting in schema" time="0.000302414">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have debugKeystrokeLogging setting in schema" time="0.000376112">
        </testcase>
    </testsuite>
    <testsuite name="src/config/trustedFolders.test.ts" timestamp="2025-09-29T17:17:41.713Z" hostname="codespaces-4e4548" tests="12" failures="0" errors="0" skipped="0" time="0.01568614">
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load empty rules if no files exist" time="0.004427323">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load user rules if only user file exists" time="0.000856777">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should handle JSON parsing errors gracefully" time="0.001042944">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; setValue should update the user config and save it" time="0.001776131">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a directly trusted folder" time="0.001508341">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted folder" time="0.000510061">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted parent folder" time="0.000521592">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return false for a directly untrusted folder" time="0.000500624">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined for a child of an untrusted folder" time="0.000570153">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined when no rules match" time="0.000620437">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should prioritize trust over distrust" time="0.000542992">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should handle path normalization" time="0.000534186">
        </testcase>
    </testsuite>
    <testsuite name="src/services/BuiltinCommandLoader.test.ts" timestamp="2025-09-29T17:17:41.716Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.022836742">
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should correctly pass the config object to command factory functions" time="0.016644599">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should filter out null command definitions returned by factories" time="0.000661193">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should handle a null config gracefully when calling factories" time="0.00057414">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should return a list of all loaded commands" time="0.00277908">
        </testcase>
    </testsuite>
    <testsuite name="src/services/CommandService.test.ts" timestamp="2025-09-29T17:17:41.717Z" hostname="codespaces-4e4548" tests="11" failures="0" errors="0" skipped="0" time="0.023063635">
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from a single loader" time="0.006036623">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should aggregate commands from multiple loaders" time="0.000991729">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should override commands from earlier loaders with those from later loaders" time="0.001508943">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle loaders that return an empty array of commands gracefully" time="0.000782199">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from successful loaders even if one fails" time="0.002206504">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; getCommands should return a readonly array that cannot be mutated" time="0.001511537">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should pass the abort signal to all loaders" time="0.002904075">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should rename extension commands when they conflict" time="0.001565158">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle user/project command override correctly" time="0.001200428">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle secondary conflicts when renaming extension commands" time="0.00118004">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle multiple secondary conflicts with incrementing suffixes" time="0.000988002">
        </testcase>
    </testsuite>
    <testsuite name="src/services/FileCommandLoader.test.ts" timestamp="2025-09-29T17:17:41.719Z" hostname="codespaces-4e4548" tests="36" failures="0" errors="0" skipped="0" time="0.192013588">
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads a single command from a file" time="0.027728588">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked directory" time="0.003668538">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked subdirectory" time="0.003241482">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads multiple commands" time="0.002695024">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates deeply nested namespaces correctly" time="0.003430186">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates namespaces from nested directories" time="0.002307041">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; returns both user and project commands in order" time="0.005192379">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files with TOML syntax errors" time="0.004478428">
            <system-err>
[FileCommandLoader] Failed to parse TOML file /home/codespace/.qwen/commands/invalid.toml: Invalid character, expected &quot;=&quot; at row 1, col 7, pos 6:
1&gt; this is not valid toml
         ^



            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files that are semantically invalid (missing prompt)" time="0.004818062">
            <system-err>
[FileCommandLoader] Skipping invalid command file: /home/codespace/.qwen/commands/no_prompt.toml. Validation errors: {
  formErrors: [],
  fieldErrors: { prompt: [ [32m&quot;The &apos;prompt&apos; field is required.&quot;[39m ] }
}

            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles filename edge cases correctly" time="0.002324373">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles file system errors gracefully" time="0.001599692">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses a default description if not provided" time="0.004690995">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses the provided description" time="0.002808526">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; should sanitize colons in filenames to prevent namespace conflicts" time="0.002461088">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only DefaultArgumentProcessor if no {{args}} or !{} are present" time="0.002856926">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if {{args}} is present (but not !{})" time="0.0023765">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and DefaultArgumentProcessor if !{} is present (but not {{args}})" time="0.002217243">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if both {{args}} and !{} are present" time="0.002242029">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates AtFileProcessor and DefaultArgumentProcessor if @{} is present" time="0.002417296">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and AtFileProcessor if !{} and @{} are present" time="0.002490082">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor and AtFileProcessor if {{args}} and @{} are present" time="0.002282185">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; loads commands from active extensions" time="0.008801065">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; extension commands have extensionName metadata for conflict resolution" time="0.0236579">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; only loads commands from active extensions" time="0.007114703">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles missing extension commands directory gracefully" time="0.017868395">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles nested command structure in extensions" time="0.005631086">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Argument Handling Integration (via ShellProcessor) &gt; correctly processes a command with {{args}}" time="0.003221194">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Default Argument Processor Integration &gt; correctly processes a command without {{args}}" time="0.003227526">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if {{args}} is present (even without shell trigger)" time="0.002666701">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if the trigger is present" time="0.002095897">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; does not instantiate ShellProcessor if no triggers ({{args}} or !{}) are present" time="0.002173371">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;submit_prompt&quot; action if shell processing succeeds" time="0.002804087">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;confirm_shell_commands&quot; action if shell processing requires it" time="0.004882291">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; re-throws other errors from the processor" time="0.005066355">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; assembles the processor pipeline in the correct order (AtFile -&gt; Shell -&gt; Default)" time="0.007403872">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; @-file Processor Integration &gt; correctly processes a command with @{file}" time="0.00376593">
        </testcase>
    </testsuite>
    <testsuite name="src/services/McpPromptLoader.test.ts" timestamp="2025-09-29T17:17:41.727Z" hostname="codespaces-4e4548" tests="10" failures="0" errors="0" skipped="0" time="0.008001325">
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle multi-word positional arguments" time="0.003362107">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle quoted multi-word positional arguments" time="0.000406318">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a single positional argument with multiple words" time="0.000269372">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped quotes in positional arguments" time="0.00024621">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped backslashes in positional arguments" time="0.000222214">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle named args followed by positional args" time="0.000309097">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args followed by named args" time="0.000266116">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args interspersed with named args" time="0.000278088">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should treat an escaped quote at the start as a literal" time="0.000244526">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a complex mix of args" time="0.00032162">
        </testcase>
    </testsuite>
    <testsuite name="src/test-utils/mockCommandContext.test.ts" timestamp="2025-09-29T17:17:41.730Z" hostname="codespaces-4e4548" tests="3" failures="0" errors="0" skipped="0" time="0.009432613">
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should return a valid CommandContext object with default mocks" time="0.005331669">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply top-level overrides correctly" time="0.00122883">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply deeply nested overrides correctly" time="0.000699604">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/App.test.tsx" timestamp="2025-09-29T17:17:41.731Z" hostname="codespaces-4e4548" tests="49" failures="0" errors="0" skipped="0" time="2.148913928">
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not start the update process when running from git" time="0.121612154">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Static inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show a success message when update succeeds" time="0.08640855">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when update fails" time="0.084940937">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when spawn fails" time="0.078365539">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not auto-update if GEMINI_CLI_DISABLE_AUTOUPDATER is true" time="0.0352614">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file when available" time="0.031347684">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display any files when not available" time="0.024744375">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other open files" time="0.030073927">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other context" time="0.029651503">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; in footer when contextFileName is not set and count is 1" time="0.036509126">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; with plural when contextFileName is not set and count is &gt; 1" time="0.019150949">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName in footer when set and count is 1" time="0.018269165">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display a generic message when multiple context files with different names are provided" time="0.021488977">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName with plural when set and count is &gt; 1" time="0.024514861">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display context file message if count is 0, even if contextFileName is set" time="0.023722501">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display QWEN.md and MCP server count when both are present" time="0.020420686">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display only MCP server count when QWEN.md count is 0" time="0.025163988">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Tips component by default" time="0.017951534">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Tips component when hideTips is true" time="0.016717502">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Header component by default" time="0.023136759">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Header component when hideBanner is true" time="0.030565396">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Footer component by default" time="0.02139384">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Footer component when hideFooter is true" time="0.013897496">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show footer if system says show, but workspace and user settings say hide" time="0.025288752">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show tips if system says show, but workspace and user settings say hide" time="0.019363825">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display theme dialog if NO_COLOR is not set" time="0.025386542">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display a message if NO_COLOR is set" time="0.026089491">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render the initial UI correctly" time="0.030022664">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render correctly with the prompt input box" time="0.03300839">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; with initial prompt from --prompt-interactive &gt; should submit the initial prompt automatically" time="0.077548426">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; errorCount &gt; should correctly sum the counts of error messages" time="0.02958062">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should call validateAuthMethod when useExternalAuth is false" time="0.027099277">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should NOT call validateAuthMethod when useExternalAuth is true" time="0.033116672">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when in a narrow terminal &gt; should render with a column layout" time="0.048515006">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; NO_COLOR smoke test &gt; should render without errors when NO_COLOR is set" time="0.033514343">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when isFolderTrustDialogOpen is true" time="0.049902081">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when the feature is enabled but the folder is not trusted" time="0.048364615">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should not display the folder trust dialog when the feature is disabled" time="0.042121137">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should queue messages when handleFinalSubmit is called during streaming" time="0.045951915">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should auto-send queued messages when transitioning from Responding to Idle" time="0.124102058">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should display queued messages with dimmed color" time="0.030294884">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should clear message queue after sending" time="0.038586308">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should handle empty messages by filtering them out" time="0.031804285">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should combine multiple queued messages with double newlines" time="0.04533073">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should limit displayed messages to MAX_DISPLAYED_QUEUED_MESSAGES" time="0.038924698">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should render message queue display without errors" time="0.025934905">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should pass debugKeystrokeLogging setting to KeypressProvider" time="0.042346307">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should use default false value when debugKeystrokeLogging is not set" time="0.028666597">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Ctrl+C behavior &gt; should call cancel but only clear the prompt when a tool is executing" time="0.308274966">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/keyMatchers.test.ts" timestamp="2025-09-29T17:17:41.741Z" hostname="codespaces-4e4548" tests="33" failures="0" errors="0" skipped="0" time="0.020091654">
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match return correctly" time="0.002944459">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match escape correctly" time="0.000525379">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match home correctly" time="0.000505342">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match end correctly" time="0.000570383">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineRight correctly" time="0.000390418">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineLeft correctly" time="0.000390277">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearInput correctly" time="0.000454156">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearScreen correctly" time="0.000440441">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyUp correctly" time="0.000399264">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyDown correctly" time="0.000397401">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationUp correctly" time="0.000508058">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationDown correctly" time="0.000459316">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestion correctly" time="0.0003809">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionUp correctly" time="0.00042417">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionDown correctly" time="0.00047171">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submit correctly" time="0.000482079">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match newline correctly" time="0.000549243">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match openExternalEditor correctly" time="0.000388424">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match pasteClipboardImage correctly" time="0.000443216">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showErrorDetails correctly" time="0.000387151">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleToolDescriptions correctly" time="0.00040781">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleIDEContextDetail correctly" time="0.000436193">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match quit correctly" time="0.001623609">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match exit correctly" time="0.000383615">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showMoreLines correctly" time="0.000335495">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleYoloMode correctly" time="0.00035431">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match reverseSearch correctly" time="0.000313575">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submitReverseSearch correctly" time="0.000308084">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestionReverseSearch correctly" time="0.000489873">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should properly handle ACCEPT_SUGGESTION_REVERSE_SEARCH cases" time="0.000282657">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should work with custom configuration" time="0.000373166">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should support multiple key bindings for same command" time="0.000272798">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Edge Cases &gt; should handle empty binding arrays" time="0.000216343">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/cleanup.test.ts" timestamp="2025-09-29T17:17:41.748Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.006082168">
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered synchronous function" time="0.003476501">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered asynchronous function" time="0.000331377">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run multiple registered functions" time="0.000256187">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should continue running cleanup functions even if one throws an error" time="0.000291834">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/gitUtils.test.ts" timestamp="2025-09-29T17:17:41.749Z" hostname="codespaces-4e4548" tests="12" failures="0" errors="0" skipped="0" time="0.024835363">
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the git command fails" time="0.010163435">
            <system-out>
Failed to get git remote: Error: oops
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/utils/gitUtils.test.ts:29:13
    at mockCall (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/spy/dist/index.js:96:15)
    at execSync (file:///workspaces/LowCal-Code/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at Module.isGitHubRepository [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/utils/gitUtils.ts:17:7[90m)[39m
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/utils/gitUtils.test.ts:31:12
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:155:11
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:752:26
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1897:20
    at new Promise (&lt;anonymous&gt;)
    at runWithTimeout (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1863:10)

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the remote is not github.com" time="0.000424191">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns true if the remote is github.com" time="0.000247912">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if github repo info cannot be determined" time="0.001637823">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if owner/repo could not be determined" time="0.000665571">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; returns the owner and repo" time="0.001883288">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root cannot be determined" time="0.000507636">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root is empty" time="0.000423099">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; returns the root" time="0.000256348">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch fails" time="0.004666399">
            <system-out>
Failed to determine latest run-gemini-cli release: nope

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch does not return a json body" time="0.001220284">
            <system-out>
Failed to determine latest run-gemini-cli release: Error: Response did not include tag_name field
    at Module.getLatestGitHubRelease [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/utils/gitUtils.ts:82:13[90m)[39m
[90m    at processTicksAndRejections (node:internal/process/task_queues:105:5)[39m
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/utils/gitUtils.test.ts:135:5
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:752:20

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; returns the release version" time="0.000830368">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/handleAutoUpdate.test.ts" timestamp="2025-09-29T17:17:41.752Z" hostname="codespaces-4e4548" tests="10" failures="0" errors="0" skipped="0" time="0.01907626">
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update info is null" time="0.00373913">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update nag is disabled" time="0.000650332">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if auto-updates are disabled" time="0.003520092">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if no update command is found" time="0.00074055">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should combine update messages correctly" time="0.000585482">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should attempt to perform an update when conditions are met" time="0.000513197">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the update process fails" time="0.002073345">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the spawn function throws an error" time="0.002546598">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should use the &quot;@nightly&quot; tag for nightly updates" time="0.000652486">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-success&quot; when the update process succeeds" time="0.001762515">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/installationInfo.test.ts" timestamp="2025-09-29T17:17:41.754Z" hostname="codespaces-4e4548" tests="16" failures="0" errors="0" skipped="0" time="0.019187988">
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN when cliPath is not available" time="0.00357299">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN and log error if realpathSync fails" time="0.003213821">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running from a local git clone" time="0.000623512">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via npx" time="0.000496025">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via pnpx" time="0.000645112">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via bunx" time="0.000458404">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect Homebrew installation via execSync" time="0.001645848">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should fall through if brew command fails" time="0.00076176">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global pnpm installation" time="0.000707319">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global yarn installation" time="0.000722186">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global bun installation" time="0.000683784">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify yarn from lockfile" time="0.00061165">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify pnpm from lockfile" time="0.000561126">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify bun from lockfile" time="0.000564944">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to local npm installation if no lockfile is found" time="0.000480015">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to global npm installation for unrecognized paths" time="0.000683725">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/readStdin.test.ts" timestamp="2025-09-29T17:17:41.758Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.01291297">
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should read and accumulate data from stdin" time="0.004941131">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should handle empty stdin input" time="0.000436293">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should timeout and resolve with empty string when no input is available" time="0.004535805">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should clear timeout once when data is received and resolve with data" time="0.000946815">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/settingsUtils.test.ts" timestamp="2025-09-29T17:17:41.759Z" hostname="codespaces-4e4548" tests="68" failures="0" errors="0" skipped="0" time="0.040179812">
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should group settings by category" time="0.00312092">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should include key property in grouped settings" time="0.003392243">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return definition for valid setting" time="0.000488561">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return undefined for invalid setting" time="0.000216773">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return true for settings that require restart" time="0.000297084">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for settings that do not require restart" time="0.000255957">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for invalid settings" time="0.000179304">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return correct default values" time="0.000245608">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return undefined for invalid settings" time="0.000158175">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getRestartRequiredSettings &gt; should return all settings that require restart" time="0.002123608">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from settings when set" time="0.00043457">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from merged settings when not set in current scope" time="0.000341607">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return default value when not set anywhere" time="0.000224118">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should handle nested settings correctly" time="0.000225129">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return undefined for invalid settings" time="0.000185756">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getAllSettingKeys &gt; should return all setting keys" time="0.000636327">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByType &gt; should return only boolean settings" time="0.003501948">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsRequiringRestart &gt; should return only settings that require restart" time="0.003488132">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return true for valid setting keys" time="0.0002363">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return false for invalid setting keys" time="0.000220561">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return correct category for valid settings" time="0.00028995">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return undefined for invalid settings" time="0.000179134">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for settings marked to show in dialog" time="0.0003325">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return false for settings marked to hide from dialog" time="0.001825864">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for invalid settings (default behavior)" time="0.00016142">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should only return settings marked for dialog display" time="0.000781928">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should not include Advanced category settings" time="0.000221974">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should include settings with showInDialog=true" time="0.000881633">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only boolean dialog settings" time="0.000796886">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only string dialog settings" time="0.000533354">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return only settings marked for dialog display" time="0.00146432">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return fewer keys than getAllSettingKeys" time="0.000334023">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should handle nested settings display correctly" time="0.00078871">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from settings when set" time="0.000219981">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from merged settings when not set in current scope" time="0.000173794">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return default value for invalid setting" time="0.000158596">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return true when value differs from default" time="0.000233475">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return false when value matches default" time="0.00018262">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for top-level settings that exist" time="0.000162403">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for top-level settings that do not exist" time="0.000150931">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for nested settings that exist" time="0.000157103">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for nested settings that do not exist" time="0.000152454">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false when parent exists but child does not" time="0.000177972">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set top-level setting value" time="0.000221894">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set nested setting value" time="0.000174225">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should preserve existing nested settings" time="0.000178172">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should not mutate original settings" time="0.001035921">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return true when modified settings require restart" time="0.000231962">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false when no modified settings require restart" time="0.000201576">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false for empty set" time="0.000180246">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return only settings that require restart" time="0.000448295">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return empty array when no settings require restart" time="0.000216714">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value without * when setting matches default" time="0.000197578">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value when setting is not in scope" time="0.00018268">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when changed from default" time="0.00019335">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value without * when setting does not exist in scope" time="0.000169937">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when user changes from default" time="0.000205904">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when setting does not exist in scope" time="0.000216543">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when setting exists in scope" time="0.000161931">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when nested setting does not exist in scope" time="0.000250938">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when nested setting exists in scope" time="0.000164106">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for top-level settings that exist in scope" time="0.0002307">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for top-level settings that do not exist in scope" time="0.000168083">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for nested settings that exist in scope" time="0.00016117">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for nested settings that do not exist in scope" time="0.000154869">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from settings when available" time="0.000223507">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from merged settings when not in scope" time="0.000194242">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return default value for undefined values" time="0.000150691">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/startupWarnings.test.ts" timestamp="2025-09-29T17:17:41.773Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="4" time="0">
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return warnings from the file and delete it" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an empty array if the file does not exist" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an error message if reading the file fails" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return a warning if deleting the file fails" time="0">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/utils/userStartupWarnings.test.ts" timestamp="2025-09-29T17:17:41.775Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.017654389">
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should return a warning when running in home directory" time="0.007580661">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should not return a warning when running in a project directory" time="0.003233608">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should return a warning when running in a root directory" time="0.001279835">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should not return a warning when running in a non-root directory" time="0.001478616">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; error handling &gt; should handle errors when checking directory" time="0.001838077">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/install.test.ts" timestamp="2025-09-29T17:17:41.776Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.032897954">
        <testcase classname="src/commands/extensions/install.test.ts" name="extensions install command &gt; should fail if no source is provided" time="0.025317003">
        </testcase>
        <testcase classname="src/commands/extensions/install.test.ts" name="extensions install command &gt; should fail if both git source and local path are provided" time="0.005760287">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/uninstall.test.ts" timestamp="2025-09-29T17:17:41.777Z" hostname="codespaces-4e4548" tests="1" failures="0" errors="0" skipped="0" time="0.025609918">
        <testcase classname="src/commands/extensions/uninstall.test.ts" name="extensions uninstall command &gt; should fail if no source is provided" time="0.023462656">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/add.test.ts" timestamp="2025-09-29T17:17:41.777Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.066217424">
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add a stdio server to project settings" time="0.037775477">
            <system-out>
MCP server &quot;my-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add an sse server to user settings" time="0.007444798">
            <system-out>
MCP server &quot;sse-server&quot; added to user settings. (sse)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add an http server to project settings" time="0.006836213">
            <system-out>
MCP server &quot;http-server&quot; added to project settings. (http)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should handle MCP server args with -- separator" time="0.005936285">
            <system-out>
MCP server &quot;my-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should handle unknown options as MCP server args" time="0.006085964">
            <system-out>
MCP server &quot;test-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/list.test.ts" timestamp="2025-09-29T17:17:41.779Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.013852592">
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display message when no servers configured" time="0.005733397">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display different server types with connected status" time="0.00384694">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display disconnected status when connection fails" time="0.000921348">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should merge extension servers with config servers" time="0.000974957">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/remove.test.ts" timestamp="2025-09-29T17:17:41.780Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.040489235">
        <testcase classname="src/commands/mcp/remove.test.ts" name="mcp remove command &gt; should remove a server from project settings" time="0.034209438">
            <system-out>
Server &quot;test-server&quot; removed from project settings.

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/remove.test.ts" name="mcp remove command &gt; should show a message if server not found" time="0.004146419">
        </testcase>
    </testsuite>
    <testsuite name="src/config/__tests__/env-persist.test.ts" timestamp="2025-09-29T17:17:41.781Z" hostname="codespaces-4e4548" tests="1" failures="0" errors="0" skipped="0" time="0.003810072">
        <testcase classname="src/config/__tests__/env-persist.test.ts" name="env persistence &gt; writes to discovered .env file and returns the path" time="0.002495933">
        </testcase>
    </testsuite>
    <testsuite name="src/config/extensions/variables.test.ts" timestamp="2025-09-29T17:17:41.782Z" hostname="codespaces-4e4548" tests="1" failures="0" errors="0" skipped="0" time="0.003924084">
        <testcase classname="src/config/extensions/variables.test.ts" name="hydrateString &gt; should replace a single variable" time="0.002230989">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/argumentProcessor.test.ts" timestamp="2025-09-29T17:17:41.782Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.012885339">
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should append the full command if args are provided" time="0.009809717">
        </testcase>
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should NOT append the full command if no args are provided" time="0.001036502">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/atFileProcessor.test.ts" timestamp="2025-09-29T17:17:41.783Z" hostname="codespaces-4e4548" tests="11" failures="0" errors="0" skipped="0" time="0.032514199">
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if no @{ trigger is present" time="0.006300976">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if config service is missing" time="0.001950807">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace a single valid @{path/to/file.txt} placeholder" time="0.002564942">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace multiple different @{...} placeholders" time="0.001634156">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should handle placeholders at the beginning, middle, and end" time="0.001220616">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should correctly parse paths that contain balanced braces" time="0.001276069">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should throw an error if the prompt contains an unclosed trigger" time="0.003078849">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Integration and Error Handling &gt; should leave the placeholder unmodified if readPathFromWorkspace throws" time="0.003210595">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{not-found.txt}&apos;: File not found. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with an ERROR on failure" time="0.004467228">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{bad-file.txt}&apos;: Access denied. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with a WARNING if the file was ignored" time="0.001569606">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should NOT call ui.addItem on success" time="0.002829334">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/injectionParser.test.ts" timestamp="2025-09-29T17:17:41.786Z" hostname="codespaces-4e4548" tests="21" failures="0" errors="0" skipped="0" time="0.01585778">
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should return an empty array if no trigger is present" time="0.003320881">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract a single, simple injection" time="0.000530148">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract multiple injections" time="0.001726509">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should handle different triggers (e.g., @{)" time="0.000271415">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle injections at the start and end of the prompt" time="0.000557439">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle adjacent injections" time="0.000692932">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle empty injections" time="0.000255366">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should trim whitespace within the content" time="0.000266487">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore similar patterns that are not the exact trigger" time="0.000206295">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore extra closing braces before the trigger" time="0.000737434">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should stop parsing at the first balanced closing brace (non-greedy)" time="0.000309857">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with simple nested braces (e.g., JSON)" time="0.000485355">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with shell constructs (e.g., awk)" time="0.000341506">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse multiple levels of nesting" time="0.000393043">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse paths containing balanced braces" time="0.000323643">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly handle an injection containing the trigger itself" time="0.000311561">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error for a simple unclosed injection" time="0.001158109">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error if the prompt ends inside a nested block" time="0.000315629">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should include the context name in the error message if provided" time="0.000361834">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw if content contains unbalanced braces (e.g., missing closing)" time="0.000368107">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should clearly state that unbalanced braces in content are not supported in the error" time="0.000335025">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/shellProcessor.test.ts" timestamp="2025-09-29T17:17:41.790Z" hostname="codespaces-4e4548" tests="33" failures="0" errors="0" skipped="0" time="0.095907103">
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw an error if config is missing" time="0.007944525">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not change the prompt if no shell injections are present" time="0.00263418">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process a single valid shell injection if allowed" time="0.005372114">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process multiple valid shell injections if all are allowed" time="0.001806528">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError if a command is not allowed in default mode" time="0.003405455">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should NOT throw ConfirmationRequiredError if a command is not allowed but approval mode is YOLO" time="0.001850279">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should still throw an error for a hard-denied command even in YOLO mode" time="0.002804708">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with the correct command" time="0.001521907">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with multiple commands if multiple are disallowed" time="0.008064786">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not execute any commands if at least one requires confirmation" time="0.002246588">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should only request confirmation for disallowed commands in a mixed prompt" time="0.005558701">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should execute all commands if they are on the session allowlist" time="0.001890915">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should trim whitespace from the command inside the injection before interpolation" time="0.001704067">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should handle an empty command inside the injection gracefully (skips execution)" time="0.001391144">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append exit code and command name on failure" time="0.001355306">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append signal info and command name if terminated by signal" time="0.001360055">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should throw a detailed error if the shell fails to spawn" time="0.00164738">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should report abort status with command name if aborted" time="0.001529972">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement if no shell injections are present (optimization path)" time="0.001521587">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement outside !{} blocks" time="0.001422141">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform escaped replacement inside !{} blocks" time="0.001548236">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should handle both raw (outside) and escaped (inside) injection simultaneously" time="0.001708665">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform security checks on the final, resolved (escaped) command" time="0.001657199">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should report the resolved command if a hard denial occurs" time="0.001303911">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should correctly handle multiline arguments" time="0.001516437">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;spaces&apos;" time="0.005684496">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;double quotes&apos;" time="0.001545781">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;single quotes&apos;" time="0.004048908">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (backticks)&apos;" time="0.002624082">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (dollar)&apos;" time="0.002654558">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;variable expansion&apos;" time="0.001549228">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (semicolon)&apos;" time="0.005668376">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (ampersand)&apos;" time="0.001530984">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/KeypressContext.test.tsx" timestamp="2025-09-29T17:17:41.797Z" hostname="codespaces-4e4548" tests="32" failures="0" errors="0" skipped="0" time="0.213104152">
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize regular enter key (keycode 13) in kitty protocol" time="0.045936671">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize numpad enter key (keycode 57414) in kitty protocol" time="0.004071289">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with modifiers" time="0.003742717">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Ctrl modifier" time="0.004541015">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Alt modifier" time="0.003437658">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should not process kitty sequences when kitty protocol is disabled" time="0.002991086">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Escape key handling &gt; should recognize escape key (keycode 27) in kitty protocol" time="0.003449372">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Tab key in kitty protocol" time="0.002864249">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Shift+Tab in kitty protocol" time="0.002399964">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Backspace key in kitty protocol" time="0.021306637">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Option+Backspace in kitty protocol" time="0.004303001">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; should handle multiline paste as a single event" time="0.008113204">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complete paste sequence with markers" time="0.006633466">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle empty paste sequence" time="0.003058451">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data before paste markers" time="0.005032431">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data after paste markers" time="0.004736179">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complex sequence with multiple paste blocks" time="0.007001681">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle fragmented paste markers across multiple data events" time="0.004585748">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle multiline content within paste markers" time="0.004429868">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle paste markers split across buffer boundaries" time="0.004384072">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; buffers fragmented paste chunks before emitting newlines" time="0.00730104">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should buffer input data and wait for timeout" time="0.003656897">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should concatenate new data and reset timeout" time="0.003947669">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should flush immediately when buffer exceeds limit" time="0.008220573">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should clear timeout when new data arrives" time="0.007921677">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle multiple separate keypress events" time="0.00520881">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle rapid sequential data within buffer limit" time="0.010706706">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should not log keystrokes when debugKeystrokeLogging is false" time="0.003118703">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer accumulation when debugKeystrokeLogging is true" time="0.003286707">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer overflow when debugKeystrokeLogging is true" time="0.003269464">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer clear on Ctrl+C when debugKeystrokeLogging is true" time="0.002284409">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should show char codes when debugKeystrokeLogging is true even without debug mode" time="0.003161163">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/SessionContext.test.tsx" timestamp="2025-09-29T17:17:41.804Z" hostname="codespaces-4e4548" tests="3" failures="0" errors="0" skipped="0" time="0.090217042">
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should provide the correct initial state" time="0.040977716">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SessionStatsProvider inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should update metrics when the uiTelemetryService emits an update" time="0.006416871">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SessionStatsProvider inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. Import `act` from `react` instead of `react-dom/test-utils`. See https://react.dev/warnings/react-dom-test-utils for more info.

            </system-err>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should throw an error when useSessionStats is used outside of a provider" time="0.03686538">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/AuthDialog.test.tsx" timestamp="2025-09-29T17:17:41.805Z" hostname="codespaces-4e4548" tests="10" failures="0" errors="0" skipped="0" time="0.570859418">
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should show an error if the initial auth type is invalid" time="0.075959525">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should detect GEMINI_API_KEY environment variable" time="0.02686063">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should not show the GEMINI_API_KEY message if QWEN_DEFAULT_AUTH_TYPE is set to something else" time="0.022306661">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should show the GEMINI_API_KEY message if QWEN_DEFAULT_AUTH_TYPE is set to use api key" time="0.018983146">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should select the auth type specified by QWEN_DEFAULT_AUTH_TYPE" time="0.017038812">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should fall back to default if QWEN_DEFAULT_AUTH_TYPE is not set" time="0.011938594">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should show an error and fall back to default if QWEN_DEFAULT_AUTH_TYPE is invalid" time="0.013836943">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should prevent exiting when no auth method is selected and show error message" time="0.13317175">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should not exit if there is already an error message" time="0.124368239">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should allow exiting when auth method is already selected" time="0.12401945">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ContextSummaryDisplay.test.tsx" timestamp="2025-09-29T17:17:41.807Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.068800678">
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on a single line on a wide screen" time="0.046777253">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on multiple lines on a narrow screen" time="0.008237455">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should switch layout at the 80-column breakpoint" time="0.0092273">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should not render empty parts" time="0.00259655">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/FolderTrustDialog.test.tsx" timestamp="2025-09-29T17:17:41.808Z" hostname="codespaces-4e4548" tests="6" failures="0" errors="0" skipped="0" time="0.273476318">
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should render the dialog with title and description" time="0.072518132">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call onSelect with DO_NOT_TRUST when escape is pressed and not restarting" time="0.083177142">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call onSelect when escape is pressed and is restarting" time="0.035393216">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should display restart message when isRestarting is true" time="0.022067936">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call process.exit when &quot;r&quot; is pressed and isRestarting is true" time="0.026219866">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call process.exit when &quot;r&quot; is pressed and isRestarting is false" time="0.03139869">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Footer.test.tsx" timestamp="2025-09-29T17:17:41.811Z" hostname="codespaces-4e4548" tests="13" failures="0" errors="0" skipped="0" time="0.134278355">
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; renders the component" time="0.04535664">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display shortened path on a wide terminal" time="0.007034924">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display only the base directory name on a narrow terminal" time="0.005484023">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use wide layout at 80 columns" time="0.005654351">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use narrow layout at 79 columns" time="0.005016761">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the branch name when provided" time="0.010300619">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; does not display the branch name when not provided" time="0.006170735">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the model name and context percentage" time="0.005441132">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display untrusted when isTrustedFolder is false" time="0.005454217">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display custom sandbox info when SANDBOX env is set" time="0.007777317">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display macOS Seatbelt info when SANDBOX is sandbox-exec" time="0.01111611">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display &quot;no sandbox&quot; when SANDBOX is not set and folder is trusted" time="0.008393606">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should prioritize untrusted message over sandbox info" time="0.004121283">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Header.test.tsx" timestamp="2025-09-29T17:17:41.814Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.092161426">
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders the long logo on a wide terminal" time="0.064233476">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders custom ASCII art when provided" time="0.003098826">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; displays the version number when nightly is true" time="0.014477336">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; does not display the version number when nightly is false" time="0.008010592">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/HistoryItemDisplay.test.tsx" timestamp="2025-09-29T17:17:41.815Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="0" time="0.189400304">
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type" time="0.045463776">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type with slash command" time="0.004650478">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders StatsDisplay for &quot;stats&quot; type" time="0.028367787">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders AboutBox for &quot;about&quot; type" time="0.037540347">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ModelStatsDisplay for &quot;model_stats&quot; type" time="0.014013642">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ToolStatsDisplay for &quot;tool_stats&quot; type" time="0.020795053">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders SessionSummaryDisplay for &quot;quit&quot; type" time="0.03612407">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/InputPrompt.test.tsx" timestamp="2025-09-29T17:17:41.816Z" hostname="codespaces-4e4548" tests="61" failures="0" errors="0" skipped="0" time="7.040749291">
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getPreviousCommand on up arrow in shell mode" time="0.156793052">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getNextCommand on down arrow in shell mode" time="0.114686182">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should set the buffer text when a shell history command is retrieved" time="0.114831767">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.addCommandToHistory on submit in shell mode" time="0.117407706">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call shell history methods when not in shell mode" time="0.218027134">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateUp for both up arrow and Ctrl+P when suggestions are showing" time="0.166167388">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateDown for both down arrow and Ctrl+N when suggestions are showing" time="0.165961645">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call completion navigation when suggestions are not showing" time="0.262889409">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle Ctrl+V when clipboard has an image" time="0.119959415">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should not insert anything when clipboard has no image" time="0.117486319">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle image save failure gracefully" time="0.114683283">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should insert image path at cursor position with proper spacing" time="0.124986055">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle errors during clipboard operations" time="0.120971553">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial parent command" time="0.117942952">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should append a sub-command when the parent command is already complete" time="0.120739865">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should handle the &quot;backspace&quot; edge case correctly" time="0.121744296">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial argument for a command" time="0.118795174">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete on Enter when suggestions are active, without submitting" time="0.120426381">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a command based on its altNames" time="0.119152563">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should not submit on Enter when the buffer is empty or only contains whitespace" time="0.117101844">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when isPerfectMatch is true" time="0.119256186">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when a complete leaf command is typed" time="0.116999946">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete an @-path on Enter without submitting" time="0.115849167">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should add a newline on enter when the line ends with a backslash" time="0.114566105">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should clear the buffer on Ctrl+C if it has text" time="0.113125627">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT clear the buffer on Ctrl+C if it is empty" time="0.114258675">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after @ without spaces" time="0.066196417">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after / without spaces" time="0.065392126">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following @" time="0.063949599">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following /" time="0.066346412">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is not after @ or /" time="0.066210532">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiline text correctly" time="0.067553896">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle single line slash command correctly" time="0.066398845">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters (emojis) correctly in paths" time="0.062500536">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with spaces after them" time="0.064261918">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in paths correctly" time="0.070711403">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion after unescaped space following escaped space" time="0.066333761">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiple escaped spaces in paths" time="0.06673516">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in slash commands" time="0.064395065">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with escaped spaces" time="0.061124251">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should not call buffer.handleInput when vim mode is enabled and vim handles the input" time="0.110978955">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call buffer.handleInput when vim mode is enabled but vim does not handle the input" time="0.128457144">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call handleInput when vim mode is disabled" time="0.115166834">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should handle bracketed paste when not focused" time="0.116045929">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should ignore regular keypresses when not focused" time="0.114962564">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \n newlines&apos;" time="0.130577935">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with extra slashes before \n newlines&apos;" time="0.118709771">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \r\n newlines&apos;" time="0.1156084">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should clear buffer on second ESC press" time="0.178771729">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should reset escape state on any non-ESC key" time="0.102694699">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC in shell mode by disabling shell mode" time="0.124565179">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC when completion suggestions are showing" time="0.122204463">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not call onEscapePromptChange when not provided" time="0.131558826">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not interfere with existing keyboard shortcuts" time="0.193617236">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; invokes reverse search on Ctrl+R" time="0.12414876">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; resets reverse search state on Escape" time="0.172081079">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; completes the highlighted entry on Tab and exits reverse-search" time="0.091000996">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; submits the highlighted entry on Enter and exits reverse-search" time="0.113914155">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; text and cursor position should be restored after reverse search" time="0.125152153">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line in multiline input" time="0.11844106">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line for single line input" time="0.125500116">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/LoadingIndicator.test.tsx" timestamp="2025-09-29T17:17:41.852Z" hostname="codespaces-4e4548" tests="15" failures="0" errors="0" skipped="0" time="0.121013068">
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should not render when streamingState is Idle" time="0.027920859">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner, phrase, and time when streamingState is Responding" time="0.016969613">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner (static), phrase but no time/cancel when streamingState is WaitingForConfirmation" time="0.004484931">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the currentLoadingPhrase correctly" time="0.004515266">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly when Responding" time="0.004484679">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly in human-readable format" time="0.003970381">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render rightContent when provided" time="0.004814665">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should transition correctly between states using rerender" time="0.011654275">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display fallback phrase if thought is empty" time="0.007947124">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the subject of a thought" time="0.007276482">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should prioritize thought.subject over currentLoadingPhrase" time="0.004803801">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on a single line on a wide terminal" time="0.004247147">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on multiple lines on a narrow terminal" time="0.005773833">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use wide layout at 80 columns" time="0.004409683">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use narrow layout at 79 columns" time="0.003997963">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSelectionDialog.test.tsx" timestamp="2025-09-29T17:17:41.856Z" hostname="codespaces-4e4548" tests="11" failures="0" errors="0" skipped="0" time="0.226757037">
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should setup escape key handler to call onCancel" time="0.061001461">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should not call onCancel for non-escape keys" time="0.012875931">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set correct initial index for current model" time="0.026528792">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set initial index to 0 when current model is not found" time="0.021653253">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should call onSelect when a model is selected" time="0.021642048">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle empty models array" time="0.008688987">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should create correct option items with proper labels" time="0.010963421">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show vision indicator for vision models" time="0.010757393">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show current indicator for the current model" time="0.009636293">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.02121941">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle multiple onSelect calls correctly" time="0.018646318">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelStatsDisplay.test.tsx" timestamp="2025-09-29T17:17:41.859Z" hostname="codespaces-4e4548" tests="6" failures="0" errors="0" skipped="0" time="0.299498313">
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should render &quot;no API calls&quot; message when there are no active models" time="0.047773554">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should not display conditional rows if no model has data for them" time="0.050107379">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display conditional rows if at least one model has data" time="0.068563425">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display stats for multiple models correctly" time="0.029180217">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.032041177">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display a single model correctly" time="0.062955073">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSwitchDialog.test.tsx" timestamp="2025-09-29T17:17:41.861Z" hostname="codespaces-4e4548" tests="11" failures="0" errors="0" skipped="0" time="0.190540409">
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup RadioButtonSelect with correct options" time="0.049371172">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect when an option is selected" time="0.013976022">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with SwitchSessionToVL when second option is selected" time="0.015841405">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with ContinueWithCurrentModel when third option is selected" time="0.019971034">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup escape key handler to call onSelect with ContinueWithCurrentModel" time="0.017043014">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should not call onSelect for non-escape keys" time="0.010799571">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should set initial index to 0 (first option)" time="0.010284842">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; VisionSwitchOutcome enum &gt; should have correct enum values" time="0.002195264">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle multiple onSelect calls correctly" time="0.024481744">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.009549441">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle escape key multiple times" time="0.01456492">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/OpenAIKeyPrompt.test.tsx" timestamp="2025-09-29T17:17:41.865Z" hostname="codespaces-4e4548" tests="3" failures="0" errors="0" skipped="0" time="0.169928634">
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should render the prompt correctly" time="0.066371882">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should show the component with proper styling" time="0.018881266">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should handle paste with control characters" time="0.082432295">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/QwenOAuthProgress.test.tsx" timestamp="2025-09-29T17:17:41.866Z" hostname="codespaces-4e4548" tests="22" failures="0" errors="0" skipped="0" time="0.391734753">
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state when deviceAuth is not provided" time="0.047171932">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state with gray border" time="0.010512328">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should render authentication flow when deviceAuth is provided" time="0.011091125">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should display correct URL in Static component when QR code is generated" time="0.037142066">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format time correctly" time="0.009257357">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format single digit seconds with leading zero" time="0.008011164">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should countdown and call onTimeout when timer expires" time="0.030453137">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should update time remaining display" time="0.017368676">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should use default 300 second timeout when deviceAuth is null" time="0.008274454">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Animated dots &gt; should cycle through animated dots" time="0.060465688">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should generate QR code when deviceAuth is provided" time="0.008667868">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should display QR code in Static component when available" time="0.019705682">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should handle QR code generation errors gracefully" time="0.009419649">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should not generate QR code when deviceAuth is null" time="0.007097751">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC key is pressed" time="0.024804379">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/spy/dist/index.js:96:15)
    at Object.spy [as generate] (file:///workspaces/LowCal-Code/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC is pressed in loading state" time="0.007653096">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should not call onCancel for other key presses" time="0.020665842">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/spy/dist/index.js:96:15)
    at Object.spy [as generate] (file:///workspaces/LowCal-Code/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should display initial timer value from deviceAuth" time="0.01092756">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/spy/dist/index.js:96:15)
    at Object.spy [as generate] (file:///workspaces/LowCal-Code/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should reset to loading state when deviceAuth becomes null" time="0.015057087">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/spy/dist/index.js:96:15)
    at Object.spy [as generate] (file:///workspaces/LowCal-Code/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/workspaces/LowCal-Code/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render timeout state when authStatus is timeout" time="0.00824576">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render default timeout message when no authMessage provided" time="0.00879251">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should call onCancel for any key press in timeout state" time="0.008256821">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SessionSummaryDisplay.test.tsx" timestamp="2025-09-29T17:17:41.873Z" hostname="codespaces-4e4548" tests="1" failures="0" errors="0" skipped="0" time="0.10873499">
        <testcase classname="src/ui/components/SessionSummaryDisplay.test.tsx" name="&lt;SessionSummaryDisplay /&gt; &gt; renders the summary display with a title" time="0.10603121">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SettingsDialog.test.tsx" timestamp="2025-09-29T17:17:41.873Z" hostname="codespaces-4e4548" tests="39" failures="0" errors="0" skipped="0" time="4.145621806">
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should render the settings dialog with default state" time="0.078085507">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should show settings list with default values" time="0.024675957">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should highlight first setting by default" time="0.035392498">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate down with arrow key" time="0.090188065">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate up with arrow key" time="0.130359592">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate with vim keys (j/k)" time="0.136706581">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should not navigate beyond bounds" time="0.08789336">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should toggle setting with Enter key" time="0.085291376">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should toggle setting with Space key" time="0.08284378">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should handle vim mode setting specially" time="0.080723505">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Scope Selection &gt; should switch between scopes" time="0.131740374">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Scope Selection &gt; should reset to settings focus when scope is selected" time="0.049283546">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Restart Prompt &gt; should show restart prompt for restart-required settings" time="0.083288757">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Restart Prompt &gt; should handle restart request when r is pressed" time="0.08762488">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Escape Key Behavior &gt; should call onSelect with undefined when Escape is pressed" time="0.047804712">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Persistence &gt; should persist settings across scope changes" time="0.129001669">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Persistence &gt; should show different values for different scopes" time="0.018139112">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Handling &gt; should handle vim mode toggle errors gracefully" time="0.083261345">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
Failed to toggle vim mode: Error: Toggle failed
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/ui/components/SettingsDialog.test.tsx:540:46
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:155:11
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:752:26
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1897:20
    at new Promise (&lt;anonymous&gt;)
    at runWithTimeout (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1863:10)
    at runTest (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1574:12)
    at runSuite (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1729:8)
    at runSuite (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1729:8)
    at runSuite (file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:1729:8)

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex State Management &gt; should track modified settings correctly" time="0.179869196">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Saving general.disableAutoUpdate immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex State Management &gt; should handle scrolling when there are many settings" time="0.178563322">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; VimMode Integration &gt; should sync with VimModeContext when vim mode is toggled" time="0.088151446">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should show correct display values for settings with different states" time="0.030594871">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should handle immediate settings save for non-restart-required settings" time="0.079225993">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should show restart prompt for restart-required settings" time="0.086879538">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should clear restart prompt when switching scopes" time="0.036850441">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Display Values &gt; should show correct values for inherited settings" time="0.022607584">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Display Values &gt; should show override indicator for overridden settings" time="0.041035608">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle rapid key presses gracefully" time="0.133458227">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle Ctrl+C to reset current setting to default" time="0.077239029">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle Ctrl+L to reset current setting to default" time="0.091951997">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle navigation when only one setting exists" time="0.138395007">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should properly handle Tab navigation between sections" time="0.061552589">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Recovery &gt; should handle malformed settings gracefully" time="0.025480949">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Recovery &gt; should handle missing setting definitions gracefully" time="0.02300292">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should handle complete user workflow: navigate, toggle, change scope, exit" time="0.07162268">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should allow changing multiple settings without losing pending changes" time="0.28994558">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Saving general.disableAutoUpdate immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [ [32m&apos;general.enablePromptCompletion&apos;[39m ] Needs restart: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should maintain state consistency during complex interactions" time="0.290844521">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should handle restart workflow correctly" time="0.085772465">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; String Settings Editing &gt; should allow editing and committing a string setting" time="0.64612207">
            <system-out>
[DEBUG SettingsDialog] Modified settings: [ [32m&apos;ui.accessibility.disableLoadingPhrases&apos;[39m ] Needs restart: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [ [32m&apos;ui.accessibility.disableLoadingPhrases&apos;[39m ] Needs restart: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [ [32m&apos;ui.accessibility.disableLoadingPhrases&apos;[39m ] Needs restart: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ShellConfirmationDialog.test.tsx" timestamp="2025-09-29T17:17:41.907Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.159711875">
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; renders correctly" time="0.065474597">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedOnce when &quot;Yes, allow once&quot; is selected" time="0.041081139">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedAlways when &quot;Yes, allow always for this session&quot; is selected" time="0.024111899">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with Cancel when &quot;No (esc)&quot; is selected" time="0.026009013">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/StatsDisplay.test.tsx" timestamp="2025-09-29T17:17:41.908Z" hostname="codespaces-4e4548" tests="12" failures="0" errors="0" skipped="0" time="0.414051847">
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders only the Performance section in its zero state" time="0.09175036">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders a table with two models correctly" time="0.064431601">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders all sections when all data is present" time="0.039716332">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides User Agreement when no decisions are made" time="0.029190293">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides Efficiency section when cache is not used" time="0.020941747">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in green for high values" time="0.023800811">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in yellow for medium values" time="0.026930999">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in red for low values" time="0.016094582">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; displays Code Changes when line counts are present" time="0.030054131">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; hides Code Changes when no lines are added or removed" time="0.014999059">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the default title when no title prop is provided" time="0.020803008">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the custom title when a title prop is provided" time="0.031984592">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/TodoDisplay.test.tsx" timestamp="2025-09-29T17:17:41.913Z" hostname="codespaces-4e4548" tests="6" failures="0" errors="0" skipped="0" time="0.086235437">
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render todo list" time="0.057308565">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should display correct status icons" time="0.016059426">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle empty todo list" time="0.001461454">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle undefined todos" time="0.00079893">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with different statuses" time="0.004776153">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with mixed statuses" time="0.003691561">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ToolStatsDisplay.test.tsx" timestamp="2025-09-29T17:17:41.915Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.151687787">
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should render &quot;no tool calls&quot; message when there are no active tools" time="0.043560907">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for a single tool correctly" time="0.019734529">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for multiple tools correctly" time="0.022737554">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.040027727">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle zero decisions gracefully" time="0.023038445">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/aboutCommand.test.ts" timestamp="2025-09-29T17:17:41.917Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.019322889">
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should have the correct name and description" time="0.005646065">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should call addItem with all version info" time="0.006063192">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show the correct sandbox environment variable" time="0.002390466">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show sandbox-exec profile when applicable" time="0.001423143">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should not show ide client when it is not detected" time="0.001892277">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/approvalModeCommand.test.ts" timestamp="2025-09-29T17:17:41.919Z" hostname="codespaces-4e4548" tests="19" failures="0" errors="0" skipped="0" time="0.055385039">
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should have the correct command properties" time="0.012997508">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should show current mode, options, and usage when no arguments provided" time="0.001703967">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when config is not available" time="0.003369992">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should change approval mode when valid mode is provided" time="0.00650356">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should accept canonical auto-edit mode value" time="0.00173817">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should accept auto-edit alias for compatibility" time="0.001626552">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when invalid mode is provided" time="0.001709897">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when setApprovalMode throws an error" time="0.001545601">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting auto-edit with user scope via nested subcommands" time="0.001713835">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting plan with project scope via nested subcommands" time="0.00167353">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting plan with session scope via nested subcommands" time="0.001529401">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow providing a scope argument after selecting a mode subcommand" time="0.001626291">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support --user plan pattern (scope first)" time="0.001524752">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support plan --user pattern (mode first)" time="0.00155059">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support --project auto-edit pattern" time="0.001580256">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when only scope flag is provided" time="0.003420866">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when multiple scope flags are provided" time="0.002054199">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should surface a helpful error when scope subcommands receive extra arguments" time="0.001566189">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should provide completion for approval modes" time="0.003482391">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/authCommand.test.ts" timestamp="2025-09-29T17:17:41.925Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.00976877">
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should return a dialog action to open the auth dialog" time="0.005806624">
        </testcase>
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should have the correct name and description" time="0.001940297">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/bugCommand.test.ts" timestamp="2025-09-29T17:17:41.926Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.012005306">
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should generate the default GitHub issue URL" time="0.00864386">
        </testcase>
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should use a custom URL template from config if provided" time="0.001283984">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/chatCommand.test.ts" timestamp="2025-09-29T17:17:41.927Z" hostname="codespaces-4e4548" tests="17" failures="0" errors="0" skipped="0" time="0.060681032">
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; should have the correct main command definition" time="0.006381506">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should inform when no checkpoints are found" time="0.00322394">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should list found checkpoints" time="0.002986117">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should handle invalid date formats gracefully" time="0.001630079">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return an error if tag is missing" time="0.001953401">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should inform if conversation history is empty or only contains system context" time="0.004215879">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return confirm_action if checkpoint already exists" time="0.004836586">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should save the conversation if overwrite is confirmed" time="0.002779351">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should return an error if tag is missing" time="0.002211282">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should inform if checkpoint is not found" time="0.001664643">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should resume a conversation" time="0.002359909">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should provide completion suggestions" time="0.00187777">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should suggest filenames sorted by modified time (newest first)" time="0.001906364">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if tag is missing" time="0.002068717">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if checkpoint is not found" time="0.002080498">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should delete the conversation" time="0.010006292">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; completion &gt; should provide completion suggestions" time="0.005661562">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/clearCommand.test.ts" timestamp="2025-09-29T17:17:41.931Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.010125004">
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should set debug message, reset chat, reset telemetry, and clear UI when config is available" time="0.006318688">
        </testcase>
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should not attempt to reset chat if config service is not available" time="0.001940587">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/compressCommand.test.ts" timestamp="2025-09-29T17:17:41.932Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.020539007">
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should do nothing if a compression is already pending" time="0.009758321">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should set pending item, call tryCompressChat, and add result on success" time="0.003529189">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat returns falsy" time="0.001170533">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat throws" time="0.001262624">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should clear the pending item in a finally block" time="0.000912">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/copyCommand.test.ts" timestamp="2025-09-29T17:17:41.934Z" hostname="codespaces-4e4548" tests="11" failures="0" errors="0" skipped="0" time="0.026426859">
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no history is available" time="0.006251411">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when history is empty" time="0.001176333">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no AI messages are found in history" time="0.000993662">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should copy last AI message to clipboard successfully" time="0.002565272">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle multiple text parts in AI message" time="0.001469439">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should filter out non-text parts" time="0.001149092">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should get the last AI message when multiple AI messages exist" time="0.002218265">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle clipboard copy error" time="0.002996446">
            <system-out>
Clipboard access denied

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle non-Error clipboard errors" time="0.001707472">
            <system-out>
String error

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no text parts found in AI message" time="0.001464841">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle unavailable config service" time="0.002370349">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/corgiCommand.test.ts" timestamp="2025-09-29T17:17:41.937Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.009620864">
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should call the toggleCorgiMode function on the UI context" time="0.006180781">
        </testcase>
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should have the correct name and description" time="0.001433722">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/directoryCommand.test.tsx" timestamp="2025-09-29T17:17:41.938Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="0" time="0.018250259">
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; show &gt; should display the list of directories" time="0.00878212">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if no path is provided" time="0.0011802">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory and show a success message for a single path" time="0.001501178">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory for each path and show a success message for multiple paths" time="0.001198955">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if addDirectory throws an exception" time="0.000983433">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should handle a mix of successful and failed additions" time="0.001372228">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; should correctly expand a Windows-style home directory path" time="0.001002659">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/docsCommand.test.ts" timestamp="2025-09-29T17:17:41.940Z" hostname="codespaces-4e4548" tests="3" failures="0" errors="0" skipped="0" time="0.015149359">
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should add an info message and call &apos;open&apos; in a non-sandbox environment" time="0.009316156">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should only add an info message in a sandbox environment" time="0.002073094">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should not open browser for &apos;sandbox-exec&apos;" time="0.001452958">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/editorCommand.test.ts" timestamp="2025-09-29T17:17:41.941Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.007690756">
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should return a dialog action to open the editor dialog" time="0.005222274">
        </testcase>
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should have the correct name and description" time="0.000432095">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/exportCommand.test.ts" timestamp="2025-09-29T17:17:41.941Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.042405267">
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should have correct name and description" time="0.004073975">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should export conversation with default filename" time="0.032903464">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle custom filename" time="0.001564978">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle export error" time="0.001526606">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/extensionsCommand.test.ts" timestamp="2025-09-29T17:17:41.943Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.013299281">
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should display &quot;No active extensions.&quot; when none are found" time="0.009658033">
        </testcase>
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should list active extensions when they are found" time="0.001558735">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/helpCommand.test.ts" timestamp="2025-09-29T17:17:41.943Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.014280841">
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should add a help message to the UI history" time="0.011030161">
        </testcase>
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should have the correct command properties" time="0.001320502">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/ideCommand.test.ts" timestamp="2025-09-29T17:17:41.944Z" hostname="codespaces-4e4548" tests="9" failures="0" errors="0" skipped="0" time="5.0286083">
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return null if config is not provided" time="0.002584518">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return the ide command" time="0.002980967">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should show disable command when connected" time="0.001508201">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connected status" time="0.00251604">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connecting status" time="0.001075104">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status" time="0.001023407">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status with details" time="0.001088119">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should install the extension" time="5.012077004">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should show an error if installation fails" time="0.00172242">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/initCommand.test.ts" timestamp="2025-09-29T17:17:41.947Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.02022878">
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should ask for confirmation if QWEN.md already exists and is non-empty" time="0.006804835">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should create QWEN.md and submit a prompt if it does not exist" time="0.005532133">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should proceed to initialize when QWEN.md exists but is empty" time="0.002126265">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should regenerate QWEN.md when overwrite is confirmed" time="0.001687896">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should return an error if config is not available" time="0.00191507">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/loggingCommand.test.ts" timestamp="2025-09-29T17:17:41.949Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.0195757">
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; enables logging when /logging on is issued" time="0.010394506">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; disables logging when /logging off is issued" time="0.002214508">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; reports status when invoked without arguments" time="0.001984209">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; shows usage for unknown arguments" time="0.002934971">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/mcpCommand.test.ts" timestamp="2025-09-29T17:17:41.950Z" hostname="codespaces-4e4548" tests="35" failures="0" errors="0" skipped="0" time="0.10189885">
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if config is not available" time="0.0063627">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if tool registry is not available" time="0.001924617">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; no MCP servers configured &gt; should display a message with a URL when no MCP servers are configured" time="0.001748329">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display configured MCP servers with status indicators and their tools" time="0.007246638">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display tool descriptions when desc argument is used" time="0.002627098">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should not display descriptions when nodesc argument is used" time="0.002256216">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should indicate when a server has no tools" time="0.002136652">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should show startup indicator when servers are connecting" time="0.002104573">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display the extension name for servers from extensions" time="0.001654163">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display blocked MCP servers" time="0.001751956">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display both active and blocked servers correctly" time="0.00186163">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should display tool schemas when schema argument is used" time="0.002649689">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should handle tools without parameter schemas gracefully" time="0.002072503">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;descriptions&quot; as alias for &quot;desc&quot;" time="0.00385724">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodescriptions&quot; as alias for &quot;nodesc&quot;" time="0.001956767">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle mixed case arguments" time="0.002143726">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;schema desc&quot;" time="0.00190406">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;desc schema&quot;" time="0.001841773">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;schema&quot; alone showing descriptions" time="0.00177026">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;schema&quot; - &quot;schema nodesc&quot;" time="0.001725176">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;desc&quot; - &quot;desc nodesc&quot;" time="0.001565338">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding both &quot;desc&quot; and &quot;schema&quot; - &quot;desc schema nodesc&quot;" time="0.001514673">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle extra whitespace in arguments" time="0.001623056">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle empty arguments gracefully" time="0.002956672">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle unknown arguments gracefully" time="0.002383213">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle empty server names gracefully" time="0.001970092">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle servers with special characters in names" time="0.00216751">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should list OAuth-enabled servers when no server name is provided" time="0.011829934">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should show message when no OAuth servers are configured" time="0.001744963">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should authenticate with a specific server" time="0.005032512">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle authentication errors" time="0.002872535">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle non-existent server" time="0.002562527">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should refresh the list of tools and display the status" time="0.004805839">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if config is not available" time="0.002024553">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if tool registry is not available" time="0.001589854">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/memoryCommand.test.ts" timestamp="2025-09-29T17:17:41.959Z" hostname="codespaces-4e4548" tests="11" failures="0" errors="0" skipped="0" time="0.031047795">
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display a message if memory is empty" time="0.012395075">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display the memory content and file count if it exists" time="0.001327585">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return an error message if no arguments are provided" time="0.002269681">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return a tool action and add an info message when arguments are provided" time="0.001206309">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --global flag and add scope to tool args" time="0.001124847">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --project flag and add scope to tool args" time="0.001489367">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return error if flag is provided but no fact follows" time="0.001021734">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with content" time="0.002170125">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with no content" time="0.001318128">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display an error message if refreshing fails" time="0.001665714">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should not throw if config service is unavailable" time="0.002632908">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/modelCommand.test.ts" timestamp="2025-09-29T17:17:41.961Z" hostname="codespaces-4e4548" tests="9" failures="0" errors="0" skipped="0" time="0.016371878">
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should have the correct name and description" time="0.00389983">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when config is not available" time="0.002274409">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when content generator config is not available" time="0.001284475">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when auth type is not available" time="0.001086756">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for QWEN_OAUTH auth type" time="0.001143011">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for USE_OPENAI auth type when model is available" time="0.001034688">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for USE_OPENAI auth type when no model is available" time="0.001119497">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for unsupported auth types" time="0.001006006">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should handle undefined auth type" time="0.000993572">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/privacyCommand.test.ts" timestamp="2025-09-29T17:17:41.963Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.00865833">
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should return a dialog action to open the privacy dialog" time="0.00547751">
        </testcase>
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should have the correct name and description" time="0.001123384">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/quitCommand.test.ts" timestamp="2025-09-29T17:17:41.963Z" hostname="codespaces-4e4548" tests="1" failures="0" errors="0" skipped="0" time="0.011374753">
        <testcase classname="src/ui/commands/quitCommand.test.ts" name="quitCommand &gt; returns a QuitActionReturn object with the correct messages" time="0.009391296">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/restoreCommand.test.ts" timestamp="2025-09-29T17:17:41.964Z" hostname="codespaces-4e4548" tests="13" failures="0" errors="0" skipped="0" time="0.071140674">
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return null if checkpointing is not enabled" time="0.016380167">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return the command if checkpointing is enabled" time="0.004099602">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if temp dir is not found" time="0.003910429">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should inform when no checkpoints are found if no args are passed" time="0.004462098">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should list available checkpoints if no args are passed" time="0.004468129">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if the specified file is not found" time="0.003429192">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should handle file read errors gracefully" time="0.004128345">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore a tool call and project state" time="0.008055155">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore even if only toolCall is present" time="0.00436145">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return an error for a checkpoint file missing the toolCall property" time="0.004664655">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array if temp dir is not found" time="0.003450142">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array on readdir error" time="0.002822241">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return a list of checkpoint names" time="0.004553368">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/settingsCommand.test.ts" timestamp="2025-09-29T17:17:41.967Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.008960463">
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should return a dialog action to open the settings dialog" time="0.005579491">
        </testcase>
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should have the correct name and description" time="0.001341561">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/setupGithubCommand.test.ts" timestamp="2025-09-29T17:17:41.967Z" hostname="codespaces-4e4548" tests="8" failures="0" errors="0" skipped="0" time="0.070643122">
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="setupGithubCommand &gt; returns a tool action to download github workflows and handles paths" time="0.036494699">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; creates a new .gitignore file when none exists" time="0.002841537">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; appends entries to existing .gitignore file" time="0.00209796">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not add duplicate entries" time="0.001651598">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; adds only missing entries when some already exist" time="0.00172761">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not get confused by entries in comments or as substrings" time="0.003322704">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles file system errors gracefully" time="0.015642436">
            <system-out>
Failed to update .gitignore: Error: ENOENT: no such file or directory, open &apos;/tmp/update-gitignore-Pixt6i/non-existent/.gitignore&apos;
[90m    at open (node:internal/fs/promises:639:25)[39m
[90m    at Object.writeFile (node:internal/fs/promises:1213:14)[39m
    at Module.updateGitignore [90m(/workspaces/LowCal-Code/packages/cli/[39msrc/ui/commands/setupGithubCommand.ts:71:7[90m)[39m
    at [90m/workspaces/LowCal-Code/packages/cli/[39msrc/ui/commands/setupGithubCommand.test.ts:218:5
    at file:///workspaces/LowCal-Code/node_modules/[4m@vitest[24m/runner/dist/chunk-hooks.js:752:20 {
  errno: [33m-2[39m,
  code: [32m&apos;ENOENT&apos;[39m,
  syscall: [32m&apos;open&apos;[39m,
  path: [32m&apos;/tmp/update-gitignore-Pixt6i/non-existent/.gitignore&apos;[39m
}

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles permission errors gracefully" time="0.004478328">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/statsCommand.test.ts" timestamp="2025-09-29T17:17:41.969Z" hostname="codespaces-4e4548" tests="3" failures="0" errors="0" skipped="0" time="0.040952058">
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display general session stats when run with no subcommand" time="0.034384603">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display model stats when using the &quot;model&quot; subcommand" time="0.002593337">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display tool stats when using the &quot;tools&quot; subcommand" time="0.001299693">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/terminalSetupCommand.test.ts" timestamp="2025-09-29T17:17:41.970Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.008633794">
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should have correct metadata" time="0.00290241">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return success message when terminal setup succeeds" time="0.002311349">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should append restart message when terminal setup requires restart" time="0.000480927">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return error message when terminal setup fails" time="0.000502046">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should handle exceptions from terminal setup" time="0.000474635">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/themeCommand.test.ts" timestamp="2025-09-29T17:17:41.971Z" hostname="codespaces-4e4548" tests="2" failures="0" errors="0" skipped="0" time="0.008598107">
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should return a dialog action to open the theme dialog" time="0.005327991">
        </testcase>
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should have the correct name and description" time="0.001213021">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/toolsCommand.test.ts" timestamp="2025-09-29T17:17:41.972Z" hostname="codespaces-4e4548" tests="4" failures="0" errors="0" skipped="0" time="0.018707112">
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display an error if the tool registry is unavailable" time="0.010243164">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display &quot;No tools available&quot; when none are found" time="0.002485593">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools without descriptions by default" time="0.001865026">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools with descriptions when &quot;desc&quot; arg is passed" time="0.001852473">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/color-utils.test.ts" timestamp="2025-09-29T17:17:41.973Z" hostname="codespaces-4e4548" tests="16" failures="0" errors="0" skipped="0" time="0.021390754">
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate hex colors" time="0.002594716">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names" time="0.001137772">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names case insensitive" time="0.000276806">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names" time="0.000564502">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names case insensitive" time="0.000288367">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should reject invalid color names" time="0.000286694">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve hex colors" time="0.000428499">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve Ink-supported color names" time="0.000559733">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve CSS color names to hex" time="0.000511092">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should handle case insensitive color names" time="0.000238395">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should return undefined for invalid colors" time="0.00246246">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should contain expected CSS color mappings" time="0.000393975">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should not contain Ink-supported color names" time="0.000339032">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should contain all Ink-supported color names" time="0.000827011">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should not contain CSS color names" time="0.000293447">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; Consistency between validation and resolution &gt; should have consistent behavior between isValidColor and resolveColor" time="0.007643758">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme-manager.test.ts" timestamp="2025-09-29T17:17:41.976Z" hostname="codespaces-4e4548" tests="12" failures="0" errors="0" skipped="0" time="0.05146279">
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should load valid custom themes" time="0.005675941">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get the active theme" time="0.000841379">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get a custom active theme" time="0.000873649">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return false when setting a non-existent theme" time="0.000672053">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should list available themes including custom themes" time="0.024401707">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should get a theme by name" time="0.000784032">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should fall back to default theme if active theme is invalid" time="0.000472701">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return NoColorTheme if NO_COLOR is set" time="0.000530769">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should load a theme from a valid file path" time="0.004672901">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme if the file does not exist" time="0.002244143">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from a file with invalid JSON" time="0.004443764">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from an untrusted file path and log a message" time="0.003832614">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme.test.ts" timestamp="2025-09-29T17:17:41.979Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.005635124">
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a valid theme" time="0.001988837">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with an invalid name" time="0.000393413">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a theme missing optional DiffAdded and DiffRemoved colors" time="0.000226642">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with a very long name" time="0.000235238">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="themeManager.loadCustomThemes &gt; should use values from DEFAULT_THEME when DiffAdded and DiffRemoved are not provided" time="0.001135015">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/atCommandProcessor.test.ts" timestamp="2025-09-29T17:17:41.980Z" hostname="codespaces-4e4548" tests="39" failures="0" errors="0" skipped="0" time="0.694755066">
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through query if no @ command is present" time="0.008396442">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through original query if only a lone @ symbol is present" time="0.004695488">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid text file path" time="0.11491472">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid directory path and convert to glob" time="0.02003512">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle query with text before and after @command" time="0.030641077">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should correctly unescape paths with escaped spaces" time="0.017103219">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references" time="0.016074207">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references with interleaved text" time="0.016274845">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle a mix of valid, invalid, and lone @ references" time="0.034443415">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should return original query if all @paths are invalid or lone @" time="0.005360452">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should skip git-ignored files in @ commands" time="0.007796443">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-04q60P/node_modules/package.json

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should process non-git-ignored files normally" time="0.022431086">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should handle mixed git-ignored and valid files" time="0.030484693">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-Dq7S4E/.env

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should always ignore .git directory files" time="0.005998464">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-xiRToD/.git/config

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; when recursive file search is disabled &gt; should not use glob search for a nonexistent file" time="0.00166361">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; gemini-ignore filtering &gt; should skip gemini-ignored files in @ commands" time="0.003198362">
            <system-out>
Ignored 1 files:
Gemini-ignored: /tmp/folder-structure-test-zPKRR3/build/output.js

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process non-ignored files when .qwenignore is present" time="0.031756276">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle mixed gemini-ignored and valid files" time="0.022123332">
            <system-out>
Ignored 1 files:
Gemini-ignored: /tmp/folder-structure-test-8r2EgS/dist/bundle.js

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;comma&apos;" time="0.011802291">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;period&apos;" time="0.014764254">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;semicolon&apos;" time="0.010748604">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;exclamation mark&apos;" time="0.02528874">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;question mark&apos;" time="0.015026966">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening parenthesis&apos;" time="0.013305343">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing parenthesis&apos;" time="0.012719059">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening square bracket&apos;" time="0.012239265">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing square bracket&apos;" time="0.015755111">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening curly brace&apos;" time="0.015657487">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing curly brace&apos;" time="0.020178464">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle multiple @paths terminated by different punctuation" time="0.015777951">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should still handle escaped spaces in paths before punctuation" time="0.01001725">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not break file paths with periods in extensions" time="0.012792678">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle file paths ending with period followed by space" time="0.014694073">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle comma termination with complex file paths" time="0.012116144">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not terminate at period within file name" time="0.010348828">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle end of string termination for period and comma" time="0.012265239">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle files with special characters in names" time="0.013553475">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle basic file names without special characters" time="0.013922423">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should not add the user&apos;s turn to history, as that is the caller&apos;s responsibility" time="0.015163195">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/shellCommandProcessor.test.ts" timestamp="2025-09-29T17:17:41.988Z" hostname="codespaces-4e4548" tests="12" failures="0" errors="0" skipped="0" time="0.072348845">
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should initiate command execution and set pending state" time="0.026052696">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle successful execution and update history correctly" time="0.004850852">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command failure and display error status" time="0.004103229">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should throttle pending UI updates for text streams" time="0.006831164">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should show binary progress messages correctly" time="0.00406091">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should not wrap the command on Windows" time="0.003114586">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command abort and display cancelled status" time="0.00411972">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle binary output result correctly" time="0.003113013">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle promise rejection and show an error" time="0.003766521">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle synchronous errors during execution and clean up resources" time="0.003602706">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should show a warning if the working directory changes" time="0.002802924">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should NOT show a warning if the directory does not change" time="0.002916767">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/slashCommandProcessor.test.ts" timestamp="2025-09-29T17:17:41.991Z" hostname="codespaces-4e4548" tests="35" failures="0" errors="0" skipped="0" time="2.024314441">
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should initialize CommandService with all required loaders" time="0.032292455">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should call loadCommands and populate state after mounting" time="0.06170507">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should provide an immutable array of commands to consumers" time="0.056736499">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should override built-in commands with file-based commands of the same name" time="0.059854723">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display an error for an unknown command" time="0.00492482">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display help for a parent command invoked without a subcommand" time="0.05686754">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should correctly find and execute a nested subcommand" time="0.062038852">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the the input is not a command" time="0.012856205">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the command has an error" time="0.005564974">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should set isProcessing to true during execution and false afterwards" time="0.106043412">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: theme&quot; action" time="0.056461591">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: model&quot; action" time="0.056210496">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;load_history&quot; action" time="0.054694515">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should handle a &quot;quit&quot; action" time="0.057861308">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should call runExitCleanup when handling a &quot;quit&quot; action" time="0.055980926">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a file-based command" time="0.055060898">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a mcp-based command" time="0.055455979">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should set confirmation request when action returns confirm_shell_commands" time="0.109490421">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should do nothing if user cancels confirmation" time="0.107566203">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command with one-time allowlist on &quot;Proceed Once&quot;" time="0.10768385">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command and update session allowlist on &quot;Proceed Always&quot;" time="0.108965202">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should be case-sensitive" time="0.055092894">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should correctly match an altName" time="0.05497515">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle extra whitespace around the command" time="0.055678469">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle `?` as a command prefix" time="0.054036689">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should override mcp-based commands with file-based commands of the same name" time="0.05716114">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should prioritize a command with a primary name over a command with a matching alias" time="0.057208205">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should add an overridden command to the history" time="0.055249027">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Lifecycle &gt; should abort command loading when the hook unmounts" time="0.004004916">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a simple slash command" time="0.055395562">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs nothing for a bogus command" time="0.055177006">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs a failure event for a failed command" time="0.057031789">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a slash command with a subcommand" time="0.057809712">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log the command path when an alias is used" time="0.055700164">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should not log for unknown commands" time="0.060841506">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAtCompletion.test.ts" timestamp="2025-09-29T17:17:41.998Z" hostname="codespaces-4e4548" tests="13" failures="0" errors="0" skipped="0" time="1.038532666">
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should perform a recursive search for an empty pattern" time="0.08347709">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should correctly filter the recursive list based on a pattern" time="0.056489691">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should append a trailing slash to directory paths in suggestions" time="0.056321137">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should be in a loading state during initial file system crawl" time="0.055513792">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should NOT show a loading indicator for subsequent searches that complete under 200ms" time="0.114423906">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should show a loading indicator and clear old suggestions for subsequent searches that take longer than 200ms" time="0.114162429">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should abort the previous search when a new one starts" time="0.160044868">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in a READY state" time="0.055486789">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in an ERROR state" time="0.055547144">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should respect .gitignore files" time="0.05800745">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should work correctly when config is undefined" time="0.057283703">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should reset and re-initialize when the cwd changes" time="0.112738508">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should perform a non-recursive search when enableRecursiveFileSearch is false" time="0.056214209">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAutoAcceptIndicator.test.ts" timestamp="2025-09-29T17:17:42.001Z" hostname="codespaces-4e4548" tests="10" failures="0" errors="0" skipped="0" time="0.068220867">
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.AUTO_EDIT if config.getApprovalMode returns ApprovalMode.AUTO_EDIT" time="0.028276689">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.DEFAULT if config.getApprovalMode returns ApprovalMode.DEFAULT" time="0.003399897">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.YOLO if config.getApprovalMode returns ApprovalMode.YOLO" time="0.003384139">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.PLAN if config.getApprovalMode returns ApprovalMode.PLAN" time="0.003066066">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should cycle approval modes when Shift+Tab is pressed" time="0.00874446">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should not toggle if only one key or other keys combinations are pressed" time="0.00424315">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should update indicator when config value changes externally (useEffect dependency)" time="0.003872897">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from DEFAULT to AUTO_EDIT" time="0.00553073">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from AUTO_EDIT to YOLO" time="0.002401687">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should cycle from YOLO to PLAN when Shift+Tab is pressed" time="0.00247861">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useCommandCompletion.test.ts" timestamp="2025-09-29T17:17:42.004Z" hostname="codespaces-4e4548" tests="17" failures="0" errors="0" skipped="0" time="0.158600663">
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.036054984">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when completion mode becomes IDLE" time="0.020463921">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset all state to default values" time="0.009197195">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should call useAtCompletion with the correct query for an escaped space" time="0.01004279">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should correctly identify the completion context with multiple @ symbols" time="0.012478812">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.005219599">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.003333173">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.005742455">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.006239922">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.0082881">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should automatically select the first item when suggestions are available" time="0.00458163">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a partial command" time="0.005915347">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path" time="0.006896876">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path when cursor is not at the end of the line" time="0.010815521">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for line comments" time="0.003499784">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for block comments" time="0.003110218">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should trigger prompt completion for regular text when enabled" time="0.003370813">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useConsoleMessages.test.ts" timestamp="2025-09-29T17:17:42.008Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="0" time="0.056079544">
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should initialize with an empty array of console messages" time="0.025964497">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should add a new message when log is called" time="0.008045748">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should batch and count identical consecutive messages" time="0.003484054">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should not batch different messages" time="0.003199083">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear all messages when clearConsoleMessages is called" time="0.004990753">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear the pending timeout when clearConsoleMessages is called" time="0.005076513">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clean up the timeout on unmount" time="0.002560994">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useEditorSettings.test.ts" timestamp="2025-09-29T17:17:42.009Z" hostname="codespaces-4e4548" tests="10" failures="0" errors="0" skipped="0" time="0.061024918">
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should initialize with dialog closed" time="0.026449517">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should open editor dialog when openEditorDialog is called" time="0.004122495">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should close editor dialog when exitEditorDialog is called" time="0.002976769">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle editor selection successfully" time="0.007327048">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle clearing editor preference (undefined editor)" time="0.003164629">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different editor types" time="0.003323405">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different setting scopes" time="0.002912048">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for unavailable editors" time="0.002772178">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for editors not allowed in sandbox" time="0.002814586">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle errors during editor selection" time="0.002605937">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFocus.test.ts" timestamp="2025-09-29T17:17:42.011Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.058899849">
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should initialize with focus and enable focus reporting" time="0.027928621">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to false when a focus-out event is received" time="0.004222712">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to true when a focus-in event is received" time="0.00718996">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should clean up and disable focus reporting on unmount" time="0.003676453">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should handle multiple focus events correctly" time="0.013030087">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFolderTrust.test.ts" timestamp="2025-09-29T17:17:42.013Z" hostname="codespaces-4e4548" tests="9" failures="0" errors="0" skipped="0" time="0.077862406">
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already trusted" time="0.034033295">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already untrusted" time="0.003863331">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should open dialog when folder trust is undefined" time="0.003439552">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_FOLDER choice" time="0.007600579">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_PARENT choice" time="0.005791325">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle DO_NOT_TRUST choice and trigger restart" time="0.010331429">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should do nothing for default choice" time="0.003661766">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should set isRestarting to true when trust status changes from false to true" time="0.002963986">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not set isRestarting to true when trust status does not change" time="0.002836076">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGeminiStream.test.tsx" timestamp="2025-09-29T17:17:42.014Z" hostname="codespaces-4e4548" tests="33" failures="0" errors="0" skipped="0" time="0.623213168">
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not submit tool responses if not all tool calls are completed" time="0.059826749">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should submit tool responses when all tool calls are completed and ready" time="0.017313626">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should handle all tool calls being cancelled" time="0.006309336">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should group multiple cancelled tool call responses into a single history entry" time="0.005858411">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not flicker streaming state to Idle between tool completion and submission" time="0.008831147">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should cancel an in-progress stream when escape is pressed" time="0.009948475">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should call onCancelSubmit handler when escape is pressed" time="0.005299028">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not do anything if escape is pressed when not responding" time="0.004114189">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should prevent further processing after cancellation" time="0.066006658">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not cancel if a tool call is in progress (not just responding)" time="0.005307243">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should schedule a tool call when the command processor returns a schedule_tool action" time="0.008430117">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should stop processing and not call Gemini when a command is handled without a tool call" time="0.007076468">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should call Gemini with prompt content when slash command returns a `submit_prompt` action" time="0.007871633">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should correctly handle a submit_prompt action with empty content" time="0.006280996">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for line comments" time="0.005310068">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for block comments" time="0.006267173">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Memory Refresh on save_memory &gt; should call performMemoryRefresh when a save_memory tool call completes successfully" time="0.003975473">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Error Handling &gt; should call parseAndFormatApiError with the correct authType on stream initialization failure" time="0.005879059">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add info message for MAX_TOKENS finish reason" time="0.005893616">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for STOP finish reason" time="0.105277395">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for FINISH_REASON_UNSPECIFIED" time="0.10534052">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add appropriate messages for other finish reasons" time="0.069281273">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should process @include commands, adding user turn after processing to prevent race conditions" time="0.004665897">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when starting a new prompt" time="0.011626773">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when user cancels" time="0.008416949">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when there is an error" time="0.007524606">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should prevent concurrent submitQuery calls" time="0.017579249">
            <system-err>
You called act(async () =&gt; ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () =&gt; ...);

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should allow subsequent calls after first call completes" time="0.005545406">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should reset execution flag even when query preparation fails" time="0.005464457">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should call handleVisionSwitch and proceed to send when allowed" time="0.005440582">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should gate submission when handleVisionSwitch returns shouldProceed=false" time="0.005710155">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model after successful stream completion" time="0.011960305">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model when an error occurs during streaming" time="0.008750922">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGitBranchName.test.ts" timestamp="2025-09-29T17:17:42.021Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="2" time="0.060849856">
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return branch name" time="0.037581443">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if git command fails" time="0.006088901">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return short commit hash if branch is HEAD (detached state)" time="0.004129759">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if branch is HEAD and getting commit hash fails" time="0.003597776">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should update branch name when .git/HEAD changes" time="0.001025893">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should handle watcher setup error silently" time="0.004949326">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should cleanup watcher on unmount" time="0.000773772">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useHistoryManager.test.ts" timestamp="2025-09-29T17:17:42.023Z" hostname="codespaces-4e4548" tests="8" failures="0" errors="0" skipped="0" time="0.050531564">
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should initialize with an empty history" time="0.023842224">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add an item to history with a unique ID" time="0.006465933">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should generate unique IDs for items added with the same base timestamp" time="0.003100871">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should update an existing history item" time="0.002886471">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not change history if updateHistoryItem is called with a nonexistent ID" time="0.002818655">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should clear the history" time="0.002754414">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not add consecutive duplicate user messages" time="0.002720331">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add duplicate user messages if they are not consecutive" time="0.003233398">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useInputHistory.test.ts" timestamp="2025-09-29T17:17:42.024Z" hostname="codespaces-4e4548" tests="11" failures="0" errors="0" skipped="0" time="0.058641692">
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; should initialize with historyIndex -1 and empty originalQueryBeforeNav" time="0.025174648">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should call onSubmit with trimmed value and reset history" time="0.004809455">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should not call onSubmit if value is empty after trimming" time="0.002422776">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if isActive is false" time="0.002790171">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if userMessages is empty" time="0.003206157">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should call onChange with the last message when navigating up from initial state" time="0.004075397">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should store currentQuery as originalQueryBeforeNav on first navigateUp" time="0.003340416">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should navigate through history messages on subsequent navigateUp calls" time="0.002785321">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if isActive is false" time="0.002608953">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if historyIndex is -1 (not in history navigation)" time="0.002095667">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should restore originalQueryBeforeNav when navigating down to initial state" time="0.002288817">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useKeypress.test.ts" timestamp="2025-09-29T17:17:42.027Z" hostname="codespaces-4e4548" tests="15" failures="0" errors="0" skipped="0" time="0.122053153">
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should not listen if isActive is false" time="0.029741018">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;a&apos;" time="0.006327936">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;left&apos;" time="0.002839403">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;right&apos;" time="0.002601319">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;up&apos;" time="0.002665168">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;down&apos;" time="0.00236043">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should set and release raw mode" time="0.002946723">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should stop listening after being unmounted" time="0.002424199">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should correctly identify alt+enter (meta key)" time="0.002640472">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should process a paste as a single event" time="0.023570354">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should handle keypress interspersed with pastes" time="0.012228104">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.003226023">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should process a paste as a single event" time="0.008041219">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should handle keypress interspersed with pastes" time="0.014688431">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.002733726">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useLoadingIndicator.test.ts" timestamp="2025-09-29T17:17:42.030Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.065406332">
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should initialize with default values when Idle" time="0.027121766">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reflect values when Responding" time="0.019316567">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should show waiting phrase and retain elapsedTime when WaitingForConfirmation" time="0.006710619">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset elapsedTime and use a witty phrase when transitioning from WaitingForConfirmation to Responding" time="0.005356124">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset timer and phrase when streamingState changes from Responding to Idle" time="0.004286241">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useMessageQueue.test.ts" timestamp="2025-09-29T17:17:42.031Z" hostname="codespaces-4e4548" tests="9" failures="0" errors="0" skipped="0" time="0.056694405">
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should initialize with empty queue" time="0.027069532">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should add messages to queue" time="0.004369134">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should filter out empty messages" time="0.002726302">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should clear queue" time="0.003048773">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should return queued messages as text with double newlines" time="0.002801752">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should auto-submit queued messages when transitioning to Idle" time="0.004744353">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when queue is empty" time="0.002577234">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when not transitioning to Idle" time="0.002668064">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should handle multiple state transitions correctly" time="0.004037306">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePhraseCycler.test.ts" timestamp="2025-09-29T17:17:42.034Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="0" time="0.050367719">
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should initialize with the first witty phrase when not active and not waiting" time="0.024178631">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should show &quot;Waiting for user confirmation...&quot; when isWaiting is true" time="0.004437442">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should not cycle phrases if isActive is false and not waiting" time="0.00252647">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should cycle through witty phrases when isActive is true and not waiting" time="0.004185292">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when isActive becomes true after being false (and not waiting)" time="0.006407424">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should clear phrase interval on unmount when active" time="0.002451199">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when transitioning from waiting to active" time="0.003715416">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePrivacySettings.test.ts" timestamp="2025-09-29T17:17:42.036Z" hostname="codespaces-4e4548" tests="6" failures="0" errors="0" skipped="0" time="0.324538384">
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle LoggingContentGenerator wrapper correctly and not throw &quot;Oauth not being used&quot; error" time="0.079744169">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should work with direct CodeAssistServer (no wrapper)" time="0.05679729">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle paid tier users correctly" time="0.056066612">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when content generator is not a CodeAssistServer" time="0.00895374">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when CodeAssistServer has no projectId" time="0.006631542">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should update data collection opt-in setting" time="0.113647182">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useQwenAuth.test.ts" timestamp="2025-09-29T17:17:42.037Z" hostname="codespaces-4e4548" tests="17" failures="0" errors="0" skipped="0" time="0.074057253">
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when not Qwen auth" time="0.023710337">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when Qwen auth but not authenticating" time="0.001810195">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set up event listeners when Qwen auth and authenticating" time="0.004070507">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle device auth event" time="0.003119164">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - success" time="0.002877964">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - error" time="0.002574449">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - polling" time="0.002455508">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - rate_limit" time="0.002555283">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event without message" time="0.002541137">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when auth type changes" time="0.003061527">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when authentication stops" time="0.002892071">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners on unmount" time="0.002473831">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when switching from Qwen auth to another auth type" time="0.003215143">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when authentication stops" time="0.003936553">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle cancelQwenAuth function" time="0.002926164">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should maintain isQwenAuth flag correctly" time="0.005186368">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set isQwenAuthenticating to true when starting authentication with Qwen auth" time="0.00196356">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useReverseSearchCompletion.test.tsx" timestamp="2025-09-29T17:17:42.041Z" hostname="codespaces-4e4548" tests="10" failures="0" errors="0" skipped="0" time="0.077919951">
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.036265554">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when reverseSearchActive becomes false" time="0.007107719">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.002726472">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.003175169">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.004266083">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.003365113">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.006171144">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with large suggestion lists and scrolling" time="0.003294631">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; filters history by buffer.text and sets showSuggestions" time="0.003540349">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; hides suggestions when there are no matches" time="0.004653514">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useShellHistory.test.ts" timestamp="2025-09-29T17:17:42.043Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="0" time="0.563780261">
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should initialize and read the history file from the correct path" time="0.070844264">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should handle a nonexistent history file gracefully" time="0.056060276">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should add a command and write to the history file" time="0.106167624">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should navigate history correctly with previous/next commands" time="0.057695227">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should not add empty or whitespace-only commands to history" time="0.055317529">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should truncate history to MAX_HISTORY_LENGTH (100)" time="0.106146395">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should move an existing command to the top when re-added" time="0.109416022">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useSlashCompletion.test.ts" timestamp="2025-09-29T17:17:42.044Z" hostname="codespaces-4e4548" tests="15" failures="0" errors="0" skipped="0" time="0.134132731">
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest all top-level commands for the root slash" time="0.026453221">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should filter commands based on partial input" time="0.003975311">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest commands based on partial altNames" time="0.002913731">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should NOT provide suggestions for a perfectly typed command that is a leaf node" time="0.005330366">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.003152466">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.002311348">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for a fully typed command that has no sub-commands or argument completion" time="0.00232277">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for an unknown command" time="0.002477058">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest sub-commands for a parent command" time="0.002702718">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest all sub-commands when the query ends with the parent command and a space" time="0.002727955">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should filter sub-commands by prefix" time="0.002245015">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should provide no suggestions for an invalid sub-command" time="0.002272516">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call the command.completion function for argument suggestions" time="0.00927552">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call command.completion with an empty string when args start with a space" time="0.058675343">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should handle completion function that returns null" time="0.004233401">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useTimer.test.ts" timestamp="2025-09-29T17:17:42.047Z" hostname="codespaces-4e4548" tests="8" failures="0" errors="0" skipped="0" time="0.055336883">
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should initialize with 0" time="0.027086572">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should not increment time if isActive is false" time="0.003107873">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should increment time every second if isActive is true" time="0.005100177">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 and start incrementing when isActive becomes true from false" time="0.002936364">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 when resetKey changes while active" time="0.003587417">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should be 0 if isActive is false, regardless of resetKey changes" time="0.002526901">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should clear timer on unmount" time="0.00483399">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should preserve elapsedTime when isActive becomes false, and reset to 0 when it becomes active again" time="0.003134513">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useToolScheduler.test.ts" timestamp="2025-09-29T17:17:42.049Z" hostname="codespaces-4e4548" tests="21" failures="0" errors="0" skipped="4" time="0.081519431">
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler in YOLO Mode &gt; should skip confirmation and execute tool directly when yoloMode is true" time="0.052196831">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; initial state should be empty" time="0.0041254">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute a tool call successfully" time="0.003734551">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool not found" time="0.004441469">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during shouldConfirmExecute" time="0.003375612">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during execute" time="0.002645822">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - approved" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - cancelled by user" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle live output updates" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute multiple tool calls" time="0.004904913">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should throw error if scheduling while already running" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;validating&apos; (validating) correctly" time="0.000702209">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;awaiting_approval&apos; (awaiting_approval) correctly" time="0.000296923">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;scheduled&apos; (scheduled) correctly" time="0.000224338">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing no live output) correctly" time="0.000225831">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing with live output) correctly" time="0.000225651">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;success&apos; (success) correctly" time="0.000252461">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool not found) correctly" time="0.00024114">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool execution failed) correctly" time="0.000222845">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;cancelled&apos; (cancelled) correctly" time="0.000221503">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map an array of ToolCalls correctly" time="0.000717809">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useVisionAutoSwitch.test.ts" timestamp="2025-09-29T17:17:42.054Z" hostname="codespaces-4e4548" tests="36" failures="0" errors="0" skipped="0" time="0.148815883">
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH" time="0.002371661">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when current model is already a vision model" time="0.000365962">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist, QWEN_OAUTH, and model is not vision" time="0.000369068">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; detects image when provided as a single Part object (non-array)" time="0.000237071">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts contain no images" time="0.000199191">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts is a plain string" time="0.000168975">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when visionModelPreviewEnabled is false" time="0.00019844">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist in YOLO mode context" time="0.000346416">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when no image parts exist in YOLO mode context" time="0.00022541">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when already using vision model in YOLO mode context" time="0.000205884">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH in YOLO mode context" time="0.000208268">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchOnce to a one-time model override" time="0.001286618">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchSessionToVL to a persistent session model" time="0.000285782">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps ContinueWithCurrentModel to empty result" time="0.000246289">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; getVisionSwitchGuidanceMessage &gt; returns the expected guidance message" time="0.000334273">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true immediately for continuations" time="0.025978415">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when authType is not QWEN_OAUTH" time="0.003487742">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when there are no image parts" time="0.003292117">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; continues with current model when dialog returns empty result" time="0.005046217">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; applies a one-time override and returns originalModel, then restores" time="0.003752094">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; persists session model when dialog requests persistence" time="0.003029838">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true when dialog returns no special flags" time="0.002563369">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; blocks when dialog throws or is cancelled" time="0.002782828">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when visionModelPreviewEnabled is false" time="0.005758374">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; automatically switches to vision model in YOLO mode without showing dialog" time="0.002788568">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when no images are present" time="0.002971048">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when already using vision model" time="0.00244669">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; restores original model after YOLO mode auto-switch" time="0.002595589">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when authType is not QWEN_OAUTH" time="0.002306329">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when visionModelPreviewEnabled is false" time="0.021483907">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; handles multiple image formats in YOLO mode" time="0.01719353">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should automatically switch once when vlmSwitchMode is &quot;once&quot;" time="0.008774827">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should switch session when vlmSwitchMode is &quot;session&quot;" time="0.00681822">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should continue with current model when vlmSwitchMode is &quot;persist&quot;" time="0.003085973">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to user prompt when vlmSwitchMode is not set" time="0.002881771">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to persist behavior when vlmSwitchMode has invalid value" time="0.009208556">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/vim.test.ts" timestamp="2025-09-29T17:17:42.062Z" hostname="codespaces-4e4548" tests="87" failures="0" errors="0" skipped="0" time="0.718337793">
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should start in NORMAL mode" time="0.029738214">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch to INSERT mode with i command" time="0.007319875">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch back to NORMAL mode with Escape" time="0.00523065">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should properly handle escape followed immediately by a command" time="0.007779893">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle h (left movement)" time="0.004022488">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle l (right movement)" time="0.00497834">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle j (down movement)" time="0.009186856">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle k (up movement)" time="0.007029854">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle 0 (move to start of line)" time="0.00576689">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle $ (move to end of line)" time="0.012951001">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle a (append after cursor)" time="0.009822549">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle A (append at end of line)" time="0.007721003">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle o (open line below)" time="0.004073162">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle O (open line above)" time="0.003618535">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle x (delete character)" time="0.003976502">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should move cursor left when deleting last character on line (vim behavior)" time="0.006798835">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle first d key (sets pending state)" time="0.004676257">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should handle count input and return to count 0 after command" time="0.008150052">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should only delete 1 character with x command when no count is specified" time="0.005084258">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should properly initialize vim hook with word movement support" time="0.006467684">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should support vim mode and basic operations across multiple lines" time="0.006399999">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w (next word)" time="0.015324916">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle b (previous word)" time="0.006711691">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle e (end of word)" time="0.006538027">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w when cursor is on the last word" time="0.013316543">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle first c key (sets pending change state)" time="0.007768872">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state on invalid command sequence (df)" time="0.006181443">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state with Escape in NORMAL mode" time="0.005291193">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Disabled vim mode &gt; should not respond to vim commands when disabled" time="0.003968968">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat x command from current cursor position" time="0.006027025">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat dd command from current position" time="0.006472836">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat ce command from current position" time="0.009556545">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cc command from current position" time="0.020044171">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cw command from current position" time="0.008718241">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat D command from current position" time="0.008458608">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat C command from current position" time="0.006780249">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat command after cursor movement" time="0.006235033">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should move cursor to the correct position after exiting INSERT mode with &quot;a&quot;" time="0.008469758">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle ^ (move to first non-whitespace character)" time="0.008235391">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle G without count (go to last line)" time="0.006213142">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle gg (go to first line)" time="0.005876173">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle count with movement commands" time="0.022891334">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete from cursor to start of next word" time="0.005652927">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should actually delete the complete word including trailing space" time="0.011798934">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete word from middle of word correctly" time="0.00351895">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should handle dw at end of line" time="0.00309551">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete multiple words with count" time="0.005731825">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should record command for repeat with dot" time="0.008128673">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.009521361">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should handle count with de" time="0.019894842">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should change from cursor to start of next word and enter INSERT mode" time="0.007661752">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should handle count with cw" time="0.009091798">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should be repeatable with dot" time="0.009518984">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should change from cursor to end of word and enter INSERT mode" time="0.006911794">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should handle count with ce" time="0.006111483">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change entire line and enter INSERT mode" time="0.005825028">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change multiple lines with count" time="0.017335064">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should be repeatable with dot" time="0.019819675">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.006958401">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should handle count with db" time="0.006189157">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should change from cursor to start of previous word and enter INSERT mode" time="0.007809878">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should handle count with cb" time="0.012403941">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending delete state after dw" time="0.015946836">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending change state after cw" time="0.018284766">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending state with escape" time="0.007339842">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should pass escape through when no pending operator is active" time="0.005421045">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should handle escape and clear pending operator" time="0.005558933">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ctrl+r in INSERT mode" time="0.005878568">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ! in INSERT mode when buffer is empty" time="0.006710689">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should handle ! as input in INSERT mode when buffer is not empty" time="0.009224653">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.015877476">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete multiple word ends with count" time="0.004310515">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.004561183">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete multiple words backward with count" time="0.004145097">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should delete from cursor to start of next word" time="0.003934875">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should change multiple words with count" time="0.004058695">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change from cursor to end of current word" time="0.003889661">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change multiple word ends with count" time="0.004626925">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cb (change word backward) &gt; should change from cursor to start of previous word" time="0.011178319">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cc (change line) &gt; should clear the line and place cursor at the start" time="0.004912407">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete the current line" time="0.005989064">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete multiple lines with count" time="0.007968354">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should handle deleting last line" time="0.00670233">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should delete from cursor to end of line" time="0.007696998">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should handle D at end of line" time="0.006290947">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should change from cursor to end of line" time="0.00561664">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should handle C at beginning of line" time="0.00372308">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/MarkdownDisplay.test.tsx" timestamp="2025-09-29T17:17:42.080Z" hostname="codespaces-4e4548" tests="17" failures="0" errors="0" skipped="0" time="0.407356125">
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders nothing for empty text" time="0.023935257">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a simple paragraph" time="0.012962644">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders headers with correct levels" time="0.007548641">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a fenced code block with a language" time="0.029889867">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a fenced code block without a language" time="0.227036083">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; handles unclosed (pending) code blocks" time="0.005943159">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders unordered lists with different markers" time="0.006531204">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders nested unordered lists" time="0.012665964">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders ordered lists" time="0.005453465">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders horizontal rules" time="0.005361154">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders tables correctly" time="0.01470434">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; handles a table at the end of the input" time="0.004952482">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; inserts a single space between paragraphs" time="0.003503341">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; correctly parses a mix of markdown elements" time="0.029595568">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; hides line numbers in code blocks when showLineNumbers is false" time="0.006574225">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; shows line numbers in code blocks by default" time="0.00389979">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; correctly splits lines using \n regardless of platform EOL" time="0.003542103">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/clipboardUtils.test.ts" timestamp="2025-09-29T17:17:42.083Z" hostname="codespaces-4e4548" tests="6" failures="0" errors="0" skipped="0" time="0.007754866">
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return false on non-macOS platforms" time="0.002368455">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return boolean on macOS" time="0.000295">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should return null on non-macOS platforms" time="0.00044004">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should handle errors gracefully" time="0.000250247">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should not throw errors" time="0.001933574">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should complete without errors on valid directory" time="0.000374839">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/commandUtils.test.ts" timestamp="2025-09-29T17:17:42.084Z" hostname="codespaces-4e4548" tests="26" failures="0" errors="0" skipped="0" time="0.068306631">
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query starts with @" time="0.006011967">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query contains @ preceded by whitespace" time="0.000655121">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when query does not start with @ and has no spaced @" time="0.000544315">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when @ is not preceded by whitespace" time="0.003509842">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return true when query starts with /" time="0.000624614">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false when query does not start with /" time="0.000554644">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for line comments starting with //" time="0.000565174">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for block comments starting with /*" time="0.000385289">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should successfully copy text to clipboard using pbcopy" time="0.005106916">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle pbcopy command failure" time="0.004300226">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle spawn error" time="0.003431997">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle stdin write error" time="0.001928448">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Windows (win32) &gt; should successfully copy text to clipboard using clip" time="0.002583656">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should successfully copy text to clipboard using xclip" time="0.002100386">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should fall back to xsel when xclip fails" time="0.003993815">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should throw error when both xclip and xsel are not found" time="0.006303119">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should emit error when xclip or xsel fail with stderr output (command installed)" time="0.004966278">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on unsupported platform &gt; should throw error for unsupported platform" time="0.000716976">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle command exit without stderr" time="0.001957619">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle empty text" time="0.001899451">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle multiline text" time="0.002183778">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle special characters" time="0.005544807">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on macOS (darwin) &gt; should return open" time="0.000672854">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Windows (win32) &gt; should return start" time="0.000470116">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Linux (linux) &gt; should return xdg-open" time="0.000444138">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on unmatched OS &gt; should return xdg-open" time="0.001745734">
            <system-err>
Unknown platform: unmatched. Attempting to open URLs with: xdg-open.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/computeStats.test.ts" timestamp="2025-09-29T17:17:42.090Z" hostname="codespaces-4e4548" tests="12" failures="0" errors="0" skipped="0" time="0.008721808">
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should return 0 if totalRequests is 0" time="0.002122076">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should calculate the error rate correctly" time="0.000264914">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should return 0 if totalRequests is 0" time="0.00024735">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should calculate the average latency correctly" time="0.000176289">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should return 0 if prompt tokens is 0" time="0.000242131">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should calculate the cache hit rate correctly" time="0.000184574">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should return all zeros for initial empty metrics" time="0.001390312">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate API and tool time percentages" time="0.000682442">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate cache efficiency" time="0.000357245">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate success and agreement rates" time="0.000328272">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should handle division by zero gracefully" time="0.000372705">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly include line counts" time="0.000227975">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/displayUtils.test.ts" timestamp="2025-09-29T17:17:42.092Z" hostname="codespaces-4e4548" tests="5" failures="0" errors="0" skipped="0" time="0.004516378">
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return green for values &gt;= green threshold" time="0.001901074">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return yellow for values &lt; green and &gt;= yellow threshold" time="0.000380429">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return red for values &lt; yellow threshold" time="0.000191797">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return defaultColor for values &lt; yellow threshold when provided" time="0.000147716">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; Threshold Constants &gt; should have the correct values" time="0.000387483">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/formatters.test.ts" timestamp="2025-09-29T17:17:42.094Z" hostname="codespaces-4e4548" tests="14" failures="0" errors="0" skipped="0" time="0.009730548">
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into KB" time="0.005397692">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into MB" time="0.00026281">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into GB" time="0.000157814">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format milliseconds less than a second" time="0.000260145">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration of 0" time="0.000179144">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of seconds" time="0.000154177">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in seconds with one decimal place" time="0.000136474">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of minutes" time="0.000156522">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in minutes and seconds" time="0.000267419">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of hours" time="0.000165237">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours and seconds" time="0.000141123">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours, minutes, and seconds" time="0.000145651">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle large durations" time="0.00014483">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle negative durations" time="0.000130624">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/markdownUtilities.test.ts" timestamp="2025-09-29T17:17:42.096Z" hostname="codespaces-4e4548" tests="7" failures="0" errors="0" skipped="0" time="0.005917371">
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should split at the last double newline if not in a code block" time="0.002610917">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if no safe split point is found" time="0.000251438">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should prioritize splitting at 

 over being at the very end of the string if the end is not in a code block" time="0.00019853">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if the only 

 is inside a code block and the end of content is not" time="0.000178523">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should correctly identify the last 

 even if it is followed by text not in a code block" time="0.00020376">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content is empty" time="0.000172842">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content has no newlines and no code blocks" time="0.000169867">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/updateCheck.test.ts" timestamp="2025-09-29T17:17:42.098Z" hostname="codespaces-4e4548" tests="9" failures="0" errors="0" skipped="0" time="0.019258809">
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null when running from source (DEV=true)" time="0.006060958">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if package.json is missing" time="0.000956604">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if there is no update" time="0.000813316">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return a message if a newer version is available" time="0.00258582">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is the same as the current version" time="0.000902342">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is older than the current version" time="0.000731464">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if fetchInfo rejects" time="0.002466989">
            <system-err>
Failed to check for updates: Error: Timeout

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should handle errors gracefully" time="0.000794932">
            <system-err>
Failed to check for updates: Error: test error

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; nightly updates &gt; should notify for a newer nightly version when current is nightly" time="0.001662549">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/DiffRenderer.test.tsx" timestamp="2025-09-29T17:17:42.100Z" hostname="codespaces-4e4548" tests="13" failures="0" errors="0" skipped="0" time="0.511622588">
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with correct language for new file with known extension" time="0.061695483">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file with unknown extension" time="0.218238452">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file if no filename is provided" time="0.024757841">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render diff content for existing file (not calling colorizeCode directly for the whole block)" time="0.020822335">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle diff with only header and no changes" time="0.011812699">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle empty diff content" time="0.002418157">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render a gap indicator for skipped lines" time="0.013282199">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should not render a gap indicator for small gaps (&lt;= MAX_CONTEXT_LINES_WITHOUT_GAP)" time="0.01919459">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height undefined" time="0.044051743">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height 6" time="0.021575949">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 30 and height 6" time="0.017906289">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with a SVN diff format" time="0.036972099">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a new file with no file extension correctly" time="0.015158236">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolConfirmationMessage.test.tsx" timestamp="2025-09-29T17:17:42.103Z" hostname="codespaces-4e4548" tests="15" failures="0" errors="0" skipped="0" time="0.272937957">
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should not display urls if prompt and url are the same" time="0.061698283">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should display urls if prompt and url are different" time="0.02131766">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should render plan confirmation with markdown plan content" time="0.021325407">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.019671001">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.022390908">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.014272976">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.012299567">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.011524059">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.00888389">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.010426115">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.009030764">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.017237011">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.015762432">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.014013453">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.009339059">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolGroupMessage.test.tsx" timestamp="2025-09-29T17:17:42.106Z" hostname="codespaces-4e4548" tests="14" failures="0" errors="0" skipped="0" time="0.185841716">
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders single successful tool call" time="0.044878046">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders multiple tool calls with different statuses" time="0.015431456">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders tool call awaiting confirmation" time="0.011948934">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders shell command with yellow border" time="0.008294873">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders mixed tool calls including shell command" time="0.013094199">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with limited terminal height" time="0.008106204">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders when not focused" time="0.006084161">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with narrow terminal width" time="0.021520398">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders empty tool calls array" time="0.005540914">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border when tools are pending" time="0.007933862">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border for shell commands even when successful" time="0.007191566">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses gray border when all tools are successful and no shell commands" time="0.009510468">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Height Calculation &gt; calculates available height correctly with multiple tools with results" time="0.01712349">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Confirmation Handling &gt; shows confirmation dialog for first confirming tool only" time="0.006187674">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolMessage.test.tsx" timestamp="2025-09-29T17:17:42.109Z" hostname="codespaces-4e4548" tests="12" failures="0" errors="0" skipped="0" time="0.124455274">
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders basic tool information" time="0.047034384">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows ✓ for Success status" time="0.005527644">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows o for Pending status" time="0.004909101">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows ? for Confirming status" time="0.005574451">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows - for Canceled status" time="0.007786915">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows x for Error status" time="0.005095318">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is Idle" time="0.005324405">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is WaitingForConfirmation" time="0.005081733">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows MockRespondingSpinner for Executing status when streamingState is Responding" time="0.006101885">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders DiffRenderer for diff results" time="0.007332488">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders emphasis correctly" time="0.014304355">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; shows subagent execution display for task tool with proper result display" time="0.007506625">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/MaxSizedBox.test.tsx" timestamp="2025-09-29T17:17:42.112Z" hostname="codespaces-4e4548" tests="21" failures="0" errors="0" skipped="0" time="0.161005315">
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders children without truncation when they fit" time="0.041079896">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines when content exceeds maxHeight" time="0.006333676">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines at the end when content exceeds maxHeight and overflowDirection is bottom" time="0.005681638">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text that exceeds maxWidth" time="0.00479071">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles mixed wrapping and non-wrapping segments" time="0.020624075">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles words longer than maxWidth by splitting them" time="0.010972676">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; does not truncate when maxHeight is undefined" time="0.003185037">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden" time="0.00358913">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden and overflowDirection is bottom" time="0.003653701">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders an empty box for empty children" time="0.001151456">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte unicode characters correctly" time="0.002719289">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte emoji characters correctly" time="0.003072808">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; falls back to an ellipsis when width is extremely small" time="0.002593384">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates long non-wrapping text with ellipsis" time="0.002519667">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates non-wrapping text containing line breaks" time="0.010403613">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates emoji characters correctly with ellipsis" time="0.001950596">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows ellipsis for multiple rows with long non-wrapping text" time="0.003659912">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; accounts for additionalHiddenLinesCount" time="0.00294507">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles React.Fragment as a child" time="0.004438063">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the top" time="0.012760705">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the bottom" time="0.009913139">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/RadioButtonSelect.test.tsx" timestamp="2025-09-29T17:17:42.117Z" hostname="codespaces-4e4548" tests="13" failures="0" errors="0" skipped="0" time="0.348107199">
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list of items and matches snapshot" time="0.035268343">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with the second item selected and matches snapshot" time="0.005800963">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with numbers hidden and matches snapshot" time="0.005801314">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with scroll arrows and matches snapshot" time="0.009827509">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with special theme display and matches snapshot" time="0.00529503">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list with &gt;10 items and matches snapshot" time="0.015827854">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders nothing when no items are provided" time="0.002171848">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; should call onSelect when &quot;enter&quot; is pressed" time="0.010420174">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; when isFocused is false &gt; should not handle any keyboard input" time="0.008644875">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate down with arrow key and select with enter" time="0.059231492">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate up with arrow key and select with enter" time="0.065146757">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate down with arrow key and select with enter" time="0.062069354">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate up with arrow key and select with enter" time="0.059384628">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/text-buffer.test.ts" timestamp="2025-09-29T17:17:42.122Z" hostname="codespaces-4e4548" tests="103" failures="0" errors="0" skipped="0" time="0.382045948">
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; should return the initial state if state is undefined" time="0.006172666">
            <system-err>
Unknown action encountered: [object Object]

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should set new text and move cursor to the end" time="0.000824888">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should not create an undo snapshot if pushToUndo is false" time="0.000291082">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a character" time="0.000603274">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a newline" time="0.000413651">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should remove a character" time="0.000289981">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should join lines if at the beginning of a line" time="0.000375299">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; undo/redo actions &gt; should undo and redo a change" time="0.000547911">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; create_undo_snapshot action &gt; should create a snapshot without changing state" time="0.000344563">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with empty text and cursor at (0,0) by default" time="0.026313541">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with provided initialText" time="0.005492509">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with initialText and initialCursorOffset" time="0.003749739">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines" time="0.003659361">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines with multiple spaces" time="0.003671475">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines even without spaces" time="0.002858569">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with multi-byte unicode characters and correct cursor offset" time="0.003889059">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert a character and update cursor" time="0.003945395">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert text in the middle of a line" time="0.003748347">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; newline: should create a new line and move cursor" time="0.00373407">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; backspace: should delete char to the left or merge lines" time="0.005107791">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; del: should delete char to the right or merge lines" time="0.007885822">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should prepend @ to a valid file path on insert" time="0.003509032">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to an invalid file path on insert" time="0.003429363">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should handle quoted paths" time="0.002849381">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to short text that is not a path" time="0.002633448">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to valid file paths when shellModeActive is true" time="0.003759918">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to quoted paths when shellModeActive is true" time="0.002956291">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with invalid paths when shellModeActive is true" time="0.003247283">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with short text when shellModeActive is true" time="0.002922268">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: left/right should work within and across visual lines (due to wrapping)" time="0.010752914">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: up/down should preserve preferred visual column" time="0.012410985">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: home/end should go to visual line start/end" time="0.007197407">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should wrap long lines correctly into visualLines" time="0.003676373">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should update visualScrollRow when visualCursor moves out of viewport" time="0.016371345">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo an insert operation" time="0.005306872">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo a newline operation" time="0.004349838">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; insert: should correctly handle multi-byte unicode characters" time="0.002803195">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; backspace: should correctly delete multi-byte unicode characters" time="0.003528868">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; move: left/right should treat multi-byte chars as single units for visual cursor" time="0.003654252">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should insert printable characters" time="0.003881155">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Enter&quot; key as newline" time="0.009346447">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Backspace&quot; key" time="0.002611889">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle multiple delete characters in one input" time="0.003702767">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts that contain delete characters" time="0.004803705">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts with a mix of regular and delete characters" time="0.003292117">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle arrow keys for movement" time="0.003370453">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should strip ANSI escape codes when pasting text" time="0.002561605">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle VSCode terminal Shift+Enter as newline" time="0.002445829">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should correctly handle repeated pasting of long text" time="0.07983988">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with single-line text" time="0.003096993">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a multi-line range with single-line text" time="0.003389669">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should delete a range when replacing with an empty string" time="0.003885413">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the beginning of the text" time="0.002914774">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the end of the text" time="0.002913862">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing the entire buffer content" time="0.00257488">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should correctly replace with unicode characters" time="0.002793066">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle invalid range by returning false and not changing text" time="0.002812212">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; replaceRange: multiple lines with a single character" time="0.002573999">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with multi-line text" time="0.002958646">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip ANSI escape codes from input" time="0.002609975">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip control characters from input" time="0.002444717">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip mixed ANSI and control characters from input" time="0.002345322">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip standard characters or newlines" time="0.002716614">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should sanitize pasted text via handleInput" time="0.002388322">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip popular emojis" time="0.002025966">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should correctly strip ANSI escape codes" time="0.000267118">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle multiple ANSI codes" time="0.000217646">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should not modify text without ANSI codes" time="0.000141544">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle empty string" time="0.000178733">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should return [0,0] for offset 0" time="0.000219018">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle single line text" time="0.000460548">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-line text" time="0.0007939">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty lines" time="0.000443507">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text ending with a newline" time="0.00034341">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text starting with a newline" time="0.000323553">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty string input" time="0.000255095">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-byte unicode characters correctly" time="0.000614857">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset exactly at newline character" time="0.000285552">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset in the middle of a multi-byte character (should place at start of that char)" time="0.000321348">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should convert row/col position to offset correctly" time="0.000703923">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle empty lines" time="0.000356845">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle single empty line" time="0.000177531">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should be inverse of offsetToLogicalPos" time="0.00068666">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle out-of-bounds positions" time="0.020496258">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete a single line including newline in multi-line text" time="0.001752116">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete multiple lines when count &gt; 1" time="0.000432376">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should clear single line content when only one line exists" time="0.000451943">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting the last line properly" time="0.000401328">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting all lines and maintain valid state for subsequent paste" time="0.00071904">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle combining characters" time="0.002857798">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000331929">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should return null when no word end found" time="0.000316369">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle right-to-left text" time="0.000396199">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle Chinese characters" time="0.000237393">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should return null at end of line" time="0.00019255">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle combining characters" time="0.000404624">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000207056">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for ASCII word characters" time="0.000333502">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for punctuation" time="0.000280673">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for non-Latin scripts" time="0.000232915">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for whitespace" time="0.000225541">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle combining characters" time="0.000229859">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle Chinese and Arabic text" time="0.000249876">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/vim-buffer-actions.test.ts" timestamp="2025-09-29T17:17:42.141Z" hostname="codespaces-4e4548" tests="74" failures="0" errors="0" skipped="0" time="0.041283215">
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should move cursor left by count" time="0.004249401">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should not move past beginning of line" time="0.000400556">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should wrap to previous line when at beginning" time="0.000409313">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should handle multiple line wrapping" time="0.000352587">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should correctly handle h/l movement between lines" time="0.000555776">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should move cursor right by count" time="0.000610669">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should not move past last character of line" time="0.00028999">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should wrap to next line when at end" time="0.000524698">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should skip over combining marks to avoid cursor disappearing" time="0.000650643">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should move cursor up by count" time="0.000345204">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should not move past first line" time="0.000283989">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should adjust column for shorter lines" time="0.000362926">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should move cursor down by count" time="0.000378064">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should not move past last line" time="0.000269843">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move to start of next word" time="0.002249894">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle multiple words" time="0.000322682">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle punctuation correctly" time="0.000291574">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move across empty lines when starting from within a word" time="0.000370671">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should move to start of previous word" time="0.000512135">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should handle multiple words" time="0.000328562">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of current word" time="0.000559052">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of next word if already at word end" time="0.000293367">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move across empty lines when at word end" time="0.000338201">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle consecutive word-end movements across empty lines" time="0.000459326">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle combining characters - advance from end of base character" time="0.0008155">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle precomposed characters with diacritics" time="0.000425583">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_start should move to column 0" time="0.000252921">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_end should move to last character" time="0.000241209">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_nonwhitespace should skip leading whitespace" time="0.000374158">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_line should move to row 0" time="0.00030042">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_last_line should move to last row" time="0.00031661">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should move to specific line" time="0.000352698">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should clamp to valid range" time="0.000267268">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete single character" time="0.000792858">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete multiple characters" time="0.000356495">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should not delete past end of line" time="0.000325146">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should do nothing at end of line" time="0.000315348">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete from cursor to next word start" time="0.000320407">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete multiple words" time="0.000288879">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete to end if no more words" time="0.000344963">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete from cursor to previous word start" time="0.000275013">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete multiple words backward" time="0.000290301">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete current line" time="0.001393458">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete multiple lines" time="0.000425553">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should leave empty line when deleting all lines" time="0.00043475">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should delete from cursor to end of line" time="0.000322401">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should do nothing at end of line" time="0.000254093">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_cursor &gt; should not change cursor position" time="0.000340184">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should move cursor right by one" time="0.0002794">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should not move past end of line" time="0.000295882">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_line_end &gt; should move cursor to end of line" time="0.000258892">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to first non-whitespace character" time="0.00026335">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to column 0 for line with only whitespace" time="0.000249846">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_below &gt; should insert a new line below the current one" time="0.000462011">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_above &gt; should insert a new line above the current one" time="0.000480956">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should move cursor left" time="0.000249315">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should not move past beginning of line" time="0.000242823">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_word_forward &gt; should delete from cursor to next word start" time="0.000328473">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_line &gt; should delete entire line content" time="0.000594388">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the left" time="0.00033803">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the right" time="0.00034336">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change multiple lines down" time="0.000392992">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty text" time="0.000307333">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle single character line" time="0.000262008">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty lines in multi-line text" time="0.000281004">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should preserve undo stack in operations" time="0.001469449">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Right-to-left text handling &gt; should handle Arabic text in word movements" time="0.000991348">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Chinese character handling &gt; should handle Chinese characters in word movements" time="0.000405876">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word end commands" time="0.000400066">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word forward commands" time="0.000369358">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word backward commands" time="0.000373787">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle Unicode block characters consistently with w and e commands" time="0.000758715">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Chinese characters" time="0.000554363">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Arabic characters" time="0.000528194">
        </testcase>
    </testsuite>
</testsuites>
