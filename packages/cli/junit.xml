<?xml version="1.0" encoding="UTF-8" ?>
<testsuites name="vitest tests" tests="1981" failures="3" errors="0" time="36.552441649">
    <testsuite name="src/gemini.test.tsx" timestamp="2025-10-02T21:38:22.663Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.018141756">
        <testcase classname="src/gemini.test.tsx" name="gemini.tsx main function &gt; should throw InvalidConfigurationError if settings have errors" time="0.003456049">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="gemini.tsx main function &gt; should log unhandled promise rejections and open debug console on first error" time="0.008648831">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return &quot;ipv4first&quot; when the input is &quot;ipv4first&quot;" time="0.000373071">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return &quot;verbatim&quot; when the input is &quot;verbatim&quot;" time="0.000134349">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return the default &quot;ipv4first&quot; when the input is undefined" time="0.000106988">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return the default &quot;ipv4first&quot; and log a warning for an invalid string" time="0.000213034">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="startInteractiveUI &gt; should render the UI with proper React context and exitOnCtrlC disabled" time="0.001835007">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="startInteractiveUI &gt; should perform all startup tasks in correct order" time="0.001957625">
        </testcase>
    </testsuite>
    <testsuite name="src/nonInteractiveCli.test.ts" timestamp="2025-10-02T21:38:22.664Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.016806945">
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should process input and write text output" time="0.006673735">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle a single tool call and respond" time="0.002159838">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle error during tool execution and should send error back to the model" time="0.001360689">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit with error if sendMessageStream throws initially" time="0.001600653">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should not exit if a tool is not found, and should send error back to model" time="0.000952603">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit when max session turns are exceeded" time="0.001359207">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should preprocess @include commands before sending to the model" time="0.001349418">
        </testcase>
    </testsuite>
    <testsuite name="src/validateNonInterActiveAuth.test.ts" timestamp="2025-10-02T21:38:22.664Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.01846778">
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; exits if no auth type is configured or env vars set" time="0.005562588">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set" time="0.004717915">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_GEMINI if GEMINI_API_KEY is set" time="0.000798729">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_OPENAI if OPENAI_API_KEY is set" time="0.000533798">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses configured QWEN_OAUTH if provided" time="0.000322386">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true (with GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION)" time="0.000352473">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true and GOOGLE_API_KEY is set" time="0.000388779">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set, even with other env vars" time="0.00068028">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if both GEMINI_API_KEY and GOOGLE_GENAI_USE_VERTEXAI are set" time="0.000616131">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_GEMINI if GOOGLE_GENAI_USE_VERTEXAI is false, GEMINI_API_KEY is set, and project/location are available" time="0.00044879">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses configuredAuthType if provided" time="0.000553364">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; exits if validateAuthMethod returns error" time="0.000523339">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; skips validation if useExternalAuth is true" time="0.001460274">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp.test.ts" timestamp="2025-10-02T21:38:22.665Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.006750647">
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should have correct command definition" time="0.000973993">
        </testcase>
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should have exactly one option (help flag)" time="0.002891995">
        </testcase>
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should register add, remove, and list subcommands" time="0.00196612">
        </testcase>
    </testsuite>
    <testsuite name="src/config/auth.test.ts" timestamp="2025-10-02T21:38:22.665Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.004771864">
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for LOGIN_WITH_GOOGLE" time="0.001876314">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for CLOUD_SHELL" time="0.000483846">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return null if GEMINI_API_KEY is set" time="0.000250594">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return an error message if GEMINI_API_KEY is not set" time="0.000307209">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION are set" time="0.000296198">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_API_KEY is set" time="0.00022181">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return an error message if no required environment variables are set" time="0.000161098">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return an error message for an invalid auth method" time="0.000143786">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.integration.test.ts" timestamp="2025-10-02T21:38:22.665Z" hostname="uby" tests="19" failures="0" errors="0" skipped="0" time="1.722576053">
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load default file filtering settings" time="0.304774038">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load custom file filtering settings from configuration" time="0.011801419">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should merge user and workspace file filtering settings" time="0.006201321">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle partial configuration objects gracefully" time="0.002242712">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle empty configuration objects gracefully" time="0.001122037">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle missing configuration sections gracefully" time="0.000852208">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a security-focused configuration" time="0.000921175">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a CI/CD environment configuration" time="0.001752034">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Checkpointing Configuration &gt; should enable checkpointing when the setting is true" time="0.003638506">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should have an empty array for extension context files by default" time="0.006182917">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should correctly store and return extension context file paths" time="0.002534993">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=auto-edit correctly through the full argument parsing flow" time="1.289635893">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=plan correctly through the full argument parsing flow" time="0.012366695">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=yolo correctly through the full argument parsing flow" time="0.008844805">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=default correctly through the full argument parsing flow" time="0.004461049">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse legacy --yolo flag correctly" time="0.004338462">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject invalid approval mode values during argument parsing" time="0.031585867">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Invalid values:
  Argument: approval-mode, Given: &quot;invalid_mode&quot;, Choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject conflicting --yolo and --approval-mode flags" time="0.014570876">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Cannot use both --yolo (-y) and --approval-mode together. Use --approval-mode=yolo instead.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should handle backward compatibility with mixed scenarios" time="0.002815422">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.test.ts" timestamp="2025-10-02T21:38:22.666Z" hostname="uby" tests="125" failures="0" errors="0" skipped="1" time="0.502848382">
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --prompt and --prompt-interactive are used together" time="0.056845261">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -p and -i together" time="0.015375135">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt without --prompt-interactive" time="0.006429023">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt-interactive without --prompt" time="0.003735756">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow -i flag as alias for --prompt-interactive" time="0.005461962">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --yolo and --approval-mode are used together" time="0.013435084">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -y and --approval-mode together" time="0.013614976">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --approval-mode without --yolo" time="0.004048405">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --yolo without --approval-mode" time="0.003449847">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should reject invalid --approval-mode values" time="0.014078655">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to true when --show-memory-usage flag is present" time="0.037660964">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false when --memory flag is not present" time="0.004451131">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false by default from settings if CLI flag is not present" time="0.002518954">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should prioritize CLI flag over settings for showMemoryUsage (CLI true, settings false)" time="0.008530594">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should leave proxy to empty by default" time="0.005068774">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [https_proxy]" time="0.003615063">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [http_proxy]" time="0.002323412">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTPS_PROXY]" time="0.002926178">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTP_PROXY]" time="0.003094018">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy when --proxy flag is present" time="0.002928863">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should prioritize CLI flag over environment variable for proxy (CLI http://localhost:7890, environment variable http://localhost:7891)" time="0.004082167">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false by default when no flag or setting is present" time="0.002778093">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to true when --telemetry flag is present" time="0.018449006">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false when --no-telemetry flag is present" time="0.003053072">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings true)" time="0.002258772">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings false)" time="0.013301736">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry CLI flag (true) over settings (false)" time="0.003465256">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry CLI flag (false) over settings (true)" time="0.00287921">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP endpoint from settings if CLI flag is not present" time="0.002135093">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-endpoint CLI flag over settings" time="0.002257529">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default endpoint if no OTLP endpoint is provided via CLI or settings" time="0.002013869">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry target from settings if CLI flag is not present" time="0.001963665">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-target CLI flag over settings" time="0.001865934">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default target if no target is provided via CLI or settings" time="0.001666335">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry log prompts from settings if CLI flag is not present" time="0.001665113">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-log-prompts CLI flag (true) over settings (false)" time="0.001781308">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry-log-prompts CLI flag (false) over settings (true)" time="0.001803028">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default log prompts (true) if no value is provided via CLI or settings" time="0.001562994">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP protocol from settings if CLI flag is not present" time="0.001534841">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-protocol CLI flag over settings" time="0.001564917">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default protocol if no OTLP protocol is provided via CLI or settings" time="0.001456356">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should reject invalid --telemetry-otlp-protocol values" time="0.005857414">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should pass extension context file paths to loadServerHierarchicalMemory" time="0.002796206">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should correctly use mocked homedir for global path" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeMcpServers &gt; should not modify the original settings object" time="0.001635808">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use default systemPromptMappings when not provided in settings" time="0.000493604">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use custom systemPromptMappings when provided in settings" time="0.000378911">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should merge excludeTools from settings and extensions" time="0.00250101">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between settings and extensions" time="0.002377782">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between extensions" time="0.003275213">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return an empty array when no excludeTools are specified and it is interactive" time="0.002415753">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return default excludes when no excludeTools are specified and it is not interactive" time="0.001623475">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle settings with excludeTools but no extensions" time="0.002327589">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle extensions with excludeTools but no settings" time="0.002121437">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should not modify the original settings object" time="0.001652008">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with default approval mode" time="0.002253732">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with plan approval mode" time="0.001981298">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with explicit default approval mode" time="0.001999292">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude only shell tools in non-interactive mode with auto-edit approval mode" time="0.002365639">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with yolo approval mode" time="0.001686803">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with legacy yolo flag" time="0.001614669">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should not exclude interactive tools in interactive mode regardless of approval mode" time="0.011613281">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should merge approval mode exclusions with settings exclusions in auto-edit mode" time="0.002034166">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should throw an error for invalid approval mode values in loadCliConfig" time="0.000534249">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow all MCP servers if the flag is not provided" time="0.002219809">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow only the specified MCP server" time="0.002222465">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow multiple specified MCP servers" time="0.002204421">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should handle server names that do not exist" time="0.002480473">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow no MCP servers if the flag is provided but empty" time="0.002339982">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read allowMCPServers from settings" time="0.001842831">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read excludeMCPServers from settings" time="0.002213297">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should override allowMCPServers with excludeMCPServers if overlapping" time="0.002706791">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize mcp server flag if set" time="0.003209131">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize CLI flag over both allowed and excluded settings" time="0.002977773">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should not filter extensions if --extensions flag is not used" time="0.001790474">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should filter extensions if --extensions flag is used" time="0.001905027">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects a model from settings.json if provided" time="0.001537937">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; uses the default gemini model if nothing is set" time="0.001556471">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; always prefers model from argvs" time="0.002332809">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects the model from argvs if provided" time="0.002253041">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be false by default" time="0.006287991">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be true when settings.folderTrustFeature is true" time="0.002574296">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is false" time="0.002509296">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is true and folderTrust is false" time="0.002228556">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is true" time="0.001938459">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be true when folderTrustFeature is true and folderTrust is true" time="0.002394303">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with includeDirectories &gt; should combine and resolve paths from settings and CLI arguments" time="0.00335459">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should pass chatCompression settings to the core config" time="0.0028251">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should have undefined chatCompression if not in settings" time="0.003048684">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false by default when useRipgrep is not set in settings" time="0.003414461">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be true when useRipgrep is set to true in settings" time="0.002755031">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false when useRipgrep is explicitly set to false in settings" time="0.002674381">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode without YOLO" time="0.003104277">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode with YOLO" time="0.003109026">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should exclude interactive tools in non-interactive mode without YOLO" time="0.002626322">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in non-interactive mode with YOLO" time="0.003212618">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if isTTY and no prompt" time="0.002224949">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if prompt-interactive is set" time="0.001708984">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if not isTTY and no prompt" time="0.001638433">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if prompt is set" time="0.001751642">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should default to DEFAULT approval mode when no flags are set" time="0.002051899">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set PLAN approval mode when --approval-mode=plan" time="0.002882336">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --yolo flag is used" time="0.002545223">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when -y flag is used" time="0.002686184">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set DEFAULT approval mode when --approval-mode=default" time="0.002548809">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set AUTO_EDIT approval mode when --approval-mode=auto-edit" time="0.002547306">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --approval-mode=yolo" time="0.003083669">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should use approval mode from settings when CLI flags are not provided" time="0.002792079">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should normalize approval mode values from settings" time="0.002739873">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should throw when approval mode in settings is invalid" time="0.002491463">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should prioritize --approval-mode over --yolo when both would be valid (but validation prevents this)" time="0.002508103">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should fall back to --yolo behavior when --approval-mode is not set" time="0.002838295">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=yolo to DEFAULT" time="0.00406698">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=auto-edit to DEFAULT" time="0.002967094">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --yolo flag to DEFAULT" time="0.003117431">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should remain DEFAULT when --approval-mode=default" time="0.002712842">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should allow PLAN approval mode in untrusted folders" time="0.002676234">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace trusted -&gt; behave as trusted" time="0.002880844">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace not trusted -&gt; behave as trusted" time="0.002434717">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.002726688">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.002885642">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace not trusted -&gt; behave as trusted" time="0.002461306">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trusted -&gt; is trusted" time="0.002426152">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace NOT trusted -&gt; is NOT trusted" time="0.002394974">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trust unknown -&gt; is unknown" time="0.002499237">
        </testcase>
    </testsuite>
    <testsuite name="src/config/extension.test.ts" timestamp="2025-10-02T21:38:22.669Z" hostname="uby" tests="26" failures="0" errors="0" skipped="0" time="0.084178715">
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should include extension path in loaded extension" time="0.012075957">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should load context file path when QWEN.md is present" time="0.003316711">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should load context file path from the extension config" time="0.001627784">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should filter out disabled extensions" time="0.004198743">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should hydrate variables" time="0.001453561">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark all extensions as active if no enabled extensions are provided" time="0.000655263">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark only the enabled extensions as active" time="0.000624086">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark all extensions as inactive when &quot;none&quot; is provided" time="0.000543015">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should handle case-insensitivity" time="0.000462316">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should log an error for unknown extensions" time="0.001417545">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should install an extension from a local path" time="0.007731063">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should throw an error if the extension already exists" time="0.009804592">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should throw an error and cleanup if qwen-extension.json is missing" time="0.002584655">
            <system-err>
Warning: extension directory /tmp/qwen-code-test-home-OLib9x/bad-extension does not contain a config file /tmp/qwen-code-test-home-OLib9x/bad-extension/qwen-extension.json.

            </system-err>
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should install an extension from a git URL" time="0.003280803">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should uninstall an extension by name" time="0.003110068">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should uninstall an extension by name and retain existing extensions" time="0.002471485">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should throw an error if the extension does not exist" time="0.000572691">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="performWorkspaceExtensionMigration &gt; should install the extensions in the user directory" time="0.004509268">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="performWorkspaceExtensionMigration &gt; should return the names of failed installations" time="0.002143128">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="updateExtension &gt; should update a git-installed extension" time="0.004903037">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should disable an extension at the user scope" time="0.001471734">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should disable an extension at the workspace scope" time="0.001564827">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should handle disabling the same extension twice" time="0.002433145">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should throw an error if you request system scope" time="0.001200873">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="enableExtension &gt; should enable an extension at the user scope" time="0.00357077">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="enableExtension &gt; should enable an extension at the workspace scope" time="0.003785528">
        </testcase>
    </testsuite>
    <testsuite name="src/config/keyBindings.test.ts" timestamp="2025-10-02T21:38:22.670Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.004534646">
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have bindings for all commands" time="0.001963105">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have valid key binding structures" time="0.001229747">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should export all required types" time="0.000136663">
        </testcase>
    </testsuite>
    <testsuite name="src/config/settings.test.ts" timestamp="2025-10-02T21:38:22.670Z" hostname="uby" tests="65" failures="0" errors="0" skipped="0" time="0.038494988">
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load empty settings if no files exist" time="0.003749943">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load system settings if only system file exists" time="0.002160991">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load user settings if only user file exists" time="0.000889447">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should restore selected auth type when provider data is persisted in V1 format" time="0.000745891">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load workspace settings if only workspace file exists" time="0.000787188">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge user and workspace settings, with workspace taking precedence" time="0.001033593">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge system, user and workspace settings, with system taking precedence over workspace, and workspace over user" time="0.001162422">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly migrate a complex legacy (v1) settings file" time="0.000877394">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly merge and migrate legacy array properties from multiple scopes" time="0.00130726">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge all settings files with the correct precedence" time="0.000828424">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should ignore folderTrust from workspace settings" time="0.000341873">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should use system folderTrust over user setting" time="0.00026494">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle contextFileName correctly when only in user settings" time="0.000267255">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle contextFileName correctly when only in workspace settings" time="0.000300125">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle excludedProjectEnvVars correctly when only in user settings" time="0.000306929">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle excludedProjectEnvVars correctly when only in workspace settings" time="0.000274198">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge excludedProjectEnvVars with workspace taking precedence over user" time="0.000439824">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should default contextFileName to undefined if not in any settings file" time="0.000433443">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load telemetry setting from user settings" time="0.000354406">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load telemetry setting from workspace settings" time="0.000306958">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should prioritize workspace telemetry setting over user setting" time="0.000351">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have telemetry as undefined if not in any settings file" time="0.000276242">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge MCP servers correctly, with workspace taking precedence" time="0.000652849">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle MCP servers when only in user settings" time="0.00038891">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle MCP servers when only in workspace settings" time="0.000352132">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have mcpServers as empty object if not in any settings file" time="0.000576698">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge MCP servers from system, user, and workspace with system taking precedence" time="0.00051303">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge mcp allowed/excluded lists with system taking precedence over workspace" time="0.000473166">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge chatCompression settings, with workspace taking precedence" time="0.001654333">
            <system-out>
{ contextPercentageThreshold: [33m0.5[39m }

            </system-out>
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle chatCompression when only in user settings" time="0.0003777">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have chatCompression as an empty object if not in any settings file" time="0.000234294">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should ignore chatCompression if contextPercentageThreshold is invalid" time="0.000692412">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should deep merge chatCompression settings" time="0.000328277">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge includeDirectories from all scopes" time="0.000558735">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle JSON parsing errors gracefully" time="0.001117499">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in user settings" time="0.000536363">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in workspace settings" time="0.000527276">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly resolve and merge env variables from different scopes" time="0.000713691">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly merge dnsResolutionOrder with workspace taking precedence" time="0.000417964">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should use user dnsResolutionOrder if workspace is not defined" time="0.000324871">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should leave unresolved environment variables as is" time="0.000344057">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve multiple environment variables in a single string" time="0.000355198">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in arrays" time="0.000435747">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly pass through null, boolean, and number types, and handle undefined properties" time="0.000684417">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve multiple concatenated environment variables in a single string value" time="0.000408547">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; when QWEN_CODE_SYSTEM_SETTINGS_PATH is set &gt; should load system settings from the path specified in the environment variable" time="0.00074542">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should exclude DEBUG and DEBUG_MODE from project .env files by default" time="0.000595472">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should respect custom excludedProjectEnvVars from user settings" time="0.00051877">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should merge excludedProjectEnvVars with workspace taking precedence" time="0.000462527">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; with workspace trust &gt; should merge workspace settings when workspace is trusted" time="0.000601744">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; with workspace trust &gt; should NOT merge workspace settings when workspace is not trusted" time="0.000492422">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle an empty object" time="0.000431158">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should migrate a simple v2 settings object to v1" time="0.000385654">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle nested properties correctly" time="0.000198487">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve security auth provider configuration" time="0.000179372">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve mcpServers at the top level" time="0.000165547">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should carry over unrecognized top-level properties" time="0.000101528">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle a complex object with mixed properties" time="0.000152793">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should not migrate a v1 settings object" time="0.000087512">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should migrate a full v2 settings object to v1" time="0.000217142">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle partial v2 settings" time="0.000101287">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle settings with different data types" time="0.000262086">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve unrecognized top-level keys" time="0.000234434">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle an empty v2 settings object" time="0.000104113">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should correctly handle mcpServers at the top level" time="0.000126945">
        </testcase>
    </testsuite>
    <testsuite name="src/config/settingsSchema.test.ts" timestamp="2025-10-02T21:38:22.672Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.018101522">
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should contain all expected top-level settings" time="0.001430599">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct structure for each setting" time="0.006622069">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct nested setting structure" time="0.00058872">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have accessibility nested properties" time="0.001099456">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have checkpointing nested properties" time="0.000131965">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have fileFiltering nested properties" time="0.000135672">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have unique categories" time="0.002347807">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have consistent default values for boolean settings" time="0.002099597">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have showInDialog property configured" time="0.000516717">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should infer Settings type correctly" time="0.00078848">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have includeDirectories setting in schema" time="0.000203567">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have loadMemoryFromIncludeDirectories setting in schema" time="0.000147773">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have folderTrustFeature setting in schema" time="0.000142123">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have debugKeystrokeLogging setting in schema" time="0.000166739">
        </testcase>
    </testsuite>
    <testsuite name="src/config/trustedFolders.test.ts" timestamp="2025-10-02T21:38:22.673Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.008616583">
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load empty rules if no files exist" time="0.002527459">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load user rules if only user file exists" time="0.000496599">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should handle JSON parsing errors gracefully" time="0.000696901">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; setValue should update the user config and save it" time="0.001016772">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a directly trusted folder" time="0.000829585">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted folder" time="0.000223554">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted parent folder" time="0.000218163">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return false for a directly untrusted folder" time="0.000245284">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined for a child of an untrusted folder" time="0.000235346">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined when no rules match" time="0.00024281">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should prioritize trust over distrust" time="0.000223614">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should handle path normalization" time="0.000271823">
        </testcase>
    </testsuite>
    <testsuite name="src/services/BuiltinCommandLoader.test.ts" timestamp="2025-10-02T21:38:22.673Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.003826845">
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should correctly pass the config object to command factory functions" time="0.002347937">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should filter out null command definitions returned by factories" time="0.000235566">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should handle a null config gracefully when calling factories" time="0.000173201">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should return a list of all loaded commands" time="0.000262817">
        </testcase>
    </testsuite>
    <testsuite name="src/services/CommandService.test.ts" timestamp="2025-10-02T21:38:22.673Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.016005982">
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from a single loader" time="0.005254407">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should aggregate commands from multiple loaders" time="0.001242049">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should override commands from earlier loaders with those from later loaders" time="0.001795434">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle loaders that return an empty array of commands gracefully" time="0.000505897">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from successful loaders even if one fails" time="0.001344529">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; getCommands should return a readonly array that cannot be mutated" time="0.000886451">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should pass the abort signal to all loaders" time="0.001563084">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should rename extension commands when they conflict" time="0.000646427">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle user/project command override correctly" time="0.000505035">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle secondary conflicts when renaming extension commands" time="0.000439032">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle multiple secondary conflicts with incrementing suffixes" time="0.000376958">
        </testcase>
    </testsuite>
    <testsuite name="src/services/FileCommandLoader.test.ts" timestamp="2025-10-02T21:38:22.674Z" hostname="uby" tests="36" failures="0" errors="0" skipped="0" time="0.177595114">
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads a single command from a file" time="0.07546863">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked directory" time="0.003334413">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked subdirectory" time="0.002237904">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads multiple commands" time="0.002610713">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates deeply nested namespaces correctly" time="0.002415262">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates namespaces from nested directories" time="0.00198246">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; returns both user and project commands in order" time="0.002816053">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files with TOML syntax errors" time="0.004933414">
            <system-err>
[FileCommandLoader] Failed to parse TOML file /home/atmandk/.qwen/commands/invalid.toml: Invalid character, expected &quot;=&quot; at row 1, col 7, pos 6:
1&gt; this is not valid toml
         ^



            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files that are semantically invalid (missing prompt)" time="0.003686065">
            <system-err>
[FileCommandLoader] Skipping invalid command file: /home/atmandk/.qwen/commands/no_prompt.toml. Validation errors: {
  formErrors: [],
  fieldErrors: { prompt: [ [32m&quot;The &apos;prompt&apos; field is required.&quot;[39m ] }
}

            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles filename edge cases correctly" time="0.001776509">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles file system errors gracefully" time="0.00121513">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses a default description if not provided" time="0.001548527">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses the provided description" time="0.001560328">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; should sanitize colons in filenames to prevent namespace conflicts" time="0.001514814">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only DefaultArgumentProcessor if no {{args}} or !{} are present" time="0.003930757">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if {{args}} is present (but not !{})" time="0.001438463">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and DefaultArgumentProcessor if !{} is present (but not {{args}})" time="0.000954978">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if both {{args}} and !{} are present" time="0.000937125">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates AtFileProcessor and DefaultArgumentProcessor if @{} is present" time="0.001011894">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and AtFileProcessor if !{} and @{} are present" time="0.001358916">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor and AtFileProcessor if {{args}} and @{} are present" time="0.001337005">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; loads commands from active extensions" time="0.003070234">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; extension commands have extensionName metadata for conflict resolution" time="0.004501224">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; only loads commands from active extensions" time="0.002378273">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles missing extension commands directory gracefully" time="0.001542796">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles nested command structure in extensions" time="0.004252754">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Argument Handling Integration (via ShellProcessor) &gt; correctly processes a command with {{args}}" time="0.002623386">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Default Argument Processor Integration &gt; correctly processes a command without {{args}}" time="0.002374275">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if {{args}} is present (even without shell trigger)" time="0.003148469">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if the trigger is present" time="0.002716559">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; does not instantiate ShellProcessor if no triggers ({{args}} or !{}) are present" time="0.001814951">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;submit_prompt&quot; action if shell processing succeeds" time="0.002877798">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;confirm_shell_commands&quot; action if shell processing requires it" time="0.002233195">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; re-throws other errors from the processor" time="0.005355275">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; assembles the processor pipeline in the correct order (AtFile -&gt; Shell -&gt; Default)" time="0.008635758">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; @-file Processor Integration &gt; correctly processes a command with @{file}" time="0.003415423">
        </testcase>
    </testsuite>
    <testsuite name="src/services/McpPromptLoader.test.ts" timestamp="2025-10-02T21:38:22.675Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.003968327">
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle multi-word positional arguments" time="0.001957194">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle quoted multi-word positional arguments" time="0.00019466">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a single positional argument with multiple words" time="0.000089616">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped quotes in positional arguments" time="0.000065572">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped backslashes in positional arguments" time="0.000057536">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle named args followed by positional args" time="0.000074147">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args followed by named args" time="0.000057827">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args interspersed with named args" time="0.000063287">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should treat an escaped quote at the start as a literal" time="0.000063607">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a complex mix of args" time="0.000087973">
        </testcase>
    </testsuite>
    <testsuite name="src/test-utils/mockCommandContext.test.ts" timestamp="2025-10-02T21:38:22.675Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.005542582">
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should return a valid CommandContext object with default mocks" time="0.002779496">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply top-level overrides correctly" time="0.001059962">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply deeply nested overrides correctly" time="0.000539298">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/App.test.tsx" timestamp="2025-10-02T21:38:22.675Z" hostname="uby" tests="49" failures="0" errors="0" skipped="0" time="1.918728265">
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not start the update process when running from git" time="0.109526101">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Static inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show a success message when update succeeds" time="0.085887317">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when update fails" time="0.073971226">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when spawn fails" time="0.076361762">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not auto-update if GEMINI_CLI_DISABLE_AUTOUPDATER is true" time="0.027393585">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file when available" time="0.024629477">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display any files when not available" time="0.022357061">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other open files" time="0.026189696">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other context" time="0.023582419">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; in footer when contextFileName is not set and count is 1" time="0.015461435">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; with plural when contextFileName is not set and count is &gt; 1" time="0.021497369">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName in footer when set and count is 1" time="0.024250657">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display a generic message when multiple context files with different names are provided" time="0.02801779">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName with plural when set and count is &gt; 1" time="0.02397728">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display context file message if count is 0, even if contextFileName is set" time="0.020507086">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display QWEN.md and MCP server count when both are present" time="0.032099557">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display only MCP server count when QWEN.md count is 0" time="0.027885736">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Tips component by default" time="0.033363888">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Tips component when hideTips is true" time="0.018919267">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Header component by default" time="0.020760154">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Header component when hideBanner is true" time="0.025733241">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Footer component by default" time="0.024459172">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Footer component when hideFooter is true" time="0.012653446">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show footer if system says show, but workspace and user settings say hide" time="0.016811463">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show tips if system says show, but workspace and user settings say hide" time="0.017288066">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display theme dialog if NO_COLOR is not set" time="0.019804836">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display a message if NO_COLOR is set" time="0.020926633">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render the initial UI correctly" time="0.027167847">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render correctly with the prompt input box" time="0.03035657">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; with initial prompt from --prompt-interactive &gt; should submit the initial prompt automatically" time="0.101641192">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; errorCount &gt; should correctly sum the counts of error messages" time="0.030312739">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should call validateAuthMethod when useExternalAuth is false" time="0.02637548">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should NOT call validateAuthMethod when useExternalAuth is true" time="0.023403868">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when in a narrow terminal &gt; should render with a column layout" time="0.029043931">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; NO_COLOR smoke test &gt; should render without errors when NO_COLOR is set" time="0.028608785">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when isFolderTrustDialogOpen is true" time="0.037548925">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when the feature is enabled but the folder is not trusted" time="0.033000114">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should not display the folder trust dialog when the feature is disabled" time="0.058879827">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should queue messages when handleFinalSubmit is called during streaming" time="0.033873812">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should auto-send queued messages when transitioning from Responding to Idle" time="0.091997048">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should display queued messages with dimmed color" time="0.031515386">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should clear message queue after sending" time="0.029272483">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should handle empty messages by filtering them out" time="0.027853115">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should combine multiple queued messages with double newlines" time="0.036720953">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should limit displayed messages to MAX_DISPLAYED_QUEUED_MESSAGES" time="0.023416943">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should render message queue display without errors" time="0.02272447">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should pass debugKeystrokeLogging setting to KeypressProvider" time="0.024024958">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should use default false value when debugKeystrokeLogging is not set" time="0.022774894">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Ctrl+C behavior &gt; should call cancel but only clear the prompt when a tool is executing" time="0.269625178">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/keyMatchers.test.ts" timestamp="2025-10-02T21:38:22.677Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.016767653">
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match return correctly" time="0.005848017">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match escape correctly" time="0.000532265">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match home correctly" time="0.00029174">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match end correctly" time="0.000269729">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineRight correctly" time="0.000185664">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineLeft correctly" time="0.00022176">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearInput correctly" time="0.000163823">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearScreen correctly" time="0.00016199">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyUp correctly" time="0.000457377">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyDown correctly" time="0.000188088">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationUp correctly" time="0.000185975">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationDown correctly" time="0.000171538">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestion correctly" time="0.000160157">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionUp correctly" time="0.000170275">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionDown correctly" time="0.000308731">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submit correctly" time="0.001051808">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match newline correctly" time="0.000254822">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match openExternalEditor correctly" time="0.000196814">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match pasteClipboardImage correctly" time="0.000148795">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showErrorDetails correctly" time="0.000141913">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleToolDescriptions correctly" time="0.000154987">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleIDEContextDetail correctly" time="0.000144037">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match quit correctly" time="0.000143877">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match exit correctly" time="0.00072338">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showMoreLines correctly" time="0.000172169">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleYoloMode correctly" time="0.000127185">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match reverseSearch correctly" time="0.000228893">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submitReverseSearch correctly" time="0.000148815">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestionReverseSearch correctly" time="0.000242749">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should properly handle ACCEPT_SUGGESTION_REVERSE_SEARCH cases" time="0.000147914">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should work with custom configuration" time="0.000202214">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should support multiple key bindings for same command" time="0.000798518">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Edge Cases &gt; should handle empty binding arrays" time="0.00014035">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/cleanup.test.ts" timestamp="2025-10-02T21:38:22.678Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.003003751">
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered synchronous function" time="0.001608738">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered asynchronous function" time="0.000209628">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run multiple registered functions" time="0.000146772">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should continue running cleanup functions even if one throws an error" time="0.00013485">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/gitUtils.test.ts" timestamp="2025-10-02T21:38:22.678Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.014409778">
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the git command fails" time="0.00713548">
            <system-out>
Failed to get git remote: Error: oops
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:29:13
    at mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at execSync (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at Module.isGitHubRepository [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.ts:17:7[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:31:12
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:155:11
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:26
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1897:20
    at new Promise (&lt;anonymous&gt;)
    at runWithTimeout (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1863:10)

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the remote is not github.com" time="0.000548896">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns true if the remote is github.com" time="0.000239353">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if github repo info cannot be determined" time="0.000711107">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if owner/repo could not be determined" time="0.000273356">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; returns the owner and repo" time="0.000839253">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root cannot be determined" time="0.000285369">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root is empty" time="0.000153204">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; returns the root" time="0.000096609">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch fails" time="0.001459682">
            <system-out>
Failed to determine latest run-gemini-cli release: nope

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch does not return a json body" time="0.000807364">
            <system-out>
Failed to determine latest run-gemini-cli release: Error: Response did not include tag_name field
    at Module.getLatestGitHubRelease [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.ts:82:13[90m)[39m
[90m    at processTicksAndRejections (node:internal/process/task_queues:105:5)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:135:5
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:20

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; returns the release version" time="0.000396324">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/handleAutoUpdate.test.ts" timestamp="2025-10-02T21:38:22.678Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.012400648">
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update info is null" time="0.00190674">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update nag is disabled" time="0.000440265">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if auto-updates are disabled" time="0.001613898">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if no update command is found" time="0.000300577">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should combine update messages correctly" time="0.00126971">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should attempt to perform an update when conditions are met" time="0.000330542">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the update process fails" time="0.001696751">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the spawn function throws an error" time="0.001682585">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should use the &quot;@nightly&quot; tag for nightly updates" time="0.000422022">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-success&quot; when the update process succeeds" time="0.001454854">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/installationInfo.test.ts" timestamp="2025-10-02T21:38:22.679Z" hostname="uby" tests="16" failures="0" errors="0" skipped="0" time="0.010845169">
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN when cliPath is not available" time="0.003072598">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN and log error if realpathSync fails" time="0.002133921">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running from a local git clone" time="0.000435016">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via npx" time="0.000262757">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via pnpx" time="0.000298843">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via bunx" time="0.000158904">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect Homebrew installation via execSync" time="0.001041949">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should fall through if brew command fails" time="0.000363683">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global pnpm installation" time="0.000429175">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global yarn installation" time="0.00020505">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global bun installation" time="0.000151099">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify yarn from lockfile" time="0.000218454">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify pnpm from lockfile" time="0.000237961">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify bun from lockfile" time="0.000152522">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to local npm installation if no lockfile is found" time="0.000109713">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to global npm installation for unrecognized paths" time="0.000147663">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/readStdin.test.ts" timestamp="2025-10-02T21:38:22.679Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.008155608">
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should read and accumulate data from stdin" time="0.003099147">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should handle empty stdin input" time="0.000353514">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should timeout and resolve with empty string when no input is available" time="0.002534773">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should clear timeout once when data is received and resolve with data" time="0.000570646">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/settingsUtils.test.ts" timestamp="2025-10-02T21:38:22.679Z" hostname="uby" tests="68" failures="0" errors="0" skipped="0" time="0.026189216">
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should group settings by category" time="0.001515666">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should include key property in grouped settings" time="0.001911058">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return definition for valid setting" time="0.000251375">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return undefined for invalid setting" time="0.0000971">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return true for settings that require restart" time="0.000946673">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for settings that do not require restart" time="0.000514963">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for invalid settings" time="0.00008647">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return correct default values" time="0.00012948">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return undefined for invalid settings" time="0.000248941">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getRestartRequiredSettings &gt; should return all settings that require restart" time="0.001254863">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from settings when set" time="0.000303301">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from merged settings when not set in current scope" time="0.000119461">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return default value when not set anywhere" time="0.000094986">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should handle nested settings correctly" time="0.000084446">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return undefined for invalid settings" time="0.000072915">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getAllSettingKeys &gt; should return all setting keys" time="0.000209959">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByType &gt; should return only boolean settings" time="0.002496752">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsRequiringRestart &gt; should return only settings that require restart" time="0.000711407">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return true for valid setting keys" time="0.001076613">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return false for invalid setting keys" time="0.000126594">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return correct category for valid settings" time="0.000105405">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return undefined for invalid settings" time="0.000051836">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for settings marked to show in dialog" time="0.000111166">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return false for settings marked to hide from dialog" time="0.000108611">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for invalid settings (default behavior)" time="0.000045635">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should only return settings marked for dialog display" time="0.000407655">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should not include Advanced category settings" time="0.000096659">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should include settings with showInDialog=true" time="0.000392016">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only boolean dialog settings" time="0.000284247">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only string dialog settings" time="0.000218565">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return only settings marked for dialog display" time="0.000558364">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return fewer keys than getAllSettingKeys" time="0.000149927">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should handle nested settings display correctly" time="0.005350365">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from settings when set" time="0.000231539">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from merged settings when not set in current scope" time="0.000072464">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return default value for invalid setting" time="0.000052136">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return true when value differs from default" time="0.000105155">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return false when value matches default" time="0.000087182">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for top-level settings that exist" time="0.000058969">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for top-level settings that do not exist" time="0.000046436">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for nested settings that exist" time="0.000053079">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for nested settings that do not exist" time="0.000044853">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false when parent exists but child does not" time="0.000050023">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set top-level setting value" time="0.000080299">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set nested setting value" time="0.000077474">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should preserve existing nested settings" time="0.000080739">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should not mutate original settings" time="0.00064815">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return true when modified settings require restart" time="0.000374433">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false when no modified settings require restart" time="0.000106387">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false for empty set" time="0.00005423">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return only settings that require restart" time="0.000245084">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return empty array when no settings require restart" time="0.000099634">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value without * when setting matches default" time="0.000079497">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value when setting is not in scope" time="0.00005425">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when changed from default" time="0.000141863">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value without * when setting does not exist in scope" time="0.000070651">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when user changes from default" time="0.00005946">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when setting does not exist in scope" time="0.000068717">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when setting exists in scope" time="0.000051325">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when nested setting does not exist in scope" time="0.000044492">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when nested setting exists in scope" time="0.00004857">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for top-level settings that exist in scope" time="0.000064569">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for top-level settings that do not exist in scope" time="0.000051846">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for nested settings that exist in scope" time="0.00005945">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for nested settings that do not exist in scope" time="0.000046977">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from settings when available" time="0.000061945">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from merged settings when not in scope" time="0.000050543">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return default value for undefined values" time="0.0000434">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/startupWarnings.test.ts" timestamp="2025-10-02T21:38:22.681Z" hostname="uby" tests="4" failures="0" errors="0" skipped="4" time="0">
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return warnings from the file and delete it" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an empty array if the file does not exist" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an error message if reading the file fails" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return a warning if deleting the file fails" time="0">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/utils/userStartupWarnings.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.019314428">
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should return a warning when running in home directory" time="0.011384527">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should not return a warning when running in a project directory" time="0.003017146">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should return a warning when running in a root directory" time="0.001365097">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should not return a warning when running in a non-root directory" time="0.000876202">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; error handling &gt; should handle errors when checking directory" time="0.001211823">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/install.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.012596239">
        <testcase classname="src/commands/extensions/install.test.ts" name="extensions install command &gt; should fail if no source is provided" time="0.009148647">
        </testcase>
        <testcase classname="src/commands/extensions/install.test.ts" name="extensions install command &gt; should fail if both git source and local path are provided" time="0.002110347">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/uninstall.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.010082767">
        <testcase classname="src/commands/extensions/uninstall.test.ts" name="extensions uninstall command &gt; should fail if no source is provided" time="0.00897177">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/add.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.037847309">
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add a stdio server to project settings" time="0.018167946">
            <system-out>
MCP server &quot;my-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add an sse server to user settings" time="0.004907085">
            <system-out>
MCP server &quot;sse-server&quot; added to user settings. (sse)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add an http server to project settings" time="0.003863663">
            <system-out>
MCP server &quot;http-server&quot; added to project settings. (http)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should handle MCP server args with -- separator" time="0.004163158">
            <system-out>
MCP server &quot;my-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should handle unknown options as MCP server args" time="0.004751216">
            <system-out>
MCP server &quot;test-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/list.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.006512687">
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display message when no servers configured" time="0.00285173">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display different server types with connected status" time="0.001837001">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display disconnected status when connection fails" time="0.000389351">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should merge extension servers with config servers" time="0.000296008">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/remove.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.020258085">
        <testcase classname="src/commands/mcp/remove.test.ts" name="mcp remove command &gt; should remove a server from project settings" time="0.015874059">
            <system-out>
Server &quot;test-server&quot; removed from project settings.

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/remove.test.ts" name="mcp remove command &gt; should show a message if server not found" time="0.003182632">
        </testcase>
    </testsuite>
    <testsuite name="src/config/__tests__/env-persist.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.00284109">
        <testcase classname="src/config/__tests__/env-persist.test.ts" name="env persistence &gt; writes to discovered .env file and returns the path" time="0.001863731">
        </testcase>
    </testsuite>
    <testsuite name="src/config/extensions/variables.test.ts" timestamp="2025-10-02T21:38:22.682Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.002551073">
        <testcase classname="src/config/extensions/variables.test.ts" name="hydrateString &gt; should replace a single variable" time="0.001275802">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/argumentProcessor.test.ts" timestamp="2025-10-02T21:38:22.683Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.004224651">
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should append the full command if args are provided" time="0.00259843">
        </testcase>
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should NOT append the full command if no args are provided" time="0.000368392">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/atFileProcessor.test.ts" timestamp="2025-10-02T21:38:22.683Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.017615503">
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if no @{ trigger is present" time="0.003103836">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if config service is missing" time="0.000885099">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace a single valid @{path/to/file.txt} placeholder" time="0.001449854">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace multiple different @{...} placeholders" time="0.000748486">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should handle placeholders at the beginning, middle, and end" time="0.000563063">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should correctly parse paths that contain balanced braces" time="0.000779393">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should throw an error if the prompt contains an unclosed trigger" time="0.002677928">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Integration and Error Handling &gt; should leave the placeholder unmodified if readPathFromWorkspace throws" time="0.002007877">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{not-found.txt}&apos;: File not found. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with an ERROR on failure" time="0.002481695">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{bad-file.txt}&apos;: Access denied. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with a WARNING if the file was ignored" time="0.000968032">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should NOT call ui.addItem on success" time="0.000619106">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/injectionParser.test.ts" timestamp="2025-10-02T21:38:22.683Z" hostname="uby" tests="21" failures="0" errors="0" skipped="0" time="0.015027952">
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should return an empty array if no trigger is present" time="0.005325329">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract a single, simple injection" time="0.000389642">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract multiple injections" time="0.000933859">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should handle different triggers (e.g., @{)" time="0.000162441">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle injections at the start and end of the prompt" time="0.000262606">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle adjacent injections" time="0.000215659">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle empty injections" time="0.000126404">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should trim whitespace within the content" time="0.000108301">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore similar patterns that are not the exact trigger" time="0.002912693">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore extra closing braces before the trigger" time="0.00029166">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should stop parsing at the first balanced closing brace (non-greedy)" time="0.000133136">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with simple nested braces (e.g., JSON)" time="0.000306106">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with shell constructs (e.g., awk)" time="0.000279998">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse multiple levels of nesting" time="0.000168372">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse paths containing balanced braces" time="0.000113821">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly handle an injection containing the trigger itself" time="0.000110304">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error for a simple unclosed injection" time="0.00082667">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error if the prompt ends inside a nested block" time="0.000202475">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should include the context name in the error message if provided" time="0.000160056">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw if content contains unbalanced braces (e.g., missing closing)" time="0.00012973">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should clearly state that unbalanced braces in content are not supported in the error" time="0.000138446">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/shellProcessor.test.ts" timestamp="2025-10-02T21:38:22.684Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.0435412">
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw an error if config is missing" time="0.00413223">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not change the prompt if no shell injections are present" time="0.001581077">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process a single valid shell injection if allowed" time="0.003119836">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process multiple valid shell injections if all are allowed" time="0.001056596">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError if a command is not allowed in default mode" time="0.000775927">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should NOT throw ConfirmationRequiredError if a command is not allowed but approval mode is YOLO" time="0.001275551">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should still throw an error for a hard-denied command even in YOLO mode" time="0.000957994">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with the correct command" time="0.000581146">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with multiple commands if multiple are disallowed" time="0.001776098">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not execute any commands if at least one requires confirmation" time="0.000775666">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should only request confirmation for disallowed commands in a mixed prompt" time="0.000779272">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should execute all commands if they are on the session allowlist" time="0.001187258">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should trim whitespace from the command inside the injection before interpolation" time="0.001248842">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should handle an empty command inside the injection gracefully (skips execution)" time="0.000853651">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append exit code and command name on failure" time="0.000809189">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append signal info and command name if terminated by signal" time="0.00065378">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should throw a detailed error if the shell fails to spawn" time="0.000922298">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should report abort status with command name if aborted" time="0.001473858">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement if no shell injections are present (optimization path)" time="0.000791335">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement outside !{} blocks" time="0.000720955">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform escaped replacement inside !{} blocks" time="0.000882484">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should handle both raw (outside) and escaped (inside) injection simultaneously" time="0.001140722">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform security checks on the final, resolved (escaped) command" time="0.001786087">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should report the resolved command if a hard denial occurs" time="0.000808126">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should correctly handle multiline arguments" time="0.000753695">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;spaces&apos;" time="0.000693253">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;double quotes&apos;" time="0.000646617">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;single quotes&apos;" time="0.00074541">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (backticks)&apos;" time="0.000690218">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (dollar)&apos;" time="0.000657437">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;variable expansion&apos;" time="0.002503735">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (semicolon)&apos;" time="0.00325152">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (ampersand)&apos;" time="0.001552585">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/KeypressContext.test.tsx" timestamp="2025-10-02T21:38:22.685Z" hostname="uby" tests="32" failures="0" errors="0" skipped="0" time="0.200835519">
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize regular enter key (keycode 13) in kitty protocol" time="0.027776374">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize numpad enter key (keycode 57414) in kitty protocol" time="0.004515981">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with modifiers" time="0.003724916">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Ctrl modifier" time="0.004382453">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Alt modifier" time="0.002667238">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should not process kitty sequences when kitty protocol is disabled" time="0.002460706">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Escape key handling &gt; should recognize escape key (keycode 27) in kitty protocol" time="0.002301972">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Tab key in kitty protocol" time="0.002275012">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Shift+Tab in kitty protocol" time="0.003720068">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Backspace key in kitty protocol" time="0.004500111">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Option+Backspace in kitty protocol" time="0.002501581">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; should handle multiline paste as a single event" time="0.011118935">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complete paste sequence with markers" time="0.007760477">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle empty paste sequence" time="0.007204769">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data before paste markers" time="0.006687371">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data after paste markers" time="0.006974142">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complex sequence with multiple paste blocks" time="0.005019102">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle fragmented paste markers across multiple data events" time="0.00297586">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle multiline content within paste markers" time="0.006745479">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle paste markers split across buffer boundaries" time="0.006142241">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; buffers fragmented paste chunks before emitting newlines" time="0.010228998">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should buffer input data and wait for timeout" time="0.004087176">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should concatenate new data and reset timeout" time="0.003932591">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should flush immediately when buffer exceeds limit" time="0.00431562">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should clear timeout when new data arrives" time="0.008124972">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle multiple separate keypress events" time="0.004641063">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle rapid sequential data within buffer limit" time="0.00603374">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should not log keystrokes when debugKeystrokeLogging is false" time="0.006180282">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer accumulation when debugKeystrokeLogging is true" time="0.009407196">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer overflow when debugKeystrokeLogging is true" time="0.00675771">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer clear on Ctrl+C when debugKeystrokeLogging is true" time="0.0035539">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should show char codes when debugKeystrokeLogging is true even without debug mode" time="0.004744955">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/SessionContext.test.tsx" timestamp="2025-10-02T21:38:22.686Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.042059587">
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should provide the correct initial state" time="0.019289863">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SessionStatsProvider inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should update metrics when the uiTelemetryService emits an update" time="0.003647362">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SessionStatsProvider inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. Import `act` from `react` instead of `react-dom/test-utils`. See https://react.dev/warnings/react-dom-test-utils for more info.

            </system-err>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should throw an error when useSessionStats is used outside of a provider" time="0.017309115">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/aboutCommand.test.ts" timestamp="2025-10-02T21:38:22.686Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.011652944">
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should have the correct name and description" time="0.002505609">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should call addItem with all version info" time="0.00333849">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show the correct sandbox environment variable" time="0.00157745">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show sandbox-exec profile when applicable" time="0.001747054">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should not show ide client when it is not detected" time="0.001255284">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/approvalModeCommand.test.ts" timestamp="2025-10-02T21:38:22.686Z" hostname="uby" tests="19" failures="0" errors="0" skipped="0" time="0.023999993">
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should have the correct command properties" time="0.003365862">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should show current mode, options, and usage when no arguments provided" time="0.000996585">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when config is not available" time="0.00178803">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should change approval mode when valid mode is provided" time="0.002924584">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should accept canonical auto-edit mode value" time="0.001305978">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should accept auto-edit alias for compatibility" time="0.000752704">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when invalid mode is provided" time="0.000803708">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when setApprovalMode throws an error" time="0.000916858">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting auto-edit with user scope via nested subcommands" time="0.00105843">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting plan with project scope via nested subcommands" time="0.000924672">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting plan with session scope via nested subcommands" time="0.000510214">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow providing a scope argument after selecting a mode subcommand" time="0.000611031">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support --user plan pattern (scope first)" time="0.000485438">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support plan --user pattern (mode first)" time="0.000685589">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support --project auto-edit pattern" time="0.00057256">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when only scope flag is provided" time="0.000582258">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when multiple scope flags are provided" time="0.001234556">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should surface a helpful error when scope subcommands receive extra arguments" time="0.001143136">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should provide completion for approval modes" time="0.001547845">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/authCommand.test.ts" timestamp="2025-10-02T21:38:22.687Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.006209135">
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should return a dialog action to open the auth dialog" time="0.004215314">
        </testcase>
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should have the correct name and description" time="0.000743527">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/bugCommand.test.ts" timestamp="2025-10-02T21:38:22.687Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.00660077">
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should generate the default GitHub issue URL" time="0.004093728">
        </testcase>
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should use a custom URL template from config if provided" time="0.000947274">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/chatCommand.test.ts" timestamp="2025-10-02T21:38:22.687Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.035678043">
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; should have the correct main command definition" time="0.004139344">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should inform when no checkpoints are found" time="0.002046548">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should list found checkpoints" time="0.002422475">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should handle invalid date formats gracefully" time="0.000896049">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return an error if tag is missing" time="0.001455474">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should inform if conversation history is empty or only contains system context" time="0.00120978">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return confirm_action if checkpoint already exists" time="0.004663855">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should save the conversation if overwrite is confirmed" time="0.002676384">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should return an error if tag is missing" time="0.00132339">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should inform if checkpoint is not found" time="0.001178311">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should resume a conversation" time="0.001291611">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should provide completion suggestions" time="0.001443623">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should suggest filenames sorted by modified time (newest first)" time="0.001316918">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if tag is missing" time="0.001059051">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if checkpoint is not found" time="0.000959957">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should delete the conversation" time="0.001018676">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; completion &gt; should provide completion suggestions" time="0.004328554">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/clearCommand.test.ts" timestamp="2025-10-02T21:38:22.687Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.004795198">
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should set debug message, reset chat, reset telemetry, and clear UI when config is available" time="0.002941265">
        </testcase>
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should not attempt to reset chat if config service is not available" time="0.00097776">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/compressCommand.test.ts" timestamp="2025-10-02T21:38:22.688Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.014564594">
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should do nothing if a compression is already pending" time="0.005948994">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should set pending item, call tryCompressChat, and add result on success" time="0.002603319">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat returns falsy" time="0.000971789">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat throws" time="0.002977402">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should clear the pending item in a finally block" time="0.000645314">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/copyCommand.test.ts" timestamp="2025-10-02T21:38:22.688Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.015594942">
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no history is available" time="0.003461809">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when history is empty" time="0.000912169">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no AI messages are found in history" time="0.000629585">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should copy last AI message to clipboard successfully" time="0.001494507">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle multiple text parts in AI message" time="0.000862927">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should filter out non-text parts" time="0.000958805">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should get the last AI message when multiple AI messages exist" time="0.001151391">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle clipboard copy error" time="0.002220381">
            <system-out>
Clipboard access denied

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle non-Error clipboard errors" time="0.000787839">
            <system-out>
String error

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no text parts found in AI message" time="0.000553404">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle unavailable config service" time="0.001031119">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/corgiCommand.test.ts" timestamp="2025-10-02T21:38:22.688Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.006005398">
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should call the toggleCorgiMode function on the UI context" time="0.003643966">
        </testcase>
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should have the correct name and description" time="0.000993119">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/directoryCommand.test.tsx" timestamp="2025-10-02T21:38:22.688Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.013889014">
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; show &gt; should display the list of directories" time="0.005380782">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if no path is provided" time="0.000951351">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory and show a success message for a single path" time="0.001057839">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory for each path and show a success message for multiple paths" time="0.00053986">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if addDirectory throws an exception" time="0.000640025">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should handle a mix of successful and failed additions" time="0.000485108">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; should correctly expand a Windows-style home directory path" time="0.003300199">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/docsCommand.test.ts" timestamp="2025-10-02T21:38:22.688Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.008629957">
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should add an info message and call &apos;open&apos; in a non-sandbox environment" time="0.005040602">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should only add an info message in a sandbox environment" time="0.001349439">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should not open browser for &apos;sandbox-exec&apos;" time="0.001129531">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/editorCommand.test.ts" timestamp="2025-10-02T21:38:22.689Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.005473583">
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should return a dialog action to open the editor dialog" time="0.003922532">
        </testcase>
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should have the correct name and description" time="0.000320653">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/exportCommand.test.ts" timestamp="2025-10-02T21:38:22.689Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.036537804">
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should have correct name and description" time="0.002480412">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should export conversation with default filename" time="0.029912128">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle custom filename" time="0.001670112">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle export error" time="0.000927257">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/extensionsCommand.test.ts" timestamp="2025-10-02T21:38:22.689Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007088563">
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should display &quot;No active extensions.&quot; when none are found" time="0.005056922">
        </testcase>
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should list active extensions when they are found" time="0.000870923">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/helpCommand.test.ts" timestamp="2025-10-02T21:38:22.689Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007711166">
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should add a help message to the UI history" time="0.005695104">
        </testcase>
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should have the correct command properties" time="0.000894546">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/ideCommand.test.ts" timestamp="2025-10-02T21:38:22.689Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="5.045920522">
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return null if config is not provided" time="0.004120599">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return the ide command" time="0.004133022">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should show disable command when connected" time="0.001821372">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connected status" time="0.0026356">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connecting status" time="0.000909604">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status" time="0.000699465">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status with details" time="0.00098831">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should install the extension" time="5.026066394">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should show an error if installation fails" time="0.002829839">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/initCommand.test.ts" timestamp="2025-10-02T21:38:22.689Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.011540295">
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should ask for confirmation if QWEN.md already exists and is non-empty" time="0.003898938">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should create QWEN.md and submit a prompt if it does not exist" time="0.003226433">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should proceed to initialize when QWEN.md exists but is empty" time="0.000782729">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should regenerate QWEN.md when overwrite is confirmed" time="0.001265844">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should return an error if config is not available" time="0.000946432">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/loggingCommand.test.ts" timestamp="2025-10-02T21:38:22.689Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.0108407">
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; enables logging when /logging on is issued" time="0.006214024">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; disables logging when /logging off is issued" time="0.00129656">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; reports status when invoked without arguments" time="0.00123141">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; shows usage for unknown arguments" time="0.000770095">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/mcpCommand.test.ts" timestamp="2025-10-02T21:38:22.690Z" hostname="uby" tests="35" failures="0" errors="0" skipped="0" time="0.076935515">
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if config is not available" time="0.003621695">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if tool registry is not available" time="0.001046698">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; no MCP servers configured &gt; should display a message with a URL when no MCP servers are configured" time="0.002375879">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display configured MCP servers with status indicators and their tools" time="0.00253889">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display tool descriptions when desc argument is used" time="0.002825822">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should not display descriptions when nodesc argument is used" time="0.00122619">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should indicate when a server has no tools" time="0.001264871">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should show startup indicator when servers are connecting" time="0.000856365">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display the extension name for servers from extensions" time="0.001362572">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display blocked MCP servers" time="0.001110085">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display both active and blocked servers correctly" time="0.001043532">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should display tool schemas when schema argument is used" time="0.001617464">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should handle tools without parameter schemas gracefully" time="0.003488158">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;descriptions&quot; as alias for &quot;desc&quot;" time="0.002134241">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodescriptions&quot; as alias for &quot;nodesc&quot;" time="0.001740532">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle mixed case arguments" time="0.002578825">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;schema desc&quot;" time="0.005984059">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;desc schema&quot;" time="0.001423034">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;schema&quot; alone showing descriptions" time="0.001302462">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;schema&quot; - &quot;schema nodesc&quot;" time="0.001452769">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;desc&quot; - &quot;desc nodesc&quot;" time="0.001460023">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding both &quot;desc&quot; and &quot;schema&quot; - &quot;desc schema nodesc&quot;" time="0.001372141">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle extra whitespace in arguments" time="0.001489758">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle empty arguments gracefully" time="0.00125871">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle unknown arguments gracefully" time="0.001294106">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle empty server names gracefully" time="0.001265533">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle servers with special characters in names" time="0.001183451">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should list OAuth-enabled servers when no server name is provided" time="0.003428277">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should show message when no OAuth servers are configured" time="0.001835838">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should authenticate with a specific server" time="0.004439028">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle authentication errors" time="0.004020764">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle non-existent server" time="0.002877277">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should refresh the list of tools and display the status" time="0.003374427">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if config is not available" time="0.00203066">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if tool registry is not available" time="0.002026993">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/memoryCommand.test.ts" timestamp="2025-10-02T21:38:22.691Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.015471574">
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display a message if memory is empty" time="0.005154883">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display the memory content and file count if it exists" time="0.001165578">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return an error message if no arguments are provided" time="0.000961961">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return a tool action and add an info message when arguments are provided" time="0.000835477">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --global flag and add scope to tool args" time="0.000700587">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --project flag and add scope to tool args" time="0.00075581">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return error if flag is provided but no fact follows" time="0.00053447">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with content" time="0.001335152">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with no content" time="0.000624065">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display an error message if refreshing fails" time="0.000788219">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should not throw if config service is unavailable" time="0.000979122">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/modelCommand.test.ts" timestamp="2025-10-02T21:38:22.691Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.006042046">
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should have the correct name and description" time="0.001630389">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when config is not available" time="0.000936414">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when content generator config is not available" time="0.000448731">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when auth type is not available" time="0.000290037">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for QWEN_OAUTH auth type" time="0.000310254">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for USE_OPENAI auth type when model is available" time="0.000341172">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for USE_OPENAI auth type when no model is available" time="0.000294606">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for unsupported auth types" time="0.000338847">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should handle undefined auth type" time="0.000369474">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/privacyCommand.test.ts" timestamp="2025-10-02T21:38:22.691Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.005350115">
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should return a dialog action to open the privacy dialog" time="0.003268922">
        </testcase>
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should have the correct name and description" time="0.000725964">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/quitCommand.test.ts" timestamp="2025-10-02T21:38:22.691Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.006550247">
        <testcase classname="src/ui/commands/quitCommand.test.ts" name="quitCommand &gt; returns a QuitActionReturn object with the correct messages" time="0.005463415">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/restoreCommand.test.ts" timestamp="2025-10-02T21:38:22.691Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.071174279">
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return null if checkpointing is not enabled" time="0.013563401">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return the command if checkpointing is enabled" time="0.004565192">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if temp dir is not found" time="0.002991749">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should inform when no checkpoints are found if no args are passed" time="0.002996999">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should list available checkpoints if no args are passed" time="0.006350577">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if the specified file is not found" time="0.004282248">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should handle file read errors gracefully" time="0.003708716">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore a tool call and project state" time="0.008756662">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore even if only toolCall is present" time="0.002829008">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return an error for a checkpoint file missing the toolCall property" time="0.004489983">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array if temp dir is not found" time="0.002102102">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array on readdir error" time="0.004322643">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return a list of checkpoint names" time="0.006420056">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/settingsCommand.test.ts" timestamp="2025-10-02T21:38:22.692Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.005810307">
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should return a dialog action to open the settings dialog" time="0.003392731">
        </testcase>
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should have the correct name and description" time="0.001054181">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/setupGithubCommand.test.ts" timestamp="2025-10-02T21:38:22.692Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.057094553">
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="setupGithubCommand &gt; returns a tool action to download github workflows and handles paths" time="0.02886495">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; creates a new .gitignore file when none exists" time="0.004578867">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; appends entries to existing .gitignore file" time="0.003883841">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not add duplicate entries" time="0.000993148">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; adds only missing entries when some already exist" time="0.001235878">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not get confused by entries in comments or as substrings" time="0.002482106">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles file system errors gracefully" time="0.00876131">
            <system-out>
Failed to update .gitignore: Error: ENOENT: no such file or directory, open &apos;/tmp/update-gitignore-7qwawG/non-existent/.gitignore&apos;
[90m    at open (node:internal/fs/promises:642:25)[39m
[90m    at Object.writeFile (node:internal/fs/promises:1249:14)[39m
    at Module.updateGitignore [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/commands/setupGithubCommand.ts:71:7[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/commands/setupGithubCommand.test.ts:218:5
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:20 {
  errno: [33m-2[39m,
  code: [32m&apos;ENOENT&apos;[39m,
  syscall: [32m&apos;open&apos;[39m,
  path: [32m&apos;/tmp/update-gitignore-7qwawG/non-existent/.gitignore&apos;[39m
}

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles permission errors gracefully" time="0.003310288">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/statsCommand.test.ts" timestamp="2025-10-02T21:38:22.692Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.011294269">
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display general session stats when run with no subcommand" time="0.006376846">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display model stats when using the &quot;model&quot; subcommand" time="0.000898503">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display tool stats when using the &quot;tools&quot; subcommand" time="0.000527927">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/terminalSetupCommand.test.ts" timestamp="2025-10-02T21:38:22.692Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.005616909">
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should have correct metadata" time="0.001561732">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return success message when terminal setup succeeds" time="0.001787319">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should append restart message when terminal setup requires restart" time="0.000421069">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return error message when terminal setup fails" time="0.000203187">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should handle exceptions from terminal setup" time="0.000389451">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/themeCommand.test.ts" timestamp="2025-10-02T21:38:22.693Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007241426">
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should return a dialog action to open the theme dialog" time="0.005075146">
        </testcase>
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should have the correct name and description" time="0.000846798">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/toolsCommand.test.ts" timestamp="2025-10-02T21:38:22.693Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.009985426">
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display an error if the tool registry is unavailable" time="0.005426837">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display &quot;No tools available&quot; when none are found" time="0.001391245">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools without descriptions by default" time="0.000827682">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools with descriptions when &quot;desc&quot; arg is passed" time="0.000499364">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/AuthDialog.test.tsx" timestamp="2025-10-02T21:38:22.693Z" hostname="uby" tests="10" failures="3" errors="0" skipped="0" time="0.577162604">
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should show an error if the initial auth type is invalid" time="0.069853684">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should detect GEMINI_API_KEY environment variable" time="0.017380268">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should not show the GEMINI_API_KEY message if QWEN_DEFAULT_AUTH_TYPE is set to something else" time="0.01189916">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should show the GEMINI_API_KEY message if QWEN_DEFAULT_AUTH_TYPE is set to use api key" time="0.011322312">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should select the auth type specified by QWEN_DEFAULT_AUTH_TYPE" time="0.048762507">
            <failure message="expected &apos;&apos; to contain &apos; 4. OpenAI&apos;" type="AssertionError">
AssertionError: expected &apos;&apos; to contain &apos; 4. OpenAI&apos;

- Expected
+ Received

-  4. OpenAI
+ 
+                                                                                                   
+  Get started                                                                                      
+                                                                                                   
+  How would you like to authenticate for this project?                                             
+                                                                                                   
+    1. Qwen OAuth                                                                                  
+   2. OpenRouter (OpenAI-compatible)                                                              
+    3. LM Studio (local)                                                                           
+    4. OpenAI                                                                                      
+                                                                                                   
+  (Use Enter to Set Auth)                                                                          
+                                                                                                   
+  Terms of Services and Privacy Notice for Qwen Code                                               
+                                                                                                   
+  https://github.com/QwenLM/Qwen3-Coder/blob/main/README.md                                        
+                                                                                                   
+ 

  src/ui/components/AuthDialog.test.tsx:226:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should fall back to default if QWEN_DEFAULT_AUTH_TYPE is not set" time="0.034084001">
            <failure message="expected &apos;&apos; to contain &apos; 1. Qwen OAuth&apos;" type="AssertionError">
AssertionError: expected &apos;&apos; to contain &apos; 1. Qwen OAuth&apos;

- Expected
+ Received

-  1. Qwen OAuth
+ 
+                                                                                                   
+  Get started                                                                                      
+                                                                                                   
+  How would you like to authenticate for this project?                                             
+                                                                                                   
+    1. Qwen OAuth                                                                                  
+   2. OpenRouter (OpenAI-compatible)                                                              
+    3. LM Studio (local)                                                                           
+    4. OpenAI                                                                                      
+                                                                                                   
+  (Use Enter to Set Auth)                                                                          
+                                                                                                   
+  Terms of Services and Privacy Notice for Qwen Code                                               
+                                                                                                   
+  https://github.com/QwenLM/Qwen3-Coder/blob/main/README.md                                        
+                                                                                                   
+ 

  src/ui/components/AuthDialog.test.tsx:261:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should show an error and fall back to default if QWEN_DEFAULT_AUTH_TYPE is invalid" time="0.022414296">
            <failure message="expected &apos;&apos; to contain &apos; 1. Qwen OAuth&apos;" type="AssertionError">
AssertionError: expected &apos;&apos; to contain &apos; 1. Qwen OAuth&apos;

- Expected
+ Received

-  1. Qwen OAuth
+ 
+                                                                                                   
+  Get started                                                                                      
+                                                                                                   
+  How would you like to authenticate for this project?                                             
+                                                                                                   
+    1. Qwen OAuth                                                                                  
+   2. OpenRouter (OpenAI-compatible)                                                              
+    3. LM Studio (local)                                                                           
+    4. OpenAI                                                                                      
+                                                                                                   
+  (Use Enter to Set Auth)                                                                          
+                                                                                                   
+  Terms of Services and Privacy Notice for Qwen Code                                               
+                                                                                                   
+  https://github.com/QwenLM/Qwen3-Coder/blob/main/README.md                                        
+                                                                                                   
+ 

  src/ui/components/AuthDialog.test.tsx:299:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should prevent exiting when no auth method is selected and show error message" time="0.125716346">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should not exit if there is already an error message" time="0.115518636">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should allow exiting when auth method is already selected" time="0.118190973">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ContextSummaryDisplay.test.tsx" timestamp="2025-10-02T21:38:22.694Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.036039">
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on a single line on a wide screen" time="0.020051873">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on multiple lines on a narrow screen" time="0.005312666">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should switch layout at the 80-column breakpoint" time="0.007190412">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should not render empty parts" time="0.002046318">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/FolderTrustDialog.test.tsx" timestamp="2025-10-02T21:38:22.695Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.323644863">
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should render the dialog with title and description" time="0.059542164">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call onSelect with DO_NOT_TRUST when escape is pressed and not restarting" time="0.072892481">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call onSelect when escape is pressed and is restarting" time="0.032823578">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should display restart message when isRestarting is true" time="0.028115692">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call process.exit when &quot;r&quot; is pressed and isRestarting is true" time="0.047961704">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call process.exit when &quot;r&quot; is pressed and isRestarting is false" time="0.077255908">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Footer.test.tsx" timestamp="2025-10-02T21:38:22.695Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.15369248">
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; renders the component" time="0.070243766">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display shortened path on a wide terminal" time="0.006820027">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display only the base directory name on a narrow terminal" time="0.005011879">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use wide layout at 80 columns" time="0.00422351">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use narrow layout at 79 columns" time="0.004847374">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the branch name when provided" time="0.004137751">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; does not display the branch name when not provided" time="0.006101767">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the model name and context percentage" time="0.006055801">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display untrusted when isTrustedFolder is false" time="0.010033425">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display custom sandbox info when SANDBOX env is set" time="0.009048833">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display macOS Seatbelt info when SANDBOX is sandbox-exec" time="0.006717286">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display &quot;no sandbox&quot; when SANDBOX is not set and folder is trusted" time="0.009916178">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should prioritize untrusted message over sandbox info" time="0.006056072">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Header.test.tsx" timestamp="2025-10-02T21:38:22.695Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.06189563">
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders the long logo on a wide terminal" time="0.039562023">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders custom ASCII art when provided" time="0.003025541">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; displays the version number when nightly is true" time="0.009718562">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; does not display the version number when nightly is false" time="0.008215129">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/HistoryItemDisplay.test.tsx" timestamp="2025-10-02T21:38:22.695Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.10005098">
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type" time="0.035190921">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type with slash command" time="0.002654374">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders StatsDisplay for &quot;stats&quot; type" time="0.025438997">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders AboutBox for &quot;about&quot; type" time="0.010228457">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ModelStatsDisplay for &quot;model_stats&quot; type" time="0.003728843">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ToolStatsDisplay for &quot;tool_stats&quot; type" time="0.003144621">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders SessionSummaryDisplay for &quot;quit&quot; type" time="0.018063622">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/InputPrompt.test.tsx" timestamp="2025-10-02T21:38:22.696Z" hostname="uby" tests="61" failures="0" errors="0" skipped="0" time="6.773764925">
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getPreviousCommand on up arrow in shell mode" time="0.171483328">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getNextCommand on down arrow in shell mode" time="0.124552461">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should set the buffer text when a shell history command is retrieved" time="0.119057227">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.addCommandToHistory on submit in shell mode" time="0.110671042">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call shell history methods when not in shell mode" time="0.219308909">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateUp for both up arrow and Ctrl+P when suggestions are showing" time="0.179319183">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateDown for both down arrow and Ctrl+N when suggestions are showing" time="0.188832837">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call completion navigation when suggestions are not showing" time="0.274934792">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle Ctrl+V when clipboard has an image" time="0.129288589">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should not insert anything when clipboard has no image" time="0.12155457">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle image save failure gracefully" time="0.116978839">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should insert image path at cursor position with proper spacing" time="0.12079279">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle errors during clipboard operations" time="0.117181273">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial parent command" time="0.113669422">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should append a sub-command when the parent command is already complete" time="0.116340507">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should handle the &quot;backspace&quot; edge case correctly" time="0.12311527">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial argument for a command" time="0.119133828">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete on Enter when suggestions are active, without submitting" time="0.133979353">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a command based on its altNames" time="0.11674765">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should not submit on Enter when the buffer is empty or only contains whitespace" time="0.117833831">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when isPerfectMatch is true" time="0.11511084">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when a complete leaf command is typed" time="0.113885572">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete an @-path on Enter without submitting" time="0.119138888">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should add a newline on enter when the line ends with a backslash" time="0.114369548">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should clear the buffer on Ctrl+C if it has text" time="0.114387831">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT clear the buffer on Ctrl+C if it is empty" time="0.112535332">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after @ without spaces" time="0.063253655">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after / without spaces" time="0.061842331">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following @" time="0.062906662">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following /" time="0.062621084">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is not after @ or /" time="0.097223224">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiline text correctly" time="0.061828386">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle single line slash command correctly" time="0.06267292">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters (emojis) correctly in paths" time="0.065405728">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with spaces after them" time="0.076769427">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in paths correctly" time="0.062339041">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion after unescaped space following escaped space" time="0.06290032">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiple escaped spaces in paths" time="0.070786761">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in slash commands" time="0.061310396">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with escaped spaces" time="0.061496261">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should not call buffer.handleInput when vim mode is enabled and vim handles the input" time="0.112110635">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call buffer.handleInput when vim mode is enabled but vim does not handle the input" time="0.112218775">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call handleInput when vim mode is disabled" time="0.107708385">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should handle bracketed paste when not focused" time="0.10877534">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should ignore regular keypresses when not focused" time="0.129357175">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \n newlines&apos;" time="0.106677086">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with extra slashes before \n newlines&apos;" time="0.107154169">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \r\n newlines&apos;" time="0.108814753">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should clear buffer on second ESC press" time="0.15838261">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should reset escape state on any non-ESC key" time="0.060756591">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC in shell mode by disabling shell mode" time="0.105585094">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC when completion suggestions are showing" time="0.108449026">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not call onEscapePromptChange when not provided" time="0.106017805">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not interfere with existing keyboard shortcuts" time="0.155791853">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; invokes reverse search on Ctrl+R" time="0.107708535">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; resets reverse search state on Escape" time="0.164607153">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; completes the highlighted entry on Tab and exits reverse-search" time="0.065130578">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; submits the highlighted entry on Enter and exits reverse-search" time="0.06365168">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; text and cursor position should be restored after reverse search" time="0.108079932">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line in multiline input" time="0.106448221">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line for single line input" time="0.108132269">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/LoadingIndicator.test.tsx" timestamp="2025-10-02T21:38:22.700Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.078222137">
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should not render when streamingState is Idle" time="0.019593214">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner, phrase, and time when streamingState is Responding" time="0.010793012">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner (static), phrase but no time/cancel when streamingState is WaitingForConfirmation" time="0.003596018">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the currentLoadingPhrase correctly" time="0.003809353">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly when Responding" time="0.003999485">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly in human-readable format" time="0.003509117">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render rightContent when provided" time="0.005274575">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should transition correctly between states using rerender" time="0.007611191">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display fallback phrase if thought is empty" time="0.002486042">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the subject of a thought" time="0.002341045">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should prioritize thought.subject over currentLoadingPhrase" time="0.002334803">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on a single line on a wide terminal" time="0.002565329">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on multiple lines on a narrow terminal" time="0.004297797">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use wide layout at 80 columns" time="0.002293486">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use narrow layout at 79 columns" time="0.001958676">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSelectionDialog.test.tsx" timestamp="2025-10-02T21:38:22.700Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.116868164">
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should setup escape key handler to call onCancel" time="0.0382585">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should not call onCancel for non-escape keys" time="0.008098363">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set correct initial index for current model" time="0.009917852">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set initial index to 0 when current model is not found" time="0.006496537">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should call onSelect when a model is selected" time="0.007614327">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle empty models array" time="0.006520621">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should create correct option items with proper labels" time="0.007330862">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show vision indicator for vision models" time="0.005930359">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show current indicator for the current model" time="0.009895119">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.007537986">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle multiple onSelect calls correctly" time="0.006930611">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelStatsDisplay.test.tsx" timestamp="2025-10-02T21:38:22.701Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.770678617">
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should render &quot;no API calls&quot; message when there are no active models" time="0.067707461">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should not display conditional rows if no model has data for them" time="0.108843599">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display conditional rows if at least one model has data" time="0.11076143">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display stats for multiple models correctly" time="0.23332538">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.230457821">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display a single model correctly" time="0.012021376">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSwitchDialog.test.tsx" timestamp="2025-10-02T21:38:22.701Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.119315397">
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup RadioButtonSelect with correct options" time="0.033489802">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect when an option is selected" time="0.01136442">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with SwitchSessionToVL when second option is selected" time="0.006431598">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with ContinueWithCurrentModel when third option is selected" time="0.007463077">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup escape key handler to call onSelect with ContinueWithCurrentModel" time="0.015608307">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should not call onSelect for non-escape keys" time="0.008405842">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should set initial index to 0 (first option)" time="0.008677986">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; VisionSwitchOutcome enum &gt; should have correct enum values" time="0.000331073">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle multiple onSelect calls correctly" time="0.011892658">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.006674376">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle escape key multiple times" time="0.00653535">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/OpenAIKeyPrompt.test.tsx" timestamp="2025-10-02T21:38:22.701Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.130048268">
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should render the prompt correctly" time="0.036806182">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should show the component with proper styling" time="0.010006807">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should handle paste with control characters" time="0.081921448">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/QwenOAuthProgress.test.tsx" timestamp="2025-10-02T21:38:22.701Z" hostname="uby" tests="22" failures="0" errors="0" skipped="0" time="0.270914826">
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state when deviceAuth is not provided" time="0.03795043">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state with gray border" time="0.00577893">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should render authentication flow when deviceAuth is provided" time="0.005592835">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should display correct URL in Static component when QR code is generated" time="0.024024238">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format time correctly" time="0.009775218">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format single digit seconds with leading zero" time="0.007757472">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should countdown and call onTimeout when timer expires" time="0.026495483">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should update time remaining display" time="0.009894338">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should use default 300 second timeout when deviceAuth is null" time="0.006198867">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Animated dots &gt; should cycle through animated dots" time="0.040813431">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should generate QR code when deviceAuth is provided" time="0.007886792">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should display QR code in Static component when available" time="0.011845701">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should handle QR code generation errors gracefully" time="0.006257986">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should not generate QR code when deviceAuth is null" time="0.004216627">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC key is pressed" time="0.021106356">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC is pressed in loading state" time="0.003608781">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should not call onCancel for other key presses" time="0.005030754">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should display initial timer value from deviceAuth" time="0.004662583">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should reset to loading state when deviceAuth becomes null" time="0.007952794">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render timeout state when authStatus is timeout" time="0.004242755">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render default timeout message when no authMessage provided" time="0.010048374">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should call onCancel for any key press in timeout state" time="0.007375205">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SessionSummaryDisplay.test.tsx" timestamp="2025-10-02T21:38:22.702Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.05631029">
        <testcase classname="src/ui/components/SessionSummaryDisplay.test.tsx" name="&lt;SessionSummaryDisplay /&gt; &gt; renders the summary display with a title" time="0.055093708">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SettingsDialog.test.tsx" timestamp="2025-10-02T21:38:22.702Z" hostname="uby" tests="39" failures="0" errors="0" skipped="0" time="3.896155496">
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should render the settings dialog with default state" time="0.072949045">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should show settings list with default values" time="0.042729057">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should highlight first setting by default" time="0.032967234">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate down with arrow key" time="0.166919498">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate up with arrow key" time="0.137403825">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate with vim keys (j/k)" time="0.128601107">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should not navigate beyond bounds" time="0.075278067">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should toggle setting with Enter key" time="0.088398929">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should toggle setting with Space key" time="0.083975479">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should handle vim mode setting specially" time="0.106760762">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Scope Selection &gt; should switch between scopes" time="0.12764164">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Scope Selection &gt; should reset to settings focus when scope is selected" time="0.027592534">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Restart Prompt &gt; should show restart prompt for restart-required settings" time="0.081725333">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Restart Prompt &gt; should handle restart request when r is pressed" time="0.068020841">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Escape Key Behavior &gt; should call onSelect with undefined when Escape is pressed" time="0.026554271">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Persistence &gt; should persist settings across scope changes" time="0.122436263">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Persistence &gt; should show different values for different scopes" time="0.015017022">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Handling &gt; should handle vim mode toggle errors gracefully" time="0.0782344">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
Failed to toggle vim mode: Error: Toggle failed
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/SettingsDialog.test.tsx:540:46
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:155:11
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:26
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1897:20
    at new Promise (&lt;anonymous&gt;)
    at runWithTimeout (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1863:10)
    at runTest (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1574:12)
    at runSuite (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1729:8)
    at runSuite (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1729:8)
    at runSuite (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1729:8)

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex State Management &gt; should track modified settings correctly" time="0.174059466">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Saving general.disableAutoUpdate immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex State Management &gt; should handle scrolling when there are many settings" time="0.193554128">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; VimMode Integration &gt; should sync with VimModeContext when vim mode is toggled" time="0.06988907">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should show correct display values for settings with different states" time="0.014732926">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should handle immediate settings save for non-restart-required settings" time="0.091465555">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should show restart prompt for restart-required settings" time="0.088321926">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should clear restart prompt when switching scopes" time="0.02107131">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Display Values &gt; should show correct values for inherited settings" time="0.014125451">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Display Values &gt; should show override indicator for overridden settings" time="0.014174883">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle rapid key presses gracefully" time="0.121757396">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle Ctrl+C to reset current setting to default" time="0.070053765">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle Ctrl+L to reset current setting to default" time="0.070899069">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle navigation when only one setting exists" time="0.119783953">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should properly handle Tab navigation between sections" time="0.032417336">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Recovery &gt; should handle malformed settings gracefully" time="0.014561749">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Recovery &gt; should handle missing setting definitions gracefully" time="0.013812462">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should handle complete user workflow: navigate, toggle, change scope, exit" time="0.031148937">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should allow changing multiple settings without losing pending changes" time="0.285020394">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Saving general.disableAutoUpdate immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [ [32m&apos;general.enablePromptCompletion&apos;[39m ] Needs restart: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should maintain state consistency during complex interactions" time="0.273076029">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should handle restart workflow correctly" time="0.079948592">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; String Settings Editing &gt; should allow editing and committing a string setting" time="0.612659316">
            <system-out>
[DEBUG SettingsDialog] Modified settings: [ [32m&apos;ui.accessibility.disableLoadingPhrases&apos;[39m ] Needs restart: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [
  [32m&apos;ui.accessibility.disableLoadingPhrases&apos;[39m,
  [32m&apos;ui.accessibility.screenReader&apos;[39m
] Needs restart: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [
  [32m&apos;ui.accessibility.disableLoadingPhrases&apos;[39m,
  [32m&apos;ui.accessibility.screenReader&apos;[39m
] Needs restart: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ShellConfirmationDialog.test.tsx" timestamp="2025-10-02T21:38:22.705Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.085074533">
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; renders correctly" time="0.052557773">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedOnce when &quot;Yes, allow once&quot; is selected" time="0.013572137">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedAlways when &quot;Yes, allow always for this session&quot; is selected" time="0.007831559">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with Cancel when &quot;No (esc)&quot; is selected" time="0.009653973">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/StatsDisplay.test.tsx" timestamp="2025-10-02T21:38:22.706Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.778893285">
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders only the Performance section in its zero state" time="0.092576904">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders a table with two models correctly" time="0.113317943">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders all sections when all data is present" time="0.06618357">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides User Agreement when no decisions are made" time="0.033025903">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides Efficiency section when cache is not used" time="0.056017438">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in green for high values" time="0.09772795">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in yellow for medium values" time="0.030229054">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in red for low values" time="0.04911493">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; displays Code Changes when line counts are present" time="0.121659797">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; hides Code Changes when no lines are added or removed" time="0.068415352">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the default title when no title prop is provided" time="0.009899908">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the custom title when a title prop is provided" time="0.025622928">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/TodoDisplay.test.tsx" timestamp="2025-10-02T21:38:22.706Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.040258943">
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render todo list" time="0.025394294">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should display correct status icons" time="0.004220053">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle empty todo list" time="0.000985164">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle undefined todos" time="0.000358383">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with different statuses" time="0.002258001">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with mixed statuses" time="0.001855355">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ToolStatsDisplay.test.tsx" timestamp="2025-10-02T21:38:22.706Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.193359378">
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should render &quot;no tool calls&quot; message when there are no active tools" time="0.063679363">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for a single tool correctly" time="0.029049672">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for multiple tools correctly" time="0.027294242">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.038351152">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle zero decisions gracefully" time="0.031535564">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/color-utils.test.ts" timestamp="2025-10-02T21:38:22.706Z" hostname="uby" tests="16" failures="0" errors="0" skipped="0" time="0.01170482">
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate hex colors" time="0.001386046">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names" time="0.000439183">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names case insensitive" time="0.000645926">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names" time="0.001480411">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names case insensitive" time="0.000168411">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should reject invalid color names" time="0.000108521">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve hex colors" time="0.000226069">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve Ink-supported color names" time="0.000190523">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve CSS color names to hex" time="0.000586536">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should handle case insensitive color names" time="0.000141502">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should return undefined for invalid colors" time="0.001423625">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should contain expected CSS color mappings" time="0.00094485">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should not contain Ink-supported color names" time="0.000120663">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should contain all Ink-supported color names" time="0.000293784">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should not contain CSS color names" time="0.000202746">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; Consistency between validation and resolution &gt; should have consistent behavior between isValidColor and resolveColor" time="0.001519052">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme-manager.test.ts" timestamp="2025-10-02T21:38:22.707Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.028157269">
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should load valid custom themes" time="0.00396466">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get the active theme" time="0.001549489">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get a custom active theme" time="0.000971989">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return false when setting a non-existent theme" time="0.000682845">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should list available themes including custom themes" time="0.008966931">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should get a theme by name" time="0.001007586">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should fall back to default theme if active theme is invalid" time="0.000797576">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return NoColorTheme if NO_COLOR is set" time="0.000656476">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should load a theme from a valid file path" time="0.003870446">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme if the file does not exist" time="0.001920125">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from a file with invalid JSON" time="0.001102351">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from an untrusted file path and log a message" time="0.00111264">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme.test.ts" timestamp="2025-10-02T21:38:22.707Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.004113796">
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a valid theme" time="0.001439234">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with an invalid name" time="0.000227741">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a theme missing optional DiffAdded and DiffRemoved colors" time="0.000141171">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with a very long name" time="0.000118319">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="themeManager.loadCustomThemes &gt; should use values from DEFAULT_THEME when DiffAdded and DiffRemoved are not provided" time="0.000715094">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/atCommandProcessor.test.ts" timestamp="2025-10-02T21:38:22.708Z" hostname="uby" tests="39" failures="0" errors="0" skipped="0" time="1.26335506">
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through query if no @ command is present" time="0.02367986">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through original query if only a lone @ symbol is present" time="0.011491515">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid text file path" time="0.134774607">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid directory path and convert to glob" time="0.054375269">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle query with text before and after @command" time="0.045131545">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should correctly unescape paths with escaped spaces" time="0.082503604">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references" time="0.060078608">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references with interleaved text" time="0.080861544">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle a mix of valid, invalid, and lone @ references" time="0.092574158">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should return original query if all @paths are invalid or lone @" time="0.07804557">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should skip git-ignored files in @ commands" time="0.027133464">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-iWMrzO/node_modules/package.json

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should process non-git-ignored files normally" time="0.05697987">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should handle mixed git-ignored and valid files" time="0.014442448">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-6RSQt3/.env

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should always ignore .git directory files" time="0.003060326">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-GE644m/.git/config

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; when recursive file search is disabled &gt; should not use glob search for a nonexistent file" time="0.001637542">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; gemini-ignore filtering &gt; should skip gemini-ignored files in @ commands" time="0.002343378">
            <system-out>
Ignored 1 files:
Gemini-ignored: /tmp/folder-structure-test-BuIp1B/build/output.js

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process non-ignored files when .qwenignore is present" time="0.016175577">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle mixed gemini-ignored and valid files" time="0.011729595">
            <system-out>
Ignored 1 files:
Gemini-ignored: /tmp/folder-structure-test-d6tLbY/dist/bundle.js

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;comma&apos;" time="0.012465197">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;period&apos;" time="0.012809455">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;semicolon&apos;" time="0.026678652">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;exclamation mark&apos;" time="0.013770193">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;question mark&apos;" time="0.013348553">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening parenthesis&apos;" time="0.010046129">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing parenthesis&apos;" time="0.013075177">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening square bracket&apos;" time="0.011766774">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing square bracket&apos;" time="0.010501412">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening curly brace&apos;" time="0.009840048">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing curly brace&apos;" time="0.010706362">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle multiple @paths terminated by different punctuation" time="0.012044429">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should still handle escaped spaces in paths before punctuation" time="0.01941277">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not break file paths with periods in extensions" time="0.020231886">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle file paths ending with period followed by space" time="0.017100228">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle comma termination with complex file paths" time="0.021774392">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not terminate at period within file name" time="0.028953093">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle end of string termination for period and comma" time="0.032148308">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle files with special characters in names" time="0.079370935">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle basic file names without special characters" time="0.052824347">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should not add the user&apos;s turn to history, as that is the caller&apos;s responsibility" time="0.030494155">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/shellCommandProcessor.test.ts" timestamp="2025-10-02T21:38:22.709Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.128259505">
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should initiate command execution and set pending state" time="0.039494008">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle successful execution and update history correctly" time="0.016530053">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command failure and display error status" time="0.006356999">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should throttle pending UI updates for text streams" time="0.011989978">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should show binary progress messages correctly" time="0.00525592">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should not wrap the command on Windows" time="0.00356463">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command abort and display cancelled status" time="0.006256042">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle binary output result correctly" time="0.006294693">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle promise rejection and show an error" time="0.006527965">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle synchronous errors during execution and clean up resources" time="0.007360016">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should show a warning if the working directory changes" time="0.005149173">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should NOT show a warning if the directory does not change" time="0.009400334">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/slashCommandProcessor.test.ts" timestamp="2025-10-02T21:38:22.709Z" hostname="uby" tests="35" failures="0" errors="0" skipped="0" time="2.259904496">
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should initialize CommandService with all required loaders" time="0.082445968">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should call loadCommands and populate state after mounting" time="0.060602177">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should provide an immutable array of commands to consumers" time="0.057193677">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should override built-in commands with file-based commands of the same name" time="0.062776252">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display an error for an unknown command" time="0.007956481">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display help for a parent command invoked without a subcommand" time="0.058841837">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should correctly find and execute a nested subcommand" time="0.062360673">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the the input is not a command" time="0.005741079">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the command has an error" time="0.004627107">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should set isProcessing to true during execution and false afterwards" time="0.116236386">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: theme&quot; action" time="0.070083239">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: model&quot; action" time="0.059975816">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;load_history&quot; action" time="0.067958816">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should handle a &quot;quit&quot; action" time="0.063036844">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should call runExitCleanup when handling a &quot;quit&quot; action" time="0.057088431">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a file-based command" time="0.056555955">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a mcp-based command" time="0.057493812">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should set confirmation request when action returns confirm_shell_commands" time="0.109147481">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should do nothing if user cancels confirmation" time="0.191718981">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command with one-time allowlist on &quot;Proceed Once&quot;" time="0.120071015">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command and update session allowlist on &quot;Proceed Always&quot;" time="0.111668428">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should be case-sensitive" time="0.055423669">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should correctly match an altName" time="0.056869647">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle extra whitespace around the command" time="0.057133244">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle `?` as a command prefix" time="0.058767991">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should override mcp-based commands with file-based commands of the same name" time="0.061879802">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should prioritize a command with a primary name over a command with a matching alias" time="0.059103541">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should add an overridden command to the history" time="0.05757909">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Lifecycle &gt; should abort command loading when the hook unmounts" time="0.005216147">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a simple slash command" time="0.058604919">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs nothing for a bogus command" time="0.056389437">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs a failure event for a failed command" time="0.061104626">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a slash command with a subcommand" time="0.061599142">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log the command path when an alias is used" time="0.057402432">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should not log for unknown commands" time="0.058307047">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAtCompletion.test.ts" timestamp="2025-10-02T21:38:22.711Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="1.078573196">
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should perform a recursive search for an empty pattern" time="0.092707926">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should correctly filter the recursive list based on a pattern" time="0.056015695">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should append a trailing slash to directory paths in suggestions" time="0.058434884">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should be in a loading state during initial file system crawl" time="0.058974844">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should NOT show a loading indicator for subsequent searches that complete under 200ms" time="0.119228375">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should show a loading indicator and clear old suggestions for subsequent searches that take longer than 200ms" time="0.119845958">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should abort the previous search when a new one starts" time="0.159273192">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in a READY state" time="0.055806848">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in an ERROR state" time="0.055739553">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should respect .gitignore files" time="0.057326011">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should work correctly when config is undefined" time="0.064788847">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should reset and re-initialize when the cwd changes" time="0.118018574">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should perform a non-recursive search when enableRecursiveFileSearch is false" time="0.058844423">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAutoAcceptIndicator.test.ts" timestamp="2025-10-02T21:38:22.711Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.054625281">
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.AUTO_EDIT if config.getApprovalMode returns ApprovalMode.AUTO_EDIT" time="0.017051458">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.DEFAULT if config.getApprovalMode returns ApprovalMode.DEFAULT" time="0.003335755">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.YOLO if config.getApprovalMode returns ApprovalMode.YOLO" time="0.00358635">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.PLAN if config.getApprovalMode returns ApprovalMode.PLAN" time="0.003271827">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should cycle approval modes when Shift+Tab is pressed" time="0.009226271">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should not toggle if only one key or other keys combinations are pressed" time="0.003870907">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should update indicator when config value changes externally (useEffect dependency)" time="0.002768375">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from DEFAULT to AUTO_EDIT" time="0.003946296">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from AUTO_EDIT to YOLO" time="0.002810333">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should cycle from YOLO to PLAN when Shift+Tab is pressed" time="0.002798902">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useCommandCompletion.test.ts" timestamp="2025-10-02T21:38:22.711Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.114692186">
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.031716189">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when completion mode becomes IDLE" time="0.018350754">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset all state to default values" time="0.003206898">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should call useAtCompletion with the correct query for an escaped space" time="0.005963701">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should correctly identify the completion context with multiple @ symbols" time="0.004695514">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.001584012">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.001740783">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.004130317">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.004884122">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.005933074">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should automatically select the first item when suggestions are available" time="0.003545844">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a partial command" time="0.005980231">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path" time="0.008243362">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path when cursor is not at the end of the line" time="0.003261358">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for line comments" time="0.0035325">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for block comments" time="0.002054403">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should trigger prompt completion for regular text when enabled" time="0.002989504">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useConsoleMessages.test.ts" timestamp="2025-10-02T21:38:22.712Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.046599993">
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should initialize with an empty array of console messages" time="0.016656947">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should add a new message when log is called" time="0.006393356">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should batch and count identical consecutive messages" time="0.005268564">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should not batch different messages" time="0.00386742">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear all messages when clearConsoleMessages is called" time="0.006642868">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear the pending timeout when clearConsoleMessages is called" time="0.003809713">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clean up the timeout on unmount" time="0.00214991">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useEditorSettings.test.ts" timestamp="2025-10-02T21:38:22.712Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.036439823">
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should initialize with dialog closed" time="0.014181685">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should open editor dialog when openEditorDialog is called" time="0.002066967">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should close editor dialog when exitEditorDialog is called" time="0.001234786">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle editor selection successfully" time="0.004749353">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle clearing editor preference (undefined editor)" time="0.002826202">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different editor types" time="0.002705609">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different setting scopes" time="0.001872868">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for unavailable editors" time="0.001764336">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for editors not allowed in sandbox" time="0.001516528">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle errors during editor selection" time="0.001754579">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFocus.test.ts" timestamp="2025-10-02T21:38:22.712Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.037158444">
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should initialize with focus and enable focus reporting" time="0.018654907">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to false when a focus-out event is received" time="0.003740204">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to true when a focus-in event is received" time="0.002915077">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should clean up and disable focus reporting on unmount" time="0.001949239">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should handle multiple focus events correctly" time="0.007964676">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFolderTrust.test.ts" timestamp="2025-10-02T21:38:22.713Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.038878448">
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already trusted" time="0.01819743">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already untrusted" time="0.001764247">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should open dialog when folder trust is undefined" time="0.00155551">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_FOLDER choice" time="0.002389734">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_PARENT choice" time="0.002135514">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle DO_NOT_TRUST choice and trigger restart" time="0.002934853">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should do nothing for default choice" time="0.002672468">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should set isRestarting to true when trust status changes from false to true" time="0.002432273">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not set isRestarting to true when trust status does not change" time="0.002922731">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGeminiStream.test.tsx" timestamp="2025-10-02T21:38:22.713Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.834977699">
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not submit tool responses if not all tool calls are completed" time="0.039656229">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should submit tool responses when all tool calls are completed and ready" time="0.045080009">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should handle all tool calls being cancelled" time="0.024837193">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should group multiple cancelled tool call responses into a single history entry" time="0.015595613">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not flicker streaming state to Idle between tool completion and submission" time="0.009819559">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should cancel an in-progress stream when escape is pressed" time="0.020192133">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should call onCancelSubmit handler when escape is pressed" time="0.00503395">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not do anything if escape is pressed when not responding" time="0.022013865">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should prevent further processing after cancellation" time="0.070112995">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not cancel if a tool call is in progress (not just responding)" time="0.011895273">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should schedule a tool call when the command processor returns a schedule_tool action" time="0.015582859">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should stop processing and not call Gemini when a command is handled without a tool call" time="0.047322592">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should call Gemini with prompt content when slash command returns a `submit_prompt` action" time="0.043133145">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should correctly handle a submit_prompt action with empty content" time="0.014894014">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for line comments" time="0.013760235">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for block comments" time="0.005002642">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Memory Refresh on save_memory &gt; should call performMemoryRefresh when a save_memory tool call completes successfully" time="0.006715774">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Error Handling &gt; should call parseAndFormatApiError with the correct authType on stream initialization failure" time="0.012539946">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add info message for MAX_TOKENS finish reason" time="0.036934129">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for STOP finish reason" time="0.116944397">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for FINISH_REASON_UNSPECIFIED" time="0.114374209">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add appropriate messages for other finish reasons" time="0.036603736">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should process @include commands, adding user turn after processing to prevent race conditions" time="0.004111883">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when starting a new prompt" time="0.006813494">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when user cancels" time="0.005216408">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when there is an error" time="0.035194167">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should prevent concurrent submitQuery calls" time="0.01644736">
            <system-err>
You called act(async () =&gt; ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () =&gt; ...);

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should allow subsequent calls after first call completes" time="0.00425677">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should reset execution flag even when query preparation fails" time="0.004027867">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should call handleVisionSwitch and proceed to send when allowed" time="0.004797682">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should gate submission when handleVisionSwitch returns shouldProceed=false" time="0.007315904">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model after successful stream completion" time="0.007725994">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model when an error occurs during streaming" time="0.005428179">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGitBranchName.test.ts" timestamp="2025-10-02T21:38:22.714Z" hostname="uby" tests="7" failures="0" errors="0" skipped="2" time="0.049922585">
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return branch name" time="0.025373305">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if git command fails" time="0.006004998">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return short commit hash if branch is HEAD (detached state)" time="0.004438107">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if branch is HEAD and getting commit hash fails" time="0.00378132">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should update branch name when .git/HEAD changes" time="0.000813527">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should handle watcher setup error silently" time="0.006609797">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should cleanup watcher on unmount" time="0.000684918">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useHistoryManager.test.ts" timestamp="2025-10-02T21:38:22.714Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.036135379">
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should initialize with an empty history" time="0.015973132">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add an item to history with a unique ID" time="0.00433185">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should generate unique IDs for items added with the same base timestamp" time="0.00329503">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should update an existing history item" time="0.00253317">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not change history if updateHistoryItem is called with a nonexistent ID" time="0.00479087">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should clear the history" time="0.001304024">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not add consecutive duplicate user messages" time="0.001101209">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add duplicate user messages if they are not consecutive" time="0.000916647">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useInputHistory.test.ts" timestamp="2025-10-02T21:38:22.715Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.039917993">
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; should initialize with historyIndex -1 and empty originalQueryBeforeNav" time="0.014560176">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should call onSubmit with trimmed value and reset history" time="0.004261299">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should not call onSubmit if value is empty after trimming" time="0.003830622">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if isActive is false" time="0.002283647">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if userMessages is empty" time="0.002208399">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should call onChange with the last message when navigating up from initial state" time="0.002678589">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should store currentQuery as originalQueryBeforeNav on first navigateUp" time="0.001622324">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should navigate through history messages on subsequent navigateUp calls" time="0.001723461">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if isActive is false" time="0.002070683">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if historyIndex is -1 (not in history navigation)" time="0.00121496">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should restore originalQueryBeforeNav when navigating down to initial state" time="0.001331395">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useKeypress.test.ts" timestamp="2025-10-02T21:38:22.715Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.07102315">
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should not listen if isActive is false" time="0.023001524">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;a&apos;" time="0.005295274">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;left&apos;" time="0.003390808">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;right&apos;" time="0.002351142">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;up&apos;" time="0.002224839">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;down&apos;" time="0.001719624">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should set and release raw mode" time="0.00155">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should stop listening after being unmounted" time="0.001515746">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should correctly identify alt+enter (meta key)" time="0.001749108">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should process a paste as a single event" time="0.006102308">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should handle keypress interspersed with pastes" time="0.006820097">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.002558807">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should process a paste as a single event" time="0.003183604">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should handle keypress interspersed with pastes" time="0.005695695">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.001866817">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useLoadingIndicator.test.ts" timestamp="2025-10-02T21:38:22.715Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.047378996">
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should initialize with default values when Idle" time="0.018395797">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reflect values when Responding" time="0.010810754">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should show waiting phrase and retain elapsedTime when WaitingForConfirmation" time="0.008046557">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset elapsedTime and use a witty phrase when transitioning from WaitingForConfirmation to Responding" time="0.003314135">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset timer and phrase when streamingState changes from Responding to Idle" time="0.004182243">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useMessageQueue.test.ts" timestamp="2025-10-02T21:38:22.716Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.042394116">
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should initialize with empty queue" time="0.018270415">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should add messages to queue" time="0.003754471">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should filter out empty messages" time="0.002512782">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should clear queue" time="0.002546194">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should return queued messages as text with double newlines" time="0.002083487">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should auto-submit queued messages when transitioning to Idle" time="0.003649246">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when queue is empty" time="0.00229064">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when not transitioning to Idle" time="0.00218206">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should handle multiple state transitions correctly" time="0.003289309">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePhraseCycler.test.ts" timestamp="2025-10-02T21:38:22.716Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.040471026">
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should initialize with the first witty phrase when not active and not waiting" time="0.015736985">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should show &quot;Waiting for user confirmation...&quot; when isWaiting is true" time="0.003400135">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should not cycle phrases if isActive is false and not waiting" time="0.003732961">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should cycle through witty phrases when isActive is true and not waiting" time="0.003453363">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when isActive becomes true after being false (and not waiting)" time="0.008421711">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should clear phrase interval on unmount when active" time="0.00187955">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when transitioning from waiting to active" time="0.002223477">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePrivacySettings.test.ts" timestamp="2025-10-02T21:38:22.716Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.46595984">
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle LoggingContentGenerator wrapper correctly and not throw &quot;Oauth not being used&quot; error" time="0.108706377">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should work with direct CodeAssistServer (no wrapper)" time="0.05622831">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle paid tier users correctly" time="0.06900743">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when content generator is not a CodeAssistServer" time="0.063434772">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when CodeAssistServer has no projectId" time="0.032314346">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should update data collection opt-in setting" time="0.133492836">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useQwenAuth.test.ts" timestamp="2025-10-02T21:38:22.716Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.058301256">
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when not Qwen auth" time="0.014439412">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when Qwen auth but not authenticating" time="0.002070493">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set up event listeners when Qwen auth and authenticating" time="0.004590659">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle device auth event" time="0.002890521">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - success" time="0.00369992">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - error" time="0.00165277">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - polling" time="0.001460013">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - rate_limit" time="0.001291881">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event without message" time="0.005658075">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when auth type changes" time="0.002166">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when authentication stops" time="0.002588171">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners on unmount" time="0.001746584">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when switching from Qwen auth to another auth type" time="0.002664122">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when authentication stops" time="0.001846168">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle cancelQwenAuth function" time="0.001981869">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should maintain isQwenAuth flag correctly" time="0.00392676">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set isQwenAuthenticating to true when starting authentication with Qwen auth" time="0.001861677">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useReverseSearchCompletion.test.tsx" timestamp="2025-10-02T21:38:22.717Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.040048785">
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.019355414">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when reverseSearchActive becomes false" time="0.003562546">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.002079239">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.001829747">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.00240897">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.001554057">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.002083427">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with large suggestion lists and scrolling" time="0.002114515">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; filters history by buffer.text and sets showSuggestions" time="0.001230548">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; hides suggestions when there are no matches" time="0.001424387">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useShellHistory.test.ts" timestamp="2025-10-02T21:38:22.717Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.762254456">
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should initialize and read the history file from the correct path" time="0.089933662">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should handle a nonexistent history file gracefully" time="0.075422416">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should add a command and write to the history file" time="0.214304229">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should navigate history correctly with previous/next commands" time="0.085155155">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should not add empty or whitespace-only commands to history" time="0.067094458">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should truncate history to MAX_HISTORY_LENGTH (100)" time="0.115368712">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should move an existing command to the top when re-added" time="0.110593702">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useSlashCompletion.test.ts" timestamp="2025-10-02T21:38:22.717Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.066659611">
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest all top-level commands for the root slash" time="0.019905242">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should filter commands based on partial input" time="0.003769879">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest commands based on partial altNames" time="0.003356504">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should NOT provide suggestions for a perfectly typed command that is a leaf node" time="0.004705632">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.00370508">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.001536454">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for a fully typed command that has no sub-commands or argument completion" time="0.001642782">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for an unknown command" time="0.001896642">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest sub-commands for a parent command" time="0.002065905">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest all sub-commands when the query ends with the parent command and a space" time="0.003019861">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should filter sub-commands by prefix" time="0.001607036">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should provide no suggestions for an invalid sub-command" time="0.001832302">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call the command.completion function for argument suggestions" time="0.006155696">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call command.completion with an empty string when args start with a space" time="0.005438218">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should handle completion function that returns null" time="0.003852602">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useTimer.test.ts" timestamp="2025-10-02T21:38:22.718Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.041687488">
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should initialize with 0" time="0.015996425">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should not increment time if isActive is false" time="0.003095401">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should increment time every second if isActive is true" time="0.004288169">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 and start incrementing when isActive becomes true from false" time="0.003502875">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 when resetKey changes while active" time="0.00504485">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should be 0 if isActive is false, regardless of resetKey changes" time="0.002386608">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should clear timer on unmount" time="0.002740073">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should preserve elapsedTime when isActive becomes false, and reset to 0 when it becomes active again" time="0.002573624">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useToolScheduler.test.ts" timestamp="2025-10-02T21:38:22.718Z" hostname="uby" tests="21" failures="0" errors="0" skipped="4" time="0.152019974">
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler in YOLO Mode &gt; should skip confirmation and execute tool directly when yoloMode is true" time="0.083467819">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; initial state should be empty" time="0.004016286">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute a tool call successfully" time="0.015573292">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool not found" time="0.007744308">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during shouldConfirmExecute" time="0.011915009">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during execute" time="0.004778026">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - approved" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - cancelled by user" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle live output updates" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute multiple tool calls" time="0.00982488">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should throw error if scheduling while already running" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;validating&apos; (validating) correctly" time="0.000928619">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;awaiting_approval&apos; (awaiting_approval) correctly" time="0.000196925">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;scheduled&apos; (scheduled) correctly" time="0.000142704">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing no live output) correctly" time="0.000148104">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing with live output) correctly" time="0.000137325">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;success&apos; (success) correctly" time="0.000196503">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool not found) correctly" time="0.000214647">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool execution failed) correctly" time="0.000186405">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;cancelled&apos; (cancelled) correctly" time="0.000198818">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map an array of ToolCalls correctly" time="0.00144792">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useVisionAutoSwitch.test.ts" timestamp="2025-10-02T21:38:22.719Z" hostname="uby" tests="36" failures="0" errors="0" skipped="0" time="0.051137403">
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH" time="0.001180496">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when current model is already a vision model" time="0.000225327">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist, QWEN_OAUTH, and model is not vision" time="0.000204618">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; detects image when provided as a single Part object (non-array)" time="0.000152632">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts contain no images" time="0.000095647">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts is a plain string" time="0.000088684">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when visionModelPreviewEnabled is false" time="0.000080228">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist in YOLO mode context" time="0.000103422">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when no image parts exist in YOLO mode context" time="0.000113349">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when already using vision model in YOLO mode context" time="0.000079096">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH in YOLO mode context" time="0.000076562">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchOnce to a one-time model override" time="0.002381749">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchSessionToVL to a persistent session model" time="0.000128127">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps ContinueWithCurrentModel to empty result" time="0.00007528">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; getVisionSwitchGuidanceMessage &gt; returns the expected guidance message" time="0.000090297">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true immediately for continuations" time="0.01175933">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when authType is not QWEN_OAUTH" time="0.002349069">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when there are no image parts" time="0.001758396">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; continues with current model when dialog returns empty result" time="0.002934503">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; applies a one-time override and returns originalModel, then restores" time="0.002628656">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; persists session model when dialog requests persistence" time="0.001470443">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true when dialog returns no special flags" time="0.00116118">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; blocks when dialog throws or is cancelled" time="0.001137917">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when visionModelPreviewEnabled is false" time="0.001310506">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; automatically switches to vision model in YOLO mode without showing dialog" time="0.001533929">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when no images are present" time="0.001775657">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when already using vision model" time="0.001683887">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; restores original model after YOLO mode auto-switch" time="0.001453942">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when authType is not QWEN_OAUTH" time="0.001548818">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when visionModelPreviewEnabled is false" time="0.001448702">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; handles multiple image formats in YOLO mode" time="0.001340081">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should automatically switch once when vlmSwitchMode is &quot;once&quot;" time="0.001412284">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should switch session when vlmSwitchMode is &quot;session&quot;" time="0.001446568">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should continue with current model when vlmSwitchMode is &quot;persist&quot;" time="0.001251897">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to user prompt when vlmSwitchMode is not set" time="0.001219297">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to persist behavior when vlmSwitchMode has invalid value" time="0.001214458">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/vim.test.ts" timestamp="2025-10-02T21:38:22.720Z" hostname="uby" tests="87" failures="0" errors="0" skipped="0" time="0.909890548">
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should start in NORMAL mode" time="0.063572696">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch to INSERT mode with i command" time="0.019262802">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch back to NORMAL mode with Escape" time="0.009338869">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should properly handle escape followed immediately by a command" time="0.013548433">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle h (left movement)" time="0.008679599">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle l (right movement)" time="0.011136838">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle j (down movement)" time="0.007734179">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle k (up movement)" time="0.01498354">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle 0 (move to start of line)" time="0.010948319">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle $ (move to end of line)" time="0.014453168">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle a (append after cursor)" time="0.006122886">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle A (append at end of line)" time="0.009550602">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle o (open line below)" time="0.037060222">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle O (open line above)" time="0.003589776">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle x (delete character)" time="0.024686504">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should move cursor left when deleting last character on line (vim behavior)" time="0.017227495">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle first d key (sets pending state)" time="0.00693531">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should handle count input and return to count 0 after command" time="0.006267022">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should only delete 1 character with x command when no count is specified" time="0.019064906">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should properly initialize vim hook with word movement support" time="0.035236746">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should support vim mode and basic operations across multiple lines" time="0.007532746">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w (next word)" time="0.004983646">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle b (previous word)" time="0.007883235">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle e (end of word)" time="0.009043462">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w when cursor is on the last word" time="0.004093999">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle first c key (sets pending change state)" time="0.010945173">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state on invalid command sequence (df)" time="0.01983975">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state with Escape in NORMAL mode" time="0.007196443">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Disabled vim mode &gt; should not respond to vim commands when disabled" time="0.00960949">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat x command from current cursor position" time="0.018774088">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat dd command from current position" time="0.013993558">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat ce command from current position" time="0.01467569">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cc command from current position" time="0.028163841">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cw command from current position" time="0.032247872">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat D command from current position" time="0.007227731">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat C command from current position" time="0.009907402">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat command after cursor movement" time="0.004983126">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should move cursor to the correct position after exiting INSERT mode with &quot;a&quot;" time="0.005402952">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle ^ (move to first non-whitespace character)" time="0.005475006">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle G without count (go to last line)" time="0.004322152">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle gg (go to first line)" time="0.005742682">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle count with movement commands" time="0.005699231">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete from cursor to start of next word" time="0.007847618">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should actually delete the complete word including trailing space" time="0.009115226">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete word from middle of word correctly" time="0.00503413">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should handle dw at end of line" time="0.003579156">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete multiple words with count" time="0.006378399">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should record command for repeat with dot" time="0.008606735">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.004748041">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should handle count with de" time="0.005762178">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should change from cursor to start of next word and enter INSERT mode" time="0.005274205">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should handle count with cw" time="0.00674674">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should be repeatable with dot" time="0.010393312">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should change from cursor to end of word and enter INSERT mode" time="0.006659459">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should handle count with ce" time="0.007162982">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change entire line and enter INSERT mode" time="0.006411079">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change multiple lines with count" time="0.005801771">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should be repeatable with dot" time="0.012896056">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.030959938">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should handle count with db" time="0.008212625">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should change from cursor to start of previous word and enter INSERT mode" time="0.006241325">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should handle count with cb" time="0.008361079">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending delete state after dw" time="0.006967609">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending change state after cw" time="0.006316604">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending state with escape" time="0.007625778">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should pass escape through when no pending operator is active" time="0.00428358">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should handle escape and clear pending operator" time="0.005151136">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ctrl+r in INSERT mode" time="0.009109515">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ! in INSERT mode when buffer is empty" time="0.008894697">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should handle ! as input in INSERT mode when buffer is not empty" time="0.011847814">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.004290373">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete multiple word ends with count" time="0.004691886">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.003782212">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete multiple words backward with count" time="0.003327991">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should delete from cursor to start of next word" time="0.003131898">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should change multiple words with count" time="0.003127951">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change from cursor to end of current word" time="0.00239283">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change multiple word ends with count" time="0.00391082">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cb (change word backward) &gt; should change from cursor to start of previous word" time="0.004343501">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cc (change line) &gt; should clear the line and place cursor at the start" time="0.010018357">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete the current line" time="0.00904199">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete multiple lines with count" time="0.004318204">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should handle deleting last line" time="0.004086907">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should delete from cursor to end of line" time="0.003618068">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should handle D at end of line" time="0.015421962">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should change from cursor to end of line" time="0.00734596">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should handle C at beginning of line" time="0.00876083">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/MarkdownDisplay.test.tsx" timestamp="2025-10-02T21:38:22.723Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.286178671">
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders nothing for empty text" time="0.021833892">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a simple paragraph" time="0.009574877">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders headers with correct levels" time="0.006130721">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a fenced code block with a language" time="0.025053703">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a fenced code block without a language" time="0.119216323">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; handles unclosed (pending) code blocks" time="0.009063069">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders unordered lists with different markers" time="0.007683455">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders nested unordered lists" time="0.00757853">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders ordered lists" time="0.006988117">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders horizontal rules" time="0.003798292">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders tables correctly" time="0.008775156">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; handles a table at the end of the input" time="0.004744554">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; inserts a single space between paragraphs" time="0.004581422">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; correctly parses a mix of markdown elements" time="0.034728796">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; hides line numbers in code blocks when showLineNumbers is false" time="0.006257736">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; shows line numbers in code blocks by default" time="0.003628577">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; correctly splits lines using \n regardless of platform EOL" time="0.004000236">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/clipboardUtils.test.ts" timestamp="2025-10-02T21:38:22.723Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.007497099">
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return false on non-macOS platforms" time="0.0012479">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return boolean on macOS" time="0.000131984">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should return null on non-macOS platforms" time="0.00019482">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should handle errors gracefully" time="0.000380735">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should not throw errors" time="0.003534564">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should complete without errors on valid directory" time="0.000396935">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/commandUtils.test.ts" timestamp="2025-10-02T21:38:22.724Z" hostname="uby" tests="26" failures="0" errors="0" skipped="0" time="0.053743859">
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query starts with @" time="0.003655097">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query contains @ preceded by whitespace" time="0.000645365">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when query does not start with @ and has no spaced @" time="0.000371297">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when @ is not preceded by whitespace" time="0.00028583">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return true when query starts with /" time="0.000355849">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false when query does not start with /" time="0.000320774">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for line comments starting with //" time="0.000312568">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for block comments starting with /*" time="0.000230747">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should successfully copy text to clipboard using pbcopy" time="0.006064167">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle pbcopy command failure" time="0.005391121">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle spawn error" time="0.002081985">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle stdin write error" time="0.002227253">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Windows (win32) &gt; should successfully copy text to clipboard using clip" time="0.002092194">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should successfully copy text to clipboard using xclip" time="0.002205634">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should fall back to xsel when xclip fails" time="0.003362545">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should throw error when both xclip and xsel are not found" time="0.003382743">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should emit error when xclip or xsel fail with stderr output (command installed)" time="0.003350192">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on unsupported platform &gt; should throw error for unsupported platform" time="0.000576307">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle command exit without stderr" time="0.001657028">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle empty text" time="0.001601055">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle multiline text" time="0.001810051">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle special characters" time="0.005939246">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on macOS (darwin) &gt; should return open" time="0.000688906">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Windows (win32) &gt; should return start" time="0.000397065">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Linux (linux) &gt; should return xdg-open" time="0.000903021">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on unmatched OS &gt; should return xdg-open" time="0.00152349">
            <system-err>
Unknown platform: unmatched. Attempting to open URLs with: xdg-open.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/computeStats.test.ts" timestamp="2025-10-02T21:38:22.724Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.007798277">
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should return 0 if totalRequests is 0" time="0.001376368">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should calculate the error rate correctly" time="0.000447418">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should return 0 if totalRequests is 0" time="0.000193959">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should calculate the average latency correctly" time="0.000201783">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should return 0 if prompt tokens is 0" time="0.000144458">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should calculate the cache hit rate correctly" time="0.000131494">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should return all zeros for initial empty metrics" time="0.000935051">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate API and tool time percentages" time="0.000372921">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate cache efficiency" time="0.000970556">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate success and agreement rates" time="0.00017278">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should handle division by zero gracefully" time="0.000481772">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly include line counts" time="0.000352062">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/displayUtils.test.ts" timestamp="2025-10-02T21:38:22.725Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.003213028">
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return green for values &gt;= green threshold" time="0.001441939">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return yellow for values &lt; green and &gt;= yellow threshold" time="0.00018385">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return red for values &lt; yellow threshold" time="0.000125733">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return defaultColor for values &lt; yellow threshold when provided" time="0.000103171">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; Threshold Constants &gt; should have the correct values" time="0.000234554">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/formatters.test.ts" timestamp="2025-10-02T21:38:22.725Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.003522341">
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into KB" time="0.001206824">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into MB" time="0.00014009">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into GB" time="0.000080519">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format milliseconds less than a second" time="0.000174423">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration of 0" time="0.000072284">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of seconds" time="0.000067255">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in seconds with one decimal place" time="0.000060121">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of minutes" time="0.000066764">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in minutes and seconds" time="0.000083946">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of hours" time="0.000063036">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours and seconds" time="0.00006441">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours, minutes, and seconds" time="0.000058689">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle large durations" time="0.000061253">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle negative durations" time="0.000056825">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/markdownUtilities.test.ts" timestamp="2025-10-02T21:38:22.725Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.003050328">
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should split at the last double newline if not in a code block" time="0.001321697">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if no safe split point is found" time="0.000172579">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should prioritize splitting at 

 over being at the very end of the string if the end is not in a code block" time="0.000091118">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if the only 

 is inside a code block and the end of content is not" time="0.000078425">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should correctly identify the last 

 even if it is followed by text not in a code block" time="0.000074668">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content is empty" time="0.000060512">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content has no newlines and no code blocks" time="0.000074007">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/updateCheck.test.ts" timestamp="2025-10-02T21:38:22.726Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.012475686">
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null when running from source (DEV=true)" time="0.00400229">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if package.json is missing" time="0.000665903">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if there is no update" time="0.000496379">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return a message if a newer version is available" time="0.001761522">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is the same as the current version" time="0.000497631">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is older than the current version" time="0.000595232">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if fetchInfo rejects" time="0.001504124">
            <system-err>
Failed to check for updates: Error: Timeout

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should handle errors gracefully" time="0.000488404">
            <system-err>
Failed to check for updates: Error: test error

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; nightly updates &gt; should notify for a newer nightly version when current is nightly" time="0.001051737">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/MaxSizedBox.test.tsx" timestamp="2025-10-02T21:38:22.726Z" hostname="uby" tests="21" failures="0" errors="0" skipped="0" time="0.093070698">
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders children without truncation when they fit" time="0.042824454">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines when content exceeds maxHeight" time="0.003760802">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines at the end when content exceeds maxHeight and overflowDirection is bottom" time="0.00200931">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text that exceeds maxWidth" time="0.003521279">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles mixed wrapping and non-wrapping segments" time="0.007413055">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles words longer than maxWidth by splitting them" time="0.003605124">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; does not truncate when maxHeight is undefined" time="0.001328259">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden" time="0.001646318">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden and overflowDirection is bottom" time="0.001550741">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders an empty box for empty children" time="0.000765087">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte unicode characters correctly" time="0.001804671">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte emoji characters correctly" time="0.001411433">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; falls back to an ellipsis when width is extremely small" time="0.001293825">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates long non-wrapping text with ellipsis" time="0.001110707">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates non-wrapping text containing line breaks" time="0.001102752">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates emoji characters correctly with ellipsis" time="0.000897371">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows ellipsis for multiple rows with long non-wrapping text" time="0.001419257">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; accounts for additionalHiddenLinesCount" time="0.001305597">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles React.Fragment as a child" time="0.00238212">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the top" time="0.004382123">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the bottom" time="0.004716021">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/RadioButtonSelect.test.tsx" timestamp="2025-10-02T21:38:22.727Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.328030313">
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list of items and matches snapshot" time="0.037883717">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with the second item selected and matches snapshot" time="0.006620086">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with numbers hidden and matches snapshot" time="0.003258233">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with scroll arrows and matches snapshot" time="0.004302786">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with special theme display and matches snapshot" time="0.003115718">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list with &gt;10 items and matches snapshot" time="0.007899625">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders nothing when no items are provided" time="0.004856021">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; should call onSelect when &quot;enter&quot; is pressed" time="0.011328934">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; when isFocused is false &gt; should not handle any keyboard input" time="0.00776168">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate down with arrow key and select with enter" time="0.060092453">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate up with arrow key and select with enter" time="0.06012875">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate down with arrow key and select with enter" time="0.058668126">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate up with arrow key and select with enter" time="0.05962622">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/text-buffer.test.ts" timestamp="2025-10-02T21:38:22.727Z" hostname="uby" tests="103" failures="0" errors="0" skipped="0" time="0.599032939">
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; should return the initial state if state is undefined" time="0.016400583">
            <system-err>
Unknown action encountered: [object Object]

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should set new text and move cursor to the end" time="0.002078909">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should not create an undo snapshot if pushToUndo is false" time="0.000350058">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a character" time="0.001112871">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a newline" time="0.000294786">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should remove a character" time="0.000263137">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should join lines if at the beginning of a line" time="0.000644714">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; undo/redo actions &gt; should undo and redo a change" time="0.003596789">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; create_undo_snapshot action &gt; should create a snapshot without changing state" time="0.000310876">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with empty text and cursor at (0,0) by default" time="0.043693503">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with provided initialText" time="0.019367636">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with initialText and initialCursorOffset" time="0.01188325">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines" time="0.021170334">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines with multiple spaces" time="0.011565592">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines even without spaces" time="0.009913484">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with multi-byte unicode characters and correct cursor offset" time="0.024839907">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert a character and update cursor" time="0.011471618">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert text in the middle of a line" time="0.014444051">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; newline: should create a new line and move cursor" time="0.010018478">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; backspace: should delete char to the left or merge lines" time="0.021229113">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; del: should delete char to the right or merge lines" time="0.011354672">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should prepend @ to a valid file path on insert" time="0.005413703">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to an invalid file path on insert" time="0.006613033">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should handle quoted paths" time="0.003684431">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to short text that is not a path" time="0.006204237">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to valid file paths when shellModeActive is true" time="0.005146789">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to quoted paths when shellModeActive is true" time="0.009945713">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with invalid paths when shellModeActive is true" time="0.004396429">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with short text when shellModeActive is true" time="0.002940423">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: left/right should work within and across visual lines (due to wrapping)" time="0.030404981">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: up/down should preserve preferred visual column" time="0.046367242">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: home/end should go to visual line start/end" time="0.013896668">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should wrap long lines correctly into visualLines" time="0.007180834">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should update visualScrollRow when visualCursor moves out of viewport" time="0.014237729">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo an insert operation" time="0.00453743">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo a newline operation" time="0.025916591">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; insert: should correctly handle multi-byte unicode characters" time="0.018455187">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; backspace: should correctly delete multi-byte unicode characters" time="0.005507827">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; move: left/right should treat multi-byte chars as single units for visual cursor" time="0.005322594">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should insert printable characters" time="0.016590284">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Enter&quot; key as newline" time="0.003603241">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Backspace&quot; key" time="0.011501694">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle multiple delete characters in one input" time="0.016140732">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts that contain delete characters" time="0.00577961">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts with a mix of regular and delete characters" time="0.003325006">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle arrow keys for movement" time="0.003902465">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should strip ANSI escape codes when pasting text" time="0.002664653">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle VSCode terminal Shift+Enter as newline" time="0.002339632">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should correctly handle repeated pasting of long text" time="0.03351002">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with single-line text" time="0.00254388">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a multi-line range with single-line text" time="0.002397458">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should delete a range when replacing with an empty string" time="0.001822324">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the beginning of the text" time="0.002533281">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the end of the text" time="0.002644716">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing the entire buffer content" time="0.002061256">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should correctly replace with unicode characters" time="0.002765069">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle invalid range by returning false and not changing text" time="0.00236605">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; replaceRange: multiple lines with a single character" time="0.001854603">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with multi-line text" time="0.001641258">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip ANSI escape codes from input" time="0.001565829">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip control characters from input" time="0.001534151">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip mixed ANSI and control characters from input" time="0.001575847">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip standard characters or newlines" time="0.001901581">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should sanitize pasted text via handleInput" time="0.001585335">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip popular emojis" time="0.001775548">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should correctly strip ANSI escape codes" time="0.000177528">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle multiple ANSI codes" time="0.0000757">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should not modify text without ANSI codes" time="0.000072254">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle empty string" time="0.000056034">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should return [0,0] for offset 0" time="0.000099474">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle single line text" time="0.000212784">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-line text" time="0.000278506">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty lines" time="0.000139168">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text ending with a newline" time="0.000109092">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text starting with a newline" time="0.000117217">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty string input" time="0.000074177">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-byte unicode characters correctly" time="0.000193428">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset exactly at newline character" time="0.000084887">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset in the middle of a multi-byte character (should place at start of that char)" time="0.000091699">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should convert row/col position to offset correctly" time="0.000371418">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle empty lines" time="0.000131333">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle single empty line" time="0.000047448">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should be inverse of offsetToLogicalPos" time="0.000294005">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle out-of-bounds positions" time="0.000085719">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete a single line including newline in multi-line text" time="0.000981858">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete multiple lines when count &gt; 1" time="0.00038377">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should clear single line content when only one line exists" time="0.000165306">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting the last line properly" time="0.000153454">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting all lines and maintain valid state for subsequent paste" time="0.000273286">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle combining characters" time="0.001618366">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000127286">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should return null when no word end found" time="0.000322738">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle right-to-left text" time="0.000204238">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle Chinese characters" time="0.000409298">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should return null at end of line" time="0.000065431">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle combining characters" time="0.000184472">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000061574">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for ASCII word characters" time="0.000106136">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for punctuation" time="0.000073917">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for non-Latin scripts" time="0.000071993">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for whitespace" time="0.000055553">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle combining characters" time="0.000392838">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle Chinese and Arabic text" time="0.000229786">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/vim-buffer-actions.test.ts" timestamp="2025-10-02T21:38:22.731Z" hostname="uby" tests="74" failures="0" errors="0" skipped="0" time="0.021331652">
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should move cursor left by count" time="0.002413368">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should not move past beginning of line" time="0.000237119">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should wrap to previous line when at beginning" time="0.000135932">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should handle multiple line wrapping" time="0.000078836">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should correctly handle h/l movement between lines" time="0.000161719">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should move cursor right by count" time="0.000667907">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should not move past last character of line" time="0.000176828">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should wrap to next line when at end" time="0.000113501">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should skip over combining marks to avoid cursor disappearing" time="0.000266323">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should move cursor up by count" time="0.000126364">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should not move past first line" time="0.000084106">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should adjust column for shorter lines" time="0.000089586">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should move cursor down by count" time="0.000098732">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should not move past last line" time="0.000074778">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move to start of next word" time="0.001742346">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle multiple words" time="0.000140671">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle punctuation correctly" time="0.000091519">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move across empty lines when starting from within a word" time="0.000106217">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should move to start of previous word" time="0.000284387">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should handle multiple words" time="0.000128217">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of current word" time="0.000316055">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of next word if already at word end" time="0.000139047">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move across empty lines when at word end" time="0.000106527">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle consecutive word-end movements across empty lines" time="0.000172118">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle combining characters - advance from end of base character" time="0.000369053">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle precomposed characters with diacritics" time="0.000230357">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_start should move to column 0" time="0.000189481">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_end should move to last character" time="0.000116025">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_nonwhitespace should skip leading whitespace" time="0.000116125">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_line should move to row 0" time="0.000089195">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_last_line should move to last row" time="0.000089225">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should move to specific line" time="0.000097491">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should clamp to valid range" time="0.000069098">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete single character" time="0.00053487">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete multiple characters" time="0.000146001">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should not delete past end of line" time="0.000101618">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should do nothing at end of line" time="0.000087161">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete from cursor to next word start" time="0.000288173">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete multiple words" time="0.00012966">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete to end if no more words" time="0.000120594">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete from cursor to previous word start" time="0.000100446">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete multiple words backward" time="0.000094665">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete current line" time="0.000700697">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete multiple lines" time="0.000147253">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should leave empty line when deleting all lines" time="0.000108622">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should delete from cursor to end of line" time="0.000582499">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should do nothing at end of line" time="0.00019403">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_cursor &gt; should not change cursor position" time="0.000165397">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should move cursor right by one" time="0.00029673">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should not move past end of line" time="0.00017276">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_line_end &gt; should move cursor to end of line" time="0.000080629">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to first non-whitespace character" time="0.00005923">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to column 0 for line with only whitespace" time="0.000045204">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_below &gt; should insert a new line below the current one" time="0.000120593">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_above &gt; should insert a new line above the current one" time="0.000185143">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should move cursor left" time="0.000080208">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should not move past beginning of line" time="0.0000482">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_word_forward &gt; should delete from cursor to next word start" time="0.000369284">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_line &gt; should delete entire line content" time="0.000349086">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the left" time="0.000195452">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the right" time="0.000127847">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change multiple lines down" time="0.000155448">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty text" time="0.000109543">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle single character line" time="0.000082333">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty lines in multi-line text" time="0.000094204">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should preserve undo stack in operations" time="0.000918851">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Right-to-left text handling &gt; should handle Arabic text in word movements" time="0.000576026">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Chinese character handling &gt; should handle Chinese characters in word movements" time="0.000145619">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word end commands" time="0.000120723">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word forward commands" time="0.000119812">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word backward commands" time="0.000117117">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle Unicode block characters consistently with w and e commands" time="0.000273376">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Chinese characters" time="0.000208215">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Arabic characters" time="0.0001787">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/DiffRenderer.test.tsx" timestamp="2025-10-02T21:38:22.734Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.357917771">
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with correct language for new file with known extension" time="0.03583265">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file with unknown extension" time="0.150056662">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file if no filename is provided" time="0.016702984">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render diff content for existing file (not calling colorizeCode directly for the whole block)" time="0.010127219">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle diff with only header and no changes" time="0.006120732">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle empty diff content" time="0.002548438">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render a gap indicator for skipped lines" time="0.018626555">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should not render a gap indicator for small gaps (&lt;= MAX_CONTEXT_LINES_WITHOUT_GAP)" time="0.014430646">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height undefined" time="0.019558791">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height 6" time="0.014441406">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 30 and height 6" time="0.019456782">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with a SVN diff format" time="0.033063123">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a new file with no file extension correctly" time="0.01424909">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolConfirmationMessage.test.tsx" timestamp="2025-10-02T21:38:22.735Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.538580049">
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should not display urls if prompt and url are the same" time="0.194557356">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should display urls if prompt and url are different" time="0.019378967">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should render plan confirmation with markdown plan content" time="0.029975666">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.047849297">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.041857494">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.030509223">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.019589848">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.017785558">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.029389481">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.0204282">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.044541121">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.007161358">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.007685168">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.010012657">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.011609945">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolGroupMessage.test.tsx" timestamp="2025-10-02T21:38:22.736Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.162132158">
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders single successful tool call" time="0.05831835">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders multiple tool calls with different statuses" time="0.010962897">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders tool call awaiting confirmation" time="0.010945855">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders shell command with yellow border" time="0.004718797">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders mixed tool calls including shell command" time="0.006879767">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with limited terminal height" time="0.005866462">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders when not focused" time="0.003493337">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with narrow terminal width" time="0.029618696">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders empty tool calls array" time="0.003830592">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border when tools are pending" time="0.003416375">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border for shell commands even when successful" time="0.006008925">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses gray border when all tools are successful and no shell commands" time="0.00423496">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Height Calculation &gt; calculates available height correctly with multiple tools with results" time="0.005053967">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Confirmation Handling &gt; shows confirmation dialog for first confirming tool only" time="0.006120631">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolMessage.test.tsx" timestamp="2025-10-02T21:38:22.736Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.051538146">
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders basic tool information" time="0.021925282">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows  for Success status" time="0.002848694">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows o for Pending status" time="0.001916338">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows ? for Confirming status" time="0.002256678">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows - for Canceled status" time="0.002186298">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows x for Error status" time="0.002267668">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is Idle" time="0.002011665">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is WaitingForConfirmation" time="0.002370118">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows MockRespondingSpinner for Executing status when streamingState is Responding" time="0.002150511">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders DiffRenderer for diff results" time="0.002472267">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders emphasis correctly" time="0.004348661">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; shows subagent execution display for task tool with proper result display" time="0.002516999">
        </testcase>
    </testsuite>
</testsuites>
