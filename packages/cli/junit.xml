<?xml version="1.0" encoding="UTF-8" ?>
<testsuites name="vitest tests" tests="1784" failures="139" errors="0" time="34.300882833">
    <testsuite name="src/gemini.test.tsx" timestamp="2025-10-17T11:01:41.432Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/gemini.test.tsx" name="src/gemini.test.tsx" time="0">
            <failure message="[vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock" type="Error">
Error: [vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock
 ❯ src/config/auth.ts:8:1

Caused by: Caused by: Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/gemini.test.tsx:30:18
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/nonInteractiveCli.test.ts" timestamp="2025-10-17T11:01:41.434Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.02279679">
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should process input and write text output" time="0.00617415">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle a single tool call and respond" time="0.003043364">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle error during tool execution and should send error back to the model" time="0.001789447">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit with error if sendMessageStream throws initially" time="0.001648296">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should not exit if a tool is not found, and should send error back to model" time="0.004060765">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit when max session turns are exceeded" time="0.002244989">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should preprocess @include commands before sending to the model" time="0.002050209">
        </testcase>
    </testsuite>
    <testsuite name="src/validateNonInterActiveAuth.test.ts" timestamp="2025-10-17T11:01:41.434Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="src/validateNonInterActiveAuth.test.ts" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/validateNonInterActiveAuth.ts:8:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp.test.ts" timestamp="2025-10-17T11:01:41.434Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/commands/mcp.test.ts" name="src/commands/mcp.test.ts" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/commands/mcp/add.ts:9:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/config/auth.test.ts" timestamp="2025-10-17T11:01:41.435Z" hostname="uby" tests="11" failures="7" errors="0" skipped="0" time="0.032222429">
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for LOGIN_WITH_GOOGLE" time="0.008953346">
            <failure message="expected &apos;Invalid auth method selected.&apos; to be null" type="AssertionError">
AssertionError: expected &apos;Invalid auth method selected.&apos; to be null

- Expected: 
null

+ Received: 
&quot;Invalid auth method selected.&quot;

 ❯ src/config/auth.test.ts:28:60
            </failure>
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for CLOUD_SHELL" time="0.001411689">
            <failure message="expected &apos;Invalid auth method selected.&apos; to be null" type="AssertionError">
AssertionError: expected &apos;Invalid auth method selected.&apos; to be null

- Expected: 
null

+ Received: 
&quot;Invalid auth method selected.&quot;

 ❯ src/config/auth.test.ts:32:54
            </failure>
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return null if GEMINI_API_KEY is set" time="0.000763922">
            <failure message="expected &apos;Invalid auth method selected.&apos; to be null" type="AssertionError">
AssertionError: expected &apos;Invalid auth method selected.&apos; to be null

- Expected: 
null

+ Received: 
&quot;Invalid auth method selected.&quot;

 ❯ src/config/auth.test.ts:38:55
            </failure>
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return an error message if GEMINI_API_KEY is not set" time="0.009189002">
            <failure message="expected &apos;Invalid auth method selected.&apos; to be &apos;GEMINI_API_KEY environment variable n…&apos; // Object.is equality" type="AssertionError">
AssertionError: expected &apos;Invalid auth method selected.&apos; to be &apos;GEMINI_API_KEY environment variable n…&apos; // Object.is equality

Expected: &quot;GEMINI_API_KEY environment variable not found. Add that to your environment and try again (no reload needed if using .env)!&quot;
Received: &quot;Invalid auth method selected.&quot;

 ❯ src/config/auth.test.ts:42:55
            </failure>
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION are set" time="0.001033761">
            <failure message="expected &apos;Invalid auth method selected.&apos; to be null" type="AssertionError">
AssertionError: expected &apos;Invalid auth method selected.&apos; to be null

- Expected: 
null

+ Received: 
&quot;Invalid auth method selected.&quot;

 ❯ src/config/auth.test.ts:52:58
            </failure>
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_API_KEY is set" time="0.001135078">
            <failure message="expected &apos;Invalid auth method selected.&apos; to be null" type="AssertionError">
AssertionError: expected &apos;Invalid auth method selected.&apos; to be null

- Expected: 
null

+ Received: 
&quot;Invalid auth method selected.&quot;

 ❯ src/config/auth.test.ts:57:58
            </failure>
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return an error message if no required environment variables are set" time="0.004238884">
            <failure message="expected &apos;Invalid auth method selected.&apos; to be &apos;When using Vertex AI, you must specif…&apos; // Object.is equality" type="AssertionError">
AssertionError: expected &apos;Invalid auth method selected.&apos; to be &apos;When using Vertex AI, you must specif…&apos; // Object.is equality

- Expected
+ Received

- When using Vertex AI, you must specify either:
- • GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION environment variables.
- • GOOGLE_API_KEY environment variable (if using express mode).
- Update your environment and try again (no reload needed if using .env)!
+ Invalid auth method selected.

 ❯ src/config/auth.test.ts:61:58
            </failure>
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return an error message for an invalid auth method" time="0.000725831">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; OpenAI-compatible providers &gt; normalizes openrouter to USE_OPENAI" time="0.00047635">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; OpenAI-compatible providers &gt; requires OPENAI_API_KEY for openrouter" time="0.000360476">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; OpenAI-compatible providers &gt; accepts lmstudio when OPENAI_API_KEY is set" time="0.000176406">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.integration.test.ts" timestamp="2025-10-17T11:01:41.436Z" hostname="uby" tests="19" failures="0" errors="0" skipped="0" time="0.709230032">
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load default file filtering settings" time="0.033522942">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load custom file filtering settings from configuration" time="0.001544114">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should merge user and workspace file filtering settings" time="0.001501875">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle partial configuration objects gracefully" time="0.000900494">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle empty configuration objects gracefully" time="0.000820547">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle missing configuration sections gracefully" time="0.001174661">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a security-focused configuration" time="0.000796251">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a CI/CD environment configuration" time="0.000968761">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Checkpointing Configuration &gt; should enable checkpointing when the setting is true" time="0.001627407">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should have an empty array for extension context files by default" time="0.001483241">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should correctly store and return extension context file paths" time="0.001005959">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=auto-edit correctly through the full argument parsing flow" time="0.589808915">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=plan correctly through the full argument parsing flow" time="0.006806168">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=yolo correctly through the full argument parsing flow" time="0.005445824">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=default correctly through the full argument parsing flow" time="0.006288942">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse legacy --yolo flag correctly" time="0.004530844">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject invalid approval mode values during argument parsing" time="0.0220068">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Invalid values:
  Argument: approval-mode, Given: &quot;invalid_mode&quot;, Choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject conflicting --yolo and --approval-mode flags" time="0.018471216">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Cannot use both --yolo (-y) and --approval-mode together. Use --approval-mode=yolo instead.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should handle backward compatibility with mixed scenarios" time="0.005147292">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.test.ts" timestamp="2025-10-17T11:01:41.437Z" hostname="uby" tests="125" failures="0" errors="0" skipped="1" time="0.540511012">
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --prompt and --prompt-interactive are used together" time="0.042482059">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -p and -i together" time="0.017587051">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt without --prompt-interactive" time="0.005363402">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt-interactive without --prompt" time="0.005447748">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow -i flag as alias for --prompt-interactive" time="0.003994662">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --yolo and --approval-mode are used together" time="0.019282014">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -y and --approval-mode together" time="0.014409089">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --approval-mode without --yolo" time="0.004405452">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --yolo without --approval-mode" time="0.003338439">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should reject invalid --approval-mode values" time="0.014185967">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to true when --show-memory-usage flag is present" time="0.028519485">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false when --memory flag is not present" time="0.003573664">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false by default from settings if CLI flag is not present" time="0.002621304">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should prioritize CLI flag over settings for showMemoryUsage (CLI true, settings false)" time="0.002186711">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should leave proxy to empty by default" time="0.002067811">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [https_proxy]" time="0.002015926">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [http_proxy]" time="0.001713236">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTPS_PROXY]" time="0.001843376">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTP_PROXY]" time="0.001913737">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy when --proxy flag is present" time="0.002785328">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should prioritize CLI flag over environment variable for proxy (CLI http://localhost:7890, environment variable http://localhost:7891)" time="0.002755783">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false by default when no flag or setting is present" time="0.00281921">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to true when --telemetry flag is present" time="0.012897455">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false when --no-telemetry flag is present" time="0.002570981">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings true)" time="0.002908004">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings false)" time="0.002585238">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry CLI flag (true) over settings (false)" time="0.002375451">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry CLI flag (false) over settings (true)" time="0.002572224">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP endpoint from settings if CLI flag is not present" time="0.002851921">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-endpoint CLI flag over settings" time="0.002278671">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default endpoint if no OTLP endpoint is provided via CLI or settings" time="0.003482305">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry target from settings if CLI flag is not present" time="0.003264643">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-target CLI flag over settings" time="0.002723553">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default target if no target is provided via CLI or settings" time="0.002510439">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry log prompts from settings if CLI flag is not present" time="0.002616666">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-log-prompts CLI flag (true) over settings (false)" time="0.002383255">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry-log-prompts CLI flag (false) over settings (true)" time="0.002671627">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default log prompts (true) if no value is provided via CLI or settings" time="0.002252954">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP protocol from settings if CLI flag is not present" time="0.01113076">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-protocol CLI flag over settings" time="0.005230246">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default protocol if no OTLP protocol is provided via CLI or settings" time="0.005921844">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should reject invalid --telemetry-otlp-protocol values" time="0.011551057">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should pass extension context file paths to loadServerHierarchicalMemory" time="0.004447739">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should correctly use mocked homedir for global path" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeMcpServers &gt; should not modify the original settings object" time="0.003677907">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use default systemPromptMappings when not provided in settings" time="0.000825485">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use custom systemPromptMappings when provided in settings" time="0.000539467">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should merge excludeTools from settings and extensions" time="0.003567614">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between settings and extensions" time="0.003564047">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between extensions" time="0.003261998">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return an empty array when no excludeTools are specified and it is interactive" time="0.002932379">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return default excludes when no excludeTools are specified and it is not interactive" time="0.003020281">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle settings with excludeTools but no extensions" time="0.003288226">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle extensions with excludeTools but no settings" time="0.003227555">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should not modify the original settings object" time="0.00444253">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with default approval mode" time="0.003411103">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with plan approval mode" time="0.003120226">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with explicit default approval mode" time="0.002400997">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude only shell tools in non-interactive mode with auto-edit approval mode" time="0.002667991">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with yolo approval mode" time="0.002792761">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with legacy yolo flag" time="0.002625743">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should not exclude interactive tools in interactive mode regardless of approval mode" time="0.012821565">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should merge approval mode exclusions with settings exclusions in auto-edit mode" time="0.002845389">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should throw an error for invalid approval mode values in loadCliConfig" time="0.000485087">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow all MCP servers if the flag is not provided" time="0.002399264">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow only the specified MCP server" time="0.003186809">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow multiple specified MCP servers" time="0.003909054">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should handle server names that do not exist" time="0.002950673">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow no MCP servers if the flag is provided but empty" time="0.002859074">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read allowMCPServers from settings" time="0.002888538">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read excludeMCPServers from settings" time="0.002671948">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should override allowMCPServers with excludeMCPServers if overlapping" time="0.002214453">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize mcp server flag if set" time="0.002556335">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize CLI flag over both allowed and excluded settings" time="0.002850849">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should not filter extensions if --extensions flag is not used" time="0.002501643">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should filter extensions if --extensions flag is used" time="0.003259894">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects a model from settings.json if provided" time="0.002749852">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; uses the default gemini model if nothing is set" time="0.002751956">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; always prefers model from argvs" time="0.002714977">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects the model from argvs if provided" time="0.004336284">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be false by default" time="0.003267729">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be true when settings.folderTrustFeature is true" time="0.002888699">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is false" time="0.002035823">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is true and folderTrust is false" time="0.002879792">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is true" time="0.003402909">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be true when folderTrustFeature is true and folderTrust is true" time="0.003392891">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with includeDirectories &gt; should combine and resolve paths from settings and CLI arguments" time="0.004858358">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should pass chatCompression settings to the core config" time="0.004715264">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should have undefined chatCompression if not in settings" time="0.004080481">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false by default when useRipgrep is not set in settings" time="0.003518783">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be true when useRipgrep is set to true in settings" time="0.003389354">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false when useRipgrep is explicitly set to false in settings" time="0.003806865">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode without YOLO" time="0.005904492">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode with YOLO" time="0.003836841">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should exclude interactive tools in non-interactive mode without YOLO" time="0.003782571">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in non-interactive mode with YOLO" time="0.004392056">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if isTTY and no prompt" time="0.004251086">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if prompt-interactive is set" time="0.003289399">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if not isTTY and no prompt" time="0.002320409">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if prompt is set" time="0.002839558">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should default to DEFAULT approval mode when no flags are set" time="0.00292185">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set PLAN approval mode when --approval-mode=plan" time="0.003125436">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --yolo flag is used" time="0.002976741">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when -y flag is used" time="0.003189855">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set DEFAULT approval mode when --approval-mode=default" time="0.002813549">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set AUTO_EDIT approval mode when --approval-mode=auto-edit" time="0.002498437">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --approval-mode=yolo" time="0.002469885">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should use approval mode from settings when CLI flags are not provided" time="0.002525497">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should normalize approval mode values from settings" time="0.002711862">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should throw when approval mode in settings is invalid" time="0.002403402">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should prioritize --approval-mode over --yolo when both would be valid (but validation prevents this)" time="0.002682317">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should fall back to --yolo behavior when --approval-mode is not set" time="0.00268929">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=yolo to DEFAULT" time="0.004727157">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=auto-edit to DEFAULT" time="0.002733662">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --yolo flag to DEFAULT" time="0.002720247">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should remain DEFAULT when --approval-mode=default" time="0.002578215">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should allow PLAN approval mode in untrusted folders" time="0.002178305">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace trusted -&gt; behave as trusted" time="0.002750463">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace not trusted -&gt; behave as trusted" time="0.002338401">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.00161764">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.001702937">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace not trusted -&gt; behave as trusted" time="0.002299649">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trusted -&gt; is trusted" time="0.002157166">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace NOT trusted -&gt; is NOT trusted" time="0.001858154">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trust unknown -&gt; is unknown" time="0.001973427">
        </testcase>
    </testsuite>
    <testsuite name="src/config/extension.test.ts" timestamp="2025-10-17T11:01:41.440Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/config/extension.test.ts" name="src/config/extension.test.ts" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/config/extension.ts:16:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/config/keyBindings.test.ts" timestamp="2025-10-17T11:01:41.441Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.007281877">
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have bindings for all commands" time="0.003136436">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have valid key binding structures" time="0.0020774">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should export all required types" time="0.000201272">
        </testcase>
    </testsuite>
    <testsuite name="src/config/settings.test.ts" timestamp="2025-10-17T11:01:41.441Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/config/settings.test.ts" name="src/config/settings.test.ts" time="0">
            <failure message="[vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock" type="Error">
Error: [vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock
 ❯ src/config/settings.test.ts:53:1

Caused by: Caused by: Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/config/settings.test.ts:23:26
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/config/settingsSchema.test.ts" timestamp="2025-10-17T11:01:41.441Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.013604742">
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should contain all expected top-level settings" time="0.001542972">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct structure for each setting" time="0.003194143">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct nested setting structure" time="0.000549064">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have accessibility nested properties" time="0.000117898">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have checkpointing nested properties" time="0.000098472">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have fileFiltering nested properties" time="0.00009229">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have unique categories" time="0.002039579">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have consistent default values for boolean settings" time="0.002365261">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have showInDialog property configured" time="0.000543335">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should infer Settings type correctly" time="0.000868415">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have includeDirectories setting in schema" time="0.000171357">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have loadMemoryFromIncludeDirectories setting in schema" time="0.000142072">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have folderTrustFeature setting in schema" time="0.000157862">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have debugKeystrokeLogging setting in schema" time="0.000176206">
        </testcase>
    </testsuite>
    <testsuite name="src/config/trustedFolders.test.ts" timestamp="2025-10-17T11:01:41.441Z" hostname="uby" tests="12" failures="7" errors="0" skipped="0" time="0.018685231">
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load empty rules if no files exist" time="0.00297611">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load user rules if only user file exists" time="0.000671761">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should handle JSON parsing errors gracefully" time="0.00708883">
            <failure message="[vitest] No &quot;getErrorMessage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getErrorMessage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Module.loadTrustedFolders src/config/trustedFolders.ts:82:16
 ❯ src/config/trustedFolders.test.ts:109:31
            </failure>
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; setValue should update the user config and save it" time="0.001517936">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a directly trusted folder" time="0.001321141">
            <failure message="[vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Module.isWorkspaceTrusted src/config/trustedFolders.ts:156:9
 ❯ src/config/trustedFolders.test.ts:165:12
            </failure>
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted folder" time="0.000556669">
            <failure message="[vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Module.isWorkspaceTrusted src/config/trustedFolders.ts:156:9
 ❯ src/config/trustedFolders.test.ts:171:12
            </failure>
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted parent folder" time="0.00045461">
            <failure message="[vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Module.isWorkspaceTrusted src/config/trustedFolders.ts:156:9
 ❯ src/config/trustedFolders.test.ts:177:12
            </failure>
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return false for a directly untrusted folder" time="0.000307107">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined for a child of an untrusted folder" time="0.000264919">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined when no rules match" time="0.000663466">
            <failure message="[vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Module.isWorkspaceTrusted src/config/trustedFolders.ts:156:9
 ❯ src/config/trustedFolders.test.ts:196:12
            </failure>
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should prioritize trust over distrust" time="0.000549806">
            <failure message="[vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Module.isWorkspaceTrusted src/config/trustedFolders.ts:156:9
 ❯ src/config/trustedFolders.test.ts:203:12
            </failure>
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should handle path normalization" time="0.000647787">
            <failure message="[vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;isWithinRoot&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Module.isWorkspaceTrusted src/config/trustedFolders.ts:156:9
 ❯ src/config/trustedFolders.test.ts:210:12
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/services/BuiltinCommandLoader.test.ts" timestamp="2025-10-17T11:01:41.442Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="src/services/BuiltinCommandLoader.test.ts" time="0">
            <failure message="[vitest] No &quot;ToolNames&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolNames&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/commands/utils/toolConfig.ts:21:5
 ❯ src/ui/commands/promptModeCommand.ts:10:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/services/CommandService.test.ts" timestamp="2025-10-17T11:01:41.443Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.011899531">
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from a single loader" time="0.003812015">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should aggregate commands from multiple loaders" time="0.000618864">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should override commands from earlier loaders with those from later loaders" time="0.000855842">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle loaders that return an empty array of commands gracefully" time="0.000369773">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from successful loaders even if one fails" time="0.001116263">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; getCommands should return a readonly array that cannot be mutated" time="0.00083315">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should pass the abort signal to all loaders" time="0.001541209">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should rename extension commands when they conflict" time="0.000506376">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle user/project command override correctly" time="0.000368731">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle secondary conflicts when renaming extension commands" time="0.000373179">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle multiple secondary conflicts with incrementing suffixes" time="0.000318638">
        </testcase>
    </testsuite>
    <testsuite name="src/services/FileCommandLoader.test.ts" timestamp="2025-10-17T11:01:41.443Z" hostname="uby" tests="36" failures="0" errors="0" skipped="0" time="0.107321004">
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads a single command from a file" time="0.021361968">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked directory" time="0.002931327">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked subdirectory" time="0.00232634">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads multiple commands" time="0.00226719">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates deeply nested namespaces correctly" time="0.002140696">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates namespaces from nested directories" time="0.001912124">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; returns both user and project commands in order" time="0.004136594">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files with TOML syntax errors" time="0.006058877">
            <system-err>
[FileCommandLoader] Failed to parse TOML file /home/atmandk/.qwen/commands/invalid.toml: Invalid character, expected &quot;=&quot; at row 1, col 7, pos 6:
1&gt; this is not valid toml
         ^



            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files that are semantically invalid (missing prompt)" time="0.005898891">
            <system-err>
[FileCommandLoader] Skipping invalid command file: /home/atmandk/.qwen/commands/no_prompt.toml. Validation errors: {
  formErrors: [],
  fieldErrors: { prompt: [ [32m&quot;The &apos;prompt&apos; field is required.&quot;[39m ] }
}

            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles filename edge cases correctly" time="0.001832667">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles file system errors gracefully" time="0.001043949">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses a default description if not provided" time="0.0016718">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses the provided description" time="0.002514697">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; should sanitize colons in filenames to prevent namespace conflicts" time="0.001719557">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only DefaultArgumentProcessor if no {{args}} or !{} are present" time="0.001932411">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if {{args}} is present (but not !{})" time="0.001167407">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and DefaultArgumentProcessor if !{} is present (but not {{args}})" time="0.001198845">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if both {{args}} and !{} are present" time="0.001036736">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates AtFileProcessor and DefaultArgumentProcessor if @{} is present" time="0.001410386">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and AtFileProcessor if !{} and @{} are present" time="0.001472041">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor and AtFileProcessor if {{args}} and @{} are present" time="0.001075147">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; loads commands from active extensions" time="0.002874292">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; extension commands have extensionName metadata for conflict resolution" time="0.003648733">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; only loads commands from active extensions" time="0.001701565">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles missing extension commands directory gracefully" time="0.001391411">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles nested command structure in extensions" time="0.003081315">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Argument Handling Integration (via ShellProcessor) &gt; correctly processes a command with {{args}}" time="0.002864734">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Default Argument Processor Integration &gt; correctly processes a command without {{args}}" time="0.002914617">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if {{args}} is present (even without shell trigger)" time="0.002562606">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if the trigger is present" time="0.001849929">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; does not instantiate ShellProcessor if no triggers ({{args}} or !{}) are present" time="0.001543672">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;submit_prompt&quot; action if shell processing succeeds" time="0.001759141">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;confirm_shell_commands&quot; action if shell processing requires it" time="0.002079423">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; re-throws other errors from the processor" time="0.002459105">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; assembles the processor pipeline in the correct order (AtFile -&gt; Shell -&gt; Default)" time="0.004672545">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; @-file Processor Integration &gt; correctly processes a command with @{file}" time="0.002181812">
        </testcase>
    </testsuite>
    <testsuite name="src/services/McpPromptLoader.test.ts" timestamp="2025-10-17T11:01:41.444Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.005293573">
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle multi-word positional arguments" time="0.002369679">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle quoted multi-word positional arguments" time="0.000303241">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a single positional argument with multiple words" time="0.000140159">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped quotes in positional arguments" time="0.000127305">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped backslashes in positional arguments" time="0.000093432">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle named args followed by positional args" time="0.00011925">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args followed by named args" time="0.000092872">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args interspersed with named args" time="0.000114452">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should treat an escaped quote at the start as a literal" time="0.000106176">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a complex mix of args" time="0.000125853">
        </testcase>
    </testsuite>
    <testsuite name="src/test-utils/mockCommandContext.test.ts" timestamp="2025-10-17T11:01:41.445Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.006475797">
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should return a valid CommandContext object with default mocks" time="0.003101742">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply top-level overrides correctly" time="0.001169962">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply deeply nested overrides correctly" time="0.000625907">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/App.test.tsx" timestamp="2025-10-17T11:01:41.445Z" hostname="uby" tests="49" failures="5" errors="0" skipped="0" time="1.254480104">
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not start the update process when running from git" time="0.083551167">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Static inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show a success message when update succeeds" time="0.06692981">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when update fails" time="0.067220868">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when spawn fails" time="0.067409196">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not auto-update if GEMINI_CLI_DISABLE_AUTOUPDATER is true" time="0.01653064">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file when available" time="0.01420991">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display any files when not available" time="0.012709739">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other open files" time="0.012013772">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other context" time="0.018198853">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; in footer when contextFileName is not set and count is 1" time="0.011448848">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; with plural when contextFileName is not set and count is &gt; 1" time="0.010666582">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName in footer when set and count is 1" time="0.010327265">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display a generic message when multiple context files with different names are provided" time="0.010534559">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName with plural when set and count is &gt; 1" time="0.010931011">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display context file message if count is 0, even if contextFileName is set" time="0.010763752">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display QWEN.md and MCP server count when both are present" time="0.010863646">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display only MCP server count when QWEN.md count is 0" time="0.01108751">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Tips component by default" time="0.010502689">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Tips component when hideTips is true" time="0.010948213">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Header component by default" time="0.011905592">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Header component when hideBanner is true" time="0.011357779">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Footer component by default" time="0.033837684">
            <failure message="expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;" type="AssertionError">
AssertionError: expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;

- Expected
+ Received

- /test/dir
+  I&apos;m Feeling Lucky (esc to cancel, 0s)
+
+
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)

 ❯ src/ui/App.test.tsx:951:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Footer component when hideFooter is true" time="0.009376999">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show footer if system says show, but workspace and user settings say hide" time="0.012152118">
            <failure message="expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;" type="AssertionError">
AssertionError: expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;

- Expected
+ Received

- /test/dir
+  I&apos;m Feeling Lucky (esc to cancel, 0s)
+
+
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)

 ❯ src/ui/App.test.tsx:989:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show tips if system says show, but workspace and user settings say hide" time="0.010797324">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display theme dialog if NO_COLOR is not set" time="0.012210406">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display a message if NO_COLOR is set" time="0.010791813">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render the initial UI correctly" time="0.012978756">
            <failure message="Snapshot `App UI &gt; should render the initial UI correctly 1` mismatched" type="Error">
Error: Snapshot `App UI &gt; should render the initial UI correctly 1` mismatched

- Expected
+ Received

  &quot; I&apos;m Feeling Lucky (esc to cancel, 0s)


- /test/dir                no sandbox (see /docs)                  model (100% context left)&quot;
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)&quot;

 ❯ src/ui/App.test.tsx:1067:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render correctly with the prompt input box" time="0.017248697">
            <failure message="Snapshot `App UI &gt; should render correctly with the prompt input box 1` mismatched" type="Error">
Error: Snapshot `App UI &gt; should render correctly with the prompt input box 1` mismatched

- Expected
+ Received

  &quot;

  ╭────────────────────────────────────────────────────────────────────────────────────────╮
  │ &gt;   Type your message or @path/to/file                                                 │
  ╰────────────────────────────────────────────────────────────────────────────────────────╯
- /test/dir                no sandbox (see /docs)                  model (100% context left)&quot;
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)&quot;

 ❯ src/ui/App.test.tsx:1088:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; with initial prompt from --prompt-interactive &gt; should submit the initial prompt automatically" time="0.052280667">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; errorCount &gt; should correctly sum the counts of error messages" time="0.01439892">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should call validateAuthMethod when useExternalAuth is false" time="0.013053864">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should NOT call validateAuthMethod when useExternalAuth is true" time="0.01282402">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when in a narrow terminal &gt; should render with a column layout" time="0.01328982">
            <failure message="Snapshot `App UI &gt; when in a narrow terminal &gt; should render with a column layout 1` mismatched" type="Error">
Error: Snapshot `App UI &gt; when in a narrow terminal &gt; should render with a column layout 1` mismatched

- Expected
+ Received

@@ -6,6 +6,6 @@
  ╰────────────────────────────────────────────────────────────────────────────────────────╯
  dir

  no sandbox (see /docs)

- model (100% context left)| ✖ 5 errors (ctrl+o for details)&quot;
+ model (131,072/131,072 tokens available) (100% context left)| ✖ 5 errors (ctrl+o for details)&quot;

 ❯ src/ui/App.test.tsx:1237:27
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; NO_COLOR smoke test &gt; should render without errors when NO_COLOR is set" time="0.013609011">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when isFolderTrustDialogOpen is true" time="0.021470619">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when the feature is enabled but the folder is not trusted" time="0.020029646">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should not display the folder trust dialog when the feature is disabled" time="0.029621271">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should queue messages when handleFinalSubmit is called during streaming" time="0.017939804">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should auto-send queued messages when transitioning from Responding to Idle" time="0.052592563">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should display queued messages with dimmed color" time="0.01510204">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should clear message queue after sending" time="0.018072388">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should handle empty messages by filtering them out" time="0.013559459">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should combine multiple queued messages with double newlines" time="0.02478286">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should limit displayed messages to MAX_DISPLAYED_QUEUED_MESSAGES" time="0.014973592">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should render message queue display without errors" time="0.016415246">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should pass debugKeystrokeLogging setting to KeypressProvider" time="0.01445852">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should use default false value when debugKeystrokeLogging is not set" time="0.012486967">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Ctrl+C behavior &gt; should call cancel but only clear the prompt when a tool is executing" time="0.251630527">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/keyMatchers.test.ts" timestamp="2025-10-17T11:01:41.447Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.007447743">
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match return correctly" time="0.001399286">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match escape correctly" time="0.000282823">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match home correctly" time="0.000201703">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match end correctly" time="0.000164564">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineRight correctly" time="0.000114912">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineLeft correctly" time="0.000100506">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearInput correctly" time="0.0000915">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearScreen correctly" time="0.000109512">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyUp correctly" time="0.00012484">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyDown correctly" time="0.000107589">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationUp correctly" time="0.000145028">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationDown correctly" time="0.000165536">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestion correctly" time="0.000153483">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionUp correctly" time="0.000145479">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionDown correctly" time="0.000153193">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submit correctly" time="0.000169052">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match newline correctly" time="0.000204508">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match openExternalEditor correctly" time="0.000157641">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match pasteClipboardImage correctly" time="0.000100866">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showErrorDetails correctly" time="0.000161669">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleToolDescriptions correctly" time="0.000108761">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleIDEContextDetail correctly" time="0.000072164">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match quit correctly" time="0.000066814">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match exit correctly" time="0.00008681">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showMoreLines correctly" time="0.000073095">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleYoloMode correctly" time="0.0000704">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match reverseSearch correctly" time="0.000123278">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submitReverseSearch correctly" time="0.000101157">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestionReverseSearch correctly" time="0.000110374">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should properly handle ACCEPT_SUGGESTION_REVERSE_SEARCH cases" time="0.00014058">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should work with custom configuration" time="0.000214156">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should support multiple key bindings for same command" time="0.000171126">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Edge Cases &gt; should handle empty binding arrays" time="0.000112288">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/cleanup.test.ts" timestamp="2025-10-17T11:01:41.448Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.004679818">
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered synchronous function" time="0.001977123">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered asynchronous function" time="0.000419355">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run multiple registered functions" time="0.000341972">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should continue running cleanup functions even if one throws an error" time="0.000325762">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/gitUtils.test.ts" timestamp="2025-10-17T11:01:41.448Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.02169343">
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the git command fails" time="0.010238181">
            <system-out>
Failed to get git remote: Error: oops
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:29:13
    at mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at execSync (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at Module.isGitHubRepository [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.ts:17:7[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:31:12
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:155:11
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:26
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1897:20
    at new Promise (&lt;anonymous&gt;)
    at runWithTimeout (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1863:10)

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the remote is not github.com" time="0.000519851">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns true if the remote is github.com" time="0.000193297">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if github repo info cannot be determined" time="0.001302357">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if owner/repo could not be determined" time="0.000576445">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; returns the owner and repo" time="0.00142339">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root cannot be determined" time="0.000474346">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root is empty" time="0.000179742">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; returns the root" time="0.000114933">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch fails" time="0.002075044">
            <system-out>
Failed to determine latest run-gemini-cli release: nope

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch does not return a json body" time="0.001273233">
            <system-out>
Failed to determine latest run-gemini-cli release: Error: Response did not include tag_name field
    at Module.getLatestGitHubRelease [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.ts:82:13[90m)[39m
[90m    at processTicksAndRejections (node:internal/process/task_queues:105:5)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:135:5
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:20

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; returns the release version" time="0.00075216">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/handleAutoUpdate.test.ts" timestamp="2025-10-17T11:01:41.449Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.012170763">
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update info is null" time="0.002068492">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update nag is disabled" time="0.00029772">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if auto-updates are disabled" time="0.002138222">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if no update command is found" time="0.000375474">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should combine update messages correctly" time="0.000257256">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should attempt to perform an update when conditions are met" time="0.000328897">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the update process fails" time="0.001822628">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the spawn function throws an error" time="0.001534206">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should use the &quot;@nightly&quot; tag for nightly updates" time="0.000414637">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-success&quot; when the update process succeeds" time="0.001623019">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/installationInfo.test.ts" timestamp="2025-10-17T11:01:41.449Z" hostname="uby" tests="16" failures="0" errors="0" skipped="0" time="0.009969575">
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN when cliPath is not available" time="0.002128403">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN and log error if realpathSync fails" time="0.001956125">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running from a local git clone" time="0.000307959">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via npx" time="0.000320161">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via pnpx" time="0.000235816">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via bunx" time="0.000222791">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect Homebrew installation via execSync" time="0.00095262">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should fall through if brew command fails" time="0.00044907">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global pnpm installation" time="0.000377377">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global yarn installation" time="0.000321354">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global bun installation" time="0.000221609">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify yarn from lockfile" time="0.000222431">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify pnpm from lockfile" time="0.000180283">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify bun from lockfile" time="0.000136201">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to local npm installation if no lockfile is found" time="0.000234152">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to global npm installation for unrecognized paths" time="0.000300756">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/readStdin.test.ts" timestamp="2025-10-17T11:01:41.449Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.009919612">
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should read and accumulate data from stdin" time="0.00482669">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should handle empty stdin input" time="0.000359675">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should timeout and resolve with empty string when no input is available" time="0.002282638">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should clear timeout once when data is received and resolve with data" time="0.000588418">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/settingsUtils.test.ts" timestamp="2025-10-17T11:01:41.450Z" hostname="uby" tests="68" failures="0" errors="0" skipped="0" time="0.011727923">
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should group settings by category" time="0.0012278">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should include key property in grouped settings" time="0.001099943">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return definition for valid setting" time="0.00025938">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return undefined for invalid setting" time="0.000192345">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return true for settings that require restart" time="0.000110193">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for settings that do not require restart" time="0.000051596">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for invalid settings" time="0.000032801">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return correct default values" time="0.000070891">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return undefined for invalid settings" time="0.000045093">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getRestartRequiredSettings &gt; should return all settings that require restart" time="0.000821719">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from settings when set" time="0.000152732">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from merged settings when not set in current scope" time="0.000054431">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return default value when not set anywhere" time="0.00003259">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should handle nested settings correctly" time="0.000035265">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return undefined for invalid settings" time="0.000029545">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getAllSettingKeys &gt; should return all setting keys" time="0.000114551">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByType &gt; should return only boolean settings" time="0.000551519">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsRequiringRestart &gt; should return only settings that require restart" time="0.000520442">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return true for valid setting keys" time="0.000195812">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return false for invalid setting keys" time="0.000076382">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return correct category for valid settings" time="0.000071762">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return undefined for invalid settings" time="0.000035345">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for settings marked to show in dialog" time="0.000074407">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return false for settings marked to hide from dialog" time="0.000070801">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for invalid settings (default behavior)" time="0.000028773">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should only return settings marked for dialog display" time="0.000325521">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should not include Advanced category settings" time="0.000074949">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should include settings with showInDialog=true" time="0.000299483">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only boolean dialog settings" time="0.000207894">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only string dialog settings" time="0.000150368">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return only settings marked for dialog display" time="0.000405119">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return fewer keys than getAllSettingKeys" time="0.000118048">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should handle nested settings display correctly" time="0.000274136">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from settings when set" time="0.000061674">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from merged settings when not set in current scope" time="0.000037118">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return default value for invalid setting" time="0.000031759">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return true when value differs from default" time="0.000058178">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return false when value matches default" time="0.000046706">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for top-level settings that exist" time="0.000038271">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for top-level settings that do not exist" time="0.000031629">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for nested settings that exist" time="0.000032781">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for nested settings that do not exist" time="0.000030477">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false when parent exists but child does not" time="0.000042328">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set top-level setting value" time="0.00005401">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set nested setting value" time="0.000042899">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should preserve existing nested settings" time="0.000057005">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should not mutate original settings" time="0.000518468">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return true when modified settings require restart" time="0.000103431">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false when no modified settings require restart" time="0.000046406">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false for empty set" time="0.000034243">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return only settings that require restart" time="0.000182948">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return empty array when no settings require restart" time="0.000074728">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value without * when setting matches default" time="0.00005407">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value when setting is not in scope" time="0.000035525">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when changed from default" time="0.000036647">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value without * when setting does not exist in scope" time="0.000034163">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when user changes from default" time="0.000041267">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when setting does not exist in scope" time="0.000045935">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when setting exists in scope" time="0.000033762">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when nested setting does not exist in scope" time="0.000029865">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when nested setting exists in scope" time="0.00003222">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for top-level settings that exist in scope" time="0.000045103">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for top-level settings that do not exist in scope" time="0.000031679">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for nested settings that exist in scope" time="0.000031147">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for nested settings that do not exist in scope" time="0.000029635">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from settings when available" time="0.000051395">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from merged settings when not in scope" time="0.000050243">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return default value for undefined values" time="0.000032611">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/startupWarnings.test.ts" timestamp="2025-10-17T11:01:41.452Z" hostname="uby" tests="4" failures="0" errors="0" skipped="4" time="0">
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return warnings from the file and delete it" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an empty array if the file does not exist" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an error message if reading the file fails" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return a warning if deleting the file fails" time="0">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/utils/userStartupWarnings.test.ts" timestamp="2025-10-17T11:01:41.452Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.013207548">
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should return a warning when running in home directory" time="0.006193806">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should not return a warning when running in a project directory" time="0.001524697">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should return a warning when running in a root directory" time="0.001029713">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should not return a warning when running in a non-root directory" time="0.001288522">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; error handling &gt; should handle errors when checking directory" time="0.001472912">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/install.test.ts" timestamp="2025-10-17T11:01:41.452Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/commands/extensions/install.test.ts" name="src/commands/extensions/install.test.ts" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/config/extension.ts:16:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/uninstall.test.ts" timestamp="2025-10-17T11:01:41.452Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/commands/extensions/uninstall.test.ts" name="src/commands/extensions/uninstall.test.ts" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/config/extension.ts:16:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/add.test.ts" timestamp="2025-10-17T11:01:41.453Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/commands/mcp/add.test.ts" name="src/commands/mcp/add.test.ts" time="0">
            <failure message="[vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock" type="Error">
Error: [vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock
 ❯ src/commands/mcp/add.ts:9:1

Caused by: Caused by: Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/commands/mcp/add.test.ts:17:18
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/list.test.ts" timestamp="2025-10-17T11:01:41.453Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.011989377">
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display message when no servers configured" time="0.004063489">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display different server types with connected status" time="0.004210511">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display disconnected status when connection fails" time="0.001220285">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should merge extension servers with config servers" time="0.001134717">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/remove.test.ts" timestamp="2025-10-17T11:01:41.453Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/commands/mcp/remove.test.ts" name="src/commands/mcp/remove.test.ts" time="0">
            <failure message="[vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock" type="Error">
Error: [vitest] There was an error when mocking a module. If you are using &quot;vi.mock&quot; factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock
 ❯ src/commands/mcp/remove.test.ts:9:1

Caused by: Caused by: Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/commands/mcp/remove.test.ts:18:18
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/config/__tests__/env-persist.test.ts" timestamp="2025-10-17T11:01:41.453Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/config/__tests__/env-persist.test.ts" name="src/config/__tests__/env-persist.test.ts" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/config/auth.ts:8:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/config/extensions/variables.test.ts" timestamp="2025-10-17T11:01:41.453Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.002480734">
        <testcase classname="src/config/extensions/variables.test.ts" name="hydrateString &gt; should replace a single variable" time="0.001258646">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/argumentProcessor.test.ts" timestamp="2025-10-17T11:01:41.453Z" hostname="uby" tests="2" failures="1" errors="0" skipped="0" time="0.011219935">
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should append the full command if args are provided" time="0.008605183">
            <failure message="[vitest] No &quot;appendToLastTextPart&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;appendToLastTextPart&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ DefaultArgumentProcessor.process src/services/prompt-processors/argumentProcessor.ts:23:14
 ❯ src/services/prompt-processors/argumentProcessor.test.ts:24:38
            </failure>
        </testcase>
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should NOT append the full command if no args are provided" time="0.001220456">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/atFileProcessor.test.ts" timestamp="2025-10-17T11:01:41.454Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.021049721">
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if no @{ trigger is present" time="0.003780857">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if config service is missing" time="0.0009956">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace a single valid @{path/to/file.txt} placeholder" time="0.002042304">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace multiple different @{...} placeholders" time="0.001046924">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should handle placeholders at the beginning, middle, and end" time="0.001058126">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should correctly parse paths that contain balanced braces" time="0.000923307">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should throw an error if the prompt contains an unclosed trigger" time="0.003395024">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Integration and Error Handling &gt; should leave the placeholder unmodified if readPathFromWorkspace throws" time="0.001643217">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{not-found.txt}&apos;: File not found. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with an ERROR on failure" time="0.002439609">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{bad-file.txt}&apos;: Access denied. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with a WARNING if the file was ignored" time="0.000959343">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should NOT call ui.addItem on success" time="0.000759623">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/injectionParser.test.ts" timestamp="2025-10-17T11:01:41.454Z" hostname="uby" tests="21" failures="0" errors="0" skipped="0" time="0.007639007">
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should return an empty array if no trigger is present" time="0.002132651">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract a single, simple injection" time="0.000359785">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract multiple injections" time="0.001067333">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should handle different triggers (e.g., @{)" time="0.000127786">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle injections at the start and end of the prompt" time="0.000198908">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle adjacent injections" time="0.000148935">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle empty injections" time="0.000124269">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should trim whitespace within the content" time="0.00013009">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore similar patterns that are not the exact trigger" time="0.000089425">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore extra closing braces before the trigger" time="0.000078405">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should stop parsing at the first balanced closing brace (non-greedy)" time="0.000068847">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with simple nested braces (e.g., JSON)" time="0.000200441">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with shell constructs (e.g., awk)" time="0.000120152">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse multiple levels of nesting" time="0.000106417">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse paths containing balanced braces" time="0.000079146">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly handle an injection containing the trigger itself" time="0.000072193">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error for a simple unclosed injection" time="0.000536712">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error if the prompt ends inside a nested block" time="0.000152682">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should include the context name in the error message if provided" time="0.000086951">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw if content contains unbalanced braces (e.g., missing closing)" time="0.000074077">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should clearly state that unbalanced braces in content are not supported in the error" time="0.000071723">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/shellProcessor.test.ts" timestamp="2025-10-17T11:01:41.455Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.050568844">
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw an error if config is missing" time="0.005666091">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not change the prompt if no shell injections are present" time="0.001981011">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process a single valid shell injection if allowed" time="0.004490098">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process multiple valid shell injections if all are allowed" time="0.00193731">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError if a command is not allowed in default mode" time="0.001331671">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should NOT throw ConfirmationRequiredError if a command is not allowed but approval mode is YOLO" time="0.001098941">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should still throw an error for a hard-denied command even in YOLO mode" time="0.001171956">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with the correct command" time="0.000919048">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with multiple commands if multiple are disallowed" time="0.000864247">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not execute any commands if at least one requires confirmation" time="0.001653756">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should only request confirmation for disallowed commands in a mixed prompt" time="0.001281418">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should execute all commands if they are on the session allowlist" time="0.001555685">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should trim whitespace from the command inside the injection before interpolation" time="0.001114129">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should handle an empty command inside the injection gracefully (skips execution)" time="0.000821708">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append exit code and command name on failure" time="0.000752992">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append signal info and command name if terminated by signal" time="0.000762529">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should throw a detailed error if the shell fails to spawn" time="0.00076825">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should report abort status with command name if aborted" time="0.000747081">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement if no shell injections are present (optimization path)" time="0.000781725">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement outside !{} blocks" time="0.000552502">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform escaped replacement inside !{} blocks" time="0.000862334">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should handle both raw (outside) and escaped (inside) injection simultaneously" time="0.000826938">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform security checks on the final, resolved (escaped) command" time="0.002492587">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should report the resolved command if a hard denial occurs" time="0.001545987">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should correctly handle multiline arguments" time="0.002164009">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;spaces&apos;" time="0.001299331">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;double quotes&apos;" time="0.000852265">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;single quotes&apos;" time="0.000707928">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (backticks)&apos;" time="0.000631497">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (dollar)&apos;" time="0.001479034">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;variable expansion&apos;" time="0.001423481">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (semicolon)&apos;" time="0.001687338">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (ampersand)&apos;" time="0.001639801">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/KeypressContext.test.tsx" timestamp="2025-10-17T11:01:41.456Z" hostname="uby" tests="32" failures="0" errors="0" skipped="0" time="0.119381833">
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize regular enter key (keycode 13) in kitty protocol" time="0.025420448">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize numpad enter key (keycode 57414) in kitty protocol" time="0.00350079">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with modifiers" time="0.00409076">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Ctrl modifier" time="0.002534974">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Alt modifier" time="0.003130846">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should not process kitty sequences when kitty protocol is disabled" time="0.00200769">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Escape key handling &gt; should recognize escape key (keycode 27) in kitty protocol" time="0.0020887">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Tab key in kitty protocol" time="0.003141976">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Shift+Tab in kitty protocol" time="0.001804915">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Backspace key in kitty protocol" time="0.003545693">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Option+Backspace in kitty protocol" time="0.002238817">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; should handle multiline paste as a single event" time="0.004782729">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complete paste sequence with markers" time="0.003134273">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle empty paste sequence" time="0.003043214">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data before paste markers" time="0.003981849">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data after paste markers" time="0.003580748">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complex sequence with multiple paste blocks" time="0.004744598">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle fragmented paste markers across multiple data events" time="0.004039806">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle multiline content within paste markers" time="0.004080751">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle paste markers split across buffer boundaries" time="0.004219638">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; buffers fragmented paste chunks before emitting newlines" time="0.004308402">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should buffer input data and wait for timeout" time="0.002269965">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should concatenate new data and reset timeout" time="0.002174959">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should flush immediately when buffer exceeds limit" time="0.002662971">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should clear timeout when new data arrives" time="0.00145024">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle multiple separate keypress events" time="0.001667803">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle rapid sequential data within buffer limit" time="0.001519027">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should not log keystrokes when debugKeystrokeLogging is false" time="0.002062161">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer accumulation when debugKeystrokeLogging is true" time="0.002198563">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer overflow when debugKeystrokeLogging is true" time="0.002544713">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer clear on Ctrl+C when debugKeystrokeLogging is true" time="0.001698999">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should show char codes when debugKeystrokeLogging is true even without debug mode" time="0.001678472">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/SessionContext.test.tsx" timestamp="2025-10-17T11:01:41.457Z" hostname="uby" tests="3" failures="2" errors="0" skipped="0" time="0.225569063">
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should provide the correct initial state" time="0.134186483">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
            <failure message="expected undefined to be an instance of Date" type="AssertionError">
AssertionError: expected undefined to be an instance of Date
 ❯ src/ui/contexts/SessionContext.test.tsx:44:37
            </failure>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should update metrics when the uiTelemetryService emits an update" time="0.072986713">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. Import `act` from `react` instead of `react-dom/test-utils`. See https://react.dev/warnings/react-dom-test-utils for more info.

            </system-err>
            <failure message="uiTelemetryService.emit is not a function" type="TypeError">
TypeError: uiTelemetryService.emit is not a function
 ❯ src/ui/contexts/SessionContext.test.tsx:105:26
 ❯ Object.process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react-dom/cjs/react-dom-test-utils.development.js:22:20
 ❯ src/ui/contexts/SessionContext.test.tsx:104:5
            </failure>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should throw an error when useSessionStats is used outside of a provider" time="0.016369061">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/aboutCommand.test.ts" timestamp="2025-10-17T11:01:41.457Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.018718452">
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should have the correct name and description" time="0.003472988">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should call addItem with all version info" time="0.008058643">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show the correct sandbox environment variable" time="0.002082719">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show sandbox-exec profile when applicable" time="0.001514118">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should not show ide client when it is not detected" time="0.001310882">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/approvalModeCommand.test.ts" timestamp="2025-10-17T11:01:41.457Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="src/ui/commands/approvalModeCommand.test.ts" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/ui/commands/approvalModeCommand.ts:14:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/authCommand.test.ts" timestamp="2025-10-17T11:01:41.458Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.00413427">
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should return a dialog action to open the auth dialog" time="0.002596789">
        </testcase>
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should have the correct name and description" time="0.000519179">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/bugCommand.test.ts" timestamp="2025-10-17T11:01:41.458Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.008854894">
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should generate the default GitHub issue URL" time="0.00581682">
        </testcase>
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should use a custom URL template from config if provided" time="0.001261772">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/chatCommand.test.ts" timestamp="2025-10-17T11:01:41.458Z" hostname="uby" tests="17" failures="10" errors="0" skipped="0" time="0.063255429">
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; should have the correct main command definition" time="0.0046212">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should inform when no checkpoints are found" time="0.00221291">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should list found checkpoints" time="0.018453413">
            <failure message="expected &apos;No saved conversation checkpoints fou…&apos; to contain &apos;List of saved conversations:&apos;" type="AssertionError">
AssertionError: expected &apos;No saved conversation checkpoints fou…&apos; to contain &apos;List of saved conversations:&apos;

Expected: &quot;List of saved conversations:&quot;
Received: &quot;No saved conversation checkpoints found.&quot;

 ❯ src/ui/commands/chatCommand.test.ts:134:23
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should handle invalid date formats gracefully" time="0.003243134">
            <failure message="expected &apos;No saved conversation checkpoints fou…&apos; to contain &apos;(saved on Invalid Date)&apos;" type="AssertionError">
AssertionError: expected &apos;No saved conversation checkpoints fou…&apos; to contain &apos;(saved on Invalid Date)&apos;

Expected: &quot;(saved on Invalid Date)&quot;
Received: &quot;No saved conversation checkpoints found.&quot;

 ❯ src/ui/commands/chatCommand.test.ts:161:23
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return an error if tag is missing" time="0.001232208">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should inform if conversation history is empty or only contains system context" time="0.003023117">
            <failure message="[vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/chatCommand.ts:154:61
 ❯ src/ui/commands/chatCommand.test.ts:209:16
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return confirm_action if checkpoint already exists" time="0.003389554">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should save the conversation if overwrite is confirmed" time="0.00203991">
            <failure message="[vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/chatCommand.ts:154:61
 ❯ src/ui/commands/chatCommand.test.ts:247:22
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should return an error if tag is missing" time="0.001787404">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should inform if checkpoint is not found" time="0.00180716">
            <failure message="[vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/chatCommand.ts:190:57
 ❯ src/ui/commands/chatCommand.test.ts:281:22
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should resume a conversation" time="0.00195325">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should provide completion suggestions" time="0.004895818">
            <failure message="expected [] to deeply equal [ &apos;alpha&apos; ]" type="AssertionError">
AssertionError: expected [] to deeply equal [ &apos;alpha&apos; ]

- Expected
+ Received

- [
-   &quot;alpha&quot;,
- ]
+ []

 ❯ src/ui/commands/chatCommand.test.ts:326:24
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should suggest filenames sorted by modified time (newest first)" time="0.002898637">
            <failure message="expected [] to deeply equal [ &apos;test2&apos;, &apos;test1&apos; ]" type="AssertionError">
AssertionError: expected [] to deeply equal [ &apos;test2&apos;, &apos;test1&apos; ]

- Expected
+ Received

- [
-   &quot;test2&quot;,
-   &quot;test1&quot;,
- ]
+ []

 ❯ src/ui/commands/chatCommand.test.ts:347:24
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if tag is missing" time="0.00176411">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if checkpoint is not found" time="0.001494141">
            <failure message="[vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/chatCommand.ts:265:58
 ❯ src/ui/commands/chatCommand.test.ts:370:22
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should delete the conversation" time="0.003245919">
            <failure message="[vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;decodeTagName&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/chatCommand.ts:259:46
 ❯ src/ui/commands/chatCommand.test.ts:379:22
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; completion &gt; should provide completion suggestions" time="0.00298697">
            <failure message="expected [] to deeply equal [ &apos;alpha&apos; ]" type="AssertionError">
AssertionError: expected [] to deeply equal [ &apos;alpha&apos; ]

- Expected
+ Received

- [
-   &quot;alpha&quot;,
- ]
+ []

 ❯ src/ui/commands/chatCommand.test.ts:406:24
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/clearCommand.test.ts" timestamp="2025-10-17T11:01:41.459Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007160223">
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should set debug message, reset chat, reset telemetry, and clear UI when config is available" time="0.004210371">
        </testcase>
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should not attempt to reset chat if config service is not available" time="0.001441574">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/compressCommand.test.ts" timestamp="2025-10-17T11:01:41.459Z" hostname="uby" tests="5" failures="1" errors="0" skipped="0" time="0.021363211">
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should do nothing if a compression is already pending" time="0.00602805">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should set pending item, call tryCompressChat, and add result on success" time="0.009663559">
            <failure message="[vitest] No &quot;CompressionStatus&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;CompressionStatus&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/commands/compressCommand.test.ts:60:26
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat returns falsy" time="0.001751407">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat throws" time="0.00126088">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should clear the pending item in a finally block" time="0.001205618">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/copyCommand.test.ts" timestamp="2025-10-17T11:01:41.460Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.012164681">
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no history is available" time="0.003000215">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when history is empty" time="0.000529058">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no AI messages are found in history" time="0.000526083">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should copy last AI message to clipboard successfully" time="0.001472592">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle multiple text parts in AI message" time="0.00085511">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should filter out non-text parts" time="0.000555617">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should get the last AI message when multiple AI messages exist" time="0.000662023">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle clipboard copy error" time="0.001264497">
            <system-out>
Clipboard access denied

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle non-Error clipboard errors" time="0.000673916">
            <system-out>
String error

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no text parts found in AI message" time="0.000437819">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle unavailable config service" time="0.000896006">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/corgiCommand.test.ts" timestamp="2025-10-17T11:01:41.460Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.005430686">
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should call the toggleCorgiMode function on the UI context" time="0.003337287">
        </testcase>
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should have the correct name and description" time="0.000767539">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/directoryCommand.test.tsx" timestamp="2025-10-17T11:01:41.460Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.009642029">
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; show &gt; should display the list of directories" time="0.004375626">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if no path is provided" time="0.000758932">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory and show a success message for a single path" time="0.000833942">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory for each path and show a success message for multiple paths" time="0.00053597">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if addDirectory throws an exception" time="0.000467955">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should handle a mix of successful and failed additions" time="0.0005954">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; should correctly expand a Windows-style home directory path" time="0.000506887">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/docsCommand.test.ts" timestamp="2025-10-17T11:01:41.460Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.011787935">
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should add an info message and call &apos;open&apos; in a non-sandbox environment" time="0.006965112">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should only add an info message in a sandbox environment" time="0.001657944">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should not open browser for &apos;sandbox-exec&apos;" time="0.001005999">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/editorCommand.test.ts" timestamp="2025-10-17T11:01:41.461Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.003743648">
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should return a dialog action to open the editor dialog" time="0.002535796">
        </testcase>
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should have the correct name and description" time="0.000228933">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/exportCommand.test.ts" timestamp="2025-10-17T11:01:41.461Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.00212148">
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should have the correct name and a helpful description" time="0.001267933">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/extensionsCommand.test.ts" timestamp="2025-10-17T11:01:41.461Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.008805393">
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should display &quot;No active extensions.&quot; when none are found" time="0.005574853">
        </testcase>
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should list active extensions when they are found" time="0.001262473">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/helpCommand.test.ts" timestamp="2025-10-17T11:01:41.461Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.00813276">
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should add a help message to the UI history" time="0.00559514">
        </testcase>
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should have the correct command properties" time="0.001189339">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/ideCommand.test.ts" timestamp="2025-10-17T11:01:41.461Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="5.026396606">
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return null if config is not provided" time="0.002852161">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return the ide command" time="0.002877187">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should show disable command when connected" time="0.001186593">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connected status" time="0.001602752">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connecting status" time="0.002075185">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status" time="0.000887099">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status with details" time="0.000664879">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should install the extension" time="5.011426731">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should show an error if installation fails" time="0.000931972">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/initCommand.test.ts" timestamp="2025-10-17T11:01:41.461Z" hostname="uby" tests="5" failures="4" errors="0" skipped="0" time="0.022811938">
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should ask for confirmation if QWEN.md already exists and is non-empty" time="0.01188269">
            <failure message="[vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/initCommand.ts:35:29
 ❯ src/ui/commands/initCommand.test.ts:62:38
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should create QWEN.md and submit a prompt if it does not exist" time="0.001889051">
            <failure message="[vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/initCommand.ts:35:29
 ❯ src/ui/commands/initCommand.test.ts:81:38
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should proceed to initialize when QWEN.md exists but is empty" time="0.001389938">
            <failure message="[vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/initCommand.ts:35:29
 ❯ src/ui/commands/initCommand.test.ts:110:38
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should regenerate QWEN.md when overwrite is confirmed" time="0.002874071">
            <failure message="[vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getCurrentGeminiMdFilename&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/initCommand.ts:35:29
 ❯ src/ui/commands/initCommand.test.ts:127:38
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should return an error if config is not available" time="0.00323034">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/loggingCommand.test.ts" timestamp="2025-10-17T11:01:41.462Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.013774646">
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; enables logging when /logging on is issued" time="0.006405448">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; disables logging when /logging off is issued" time="0.002142259">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; reports status when invoked without arguments" time="0.001153551">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; shows usage for unknown arguments" time="0.001573017">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/mcpCommand.test.ts" timestamp="2025-10-17T11:01:41.462Z" hostname="uby" tests="35" failures="0" errors="0" skipped="0" time="0.067723245">
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if config is not available" time="0.004501719">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if tool registry is not available" time="0.001747409">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; no MCP servers configured &gt; should display a message with a URL when no MCP servers are configured" time="0.001332101">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display configured MCP servers with status indicators and their tools" time="0.002404904">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display tool descriptions when desc argument is used" time="0.00231576">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should not display descriptions when nodesc argument is used" time="0.001290034">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should indicate when a server has no tools" time="0.000975242">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should show startup indicator when servers are connecting" time="0.001078753">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display the extension name for servers from extensions" time="0.000890415">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display blocked MCP servers" time="0.000775293">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display both active and blocked servers correctly" time="0.000771917">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should display tool schemas when schema argument is used" time="0.001172156">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should handle tools without parameter schemas gracefully" time="0.001828799">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;descriptions&quot; as alias for &quot;desc&quot;" time="0.000922676">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodescriptions&quot; as alias for &quot;nodesc&quot;" time="0.000920461">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle mixed case arguments" time="0.000845612">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;schema desc&quot;" time="0.000896607">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;desc schema&quot;" time="0.000869748">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;schema&quot; alone showing descriptions" time="0.001003374">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;schema&quot; - &quot;schema nodesc&quot;" time="0.001023241">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;desc&quot; - &quot;desc nodesc&quot;" time="0.001005097">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding both &quot;desc&quot; and &quot;schema&quot; - &quot;desc schema nodesc&quot;" time="0.001098029">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle extra whitespace in arguments" time="0.001216418">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle empty arguments gracefully" time="0.001048919">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle unknown arguments gracefully" time="0.001103439">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle empty server names gracefully" time="0.002064575">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle servers with special characters in names" time="0.002360974">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should list OAuth-enabled servers when no server name is provided" time="0.003473709">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should show message when no OAuth servers are configured" time="0.005028913">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should authenticate with a specific server" time="0.004782027">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle authentication errors" time="0.003424468">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle non-existent server" time="0.002568125">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should refresh the list of tools and display the status" time="0.004250916">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if config is not available" time="0.002100232">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if tool registry is not available" time="0.001992031">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/memoryCommand.test.ts" timestamp="2025-10-17T11:01:41.463Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.020677753">
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display a message if memory is empty" time="0.005724639">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display the memory content and file count if it exists" time="0.001043729">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return an error message if no arguments are provided" time="0.001503558">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return a tool action and add an info message when arguments are provided" time="0.001683962">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --global flag and add scope to tool args" time="0.000915302">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --project flag and add scope to tool args" time="0.000970653">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return error if flag is provided but no fact follows" time="0.000555937">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with content" time="0.001826916">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with no content" time="0.000961717">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display an error message if refreshing fails" time="0.001310602">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should not throw if config service is unavailable" time="0.001575391">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/modelCommand.test.ts" timestamp="2025-10-17T11:01:41.463Z" hostname="uby" tests="9" failures="2" errors="0" skipped="0" time="0.020557962">
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should have the correct name and description" time="0.002633928">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when config is not available" time="0.001664006">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when content generator config is not available" time="0.001109861">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when auth type is not available" time="0.000823792">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for QWEN_OAUTH auth type" time="0.000705744">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for USE_OPENAI auth type when model is available" time="0.008480322">
            <failure message="[vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;../models/availableModels.js&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/modelCommand.ts:96:9
 ❯ src/ui/commands/modelCommand.test.ts:126:20
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for USE_OPENAI auth type when no model is available" time="0.001658054">
            <failure message="[vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;../models/availableModels.js&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/modelCommand.ts:96:9
 ❯ src/ui/commands/modelCommand.test.ts:143:20
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for unsupported auth types" time="0.001284413">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should handle undefined auth type" time="0.000634733">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/privacyCommand.test.ts" timestamp="2025-10-17T11:01:41.464Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.006105964">
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should return a dialog action to open the privacy dialog" time="0.003702993">
        </testcase>
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should have the correct name and description" time="0.000755335">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/quitCommand.test.ts" timestamp="2025-10-17T11:01:41.464Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.008301271">
        <testcase classname="src/ui/commands/quitCommand.test.ts" name="quitCommand &gt; returns a QuitActionReturn object with the correct messages" time="0.006758701">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/restoreCommand.test.ts" timestamp="2025-10-17T11:01:41.464Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.059119886">
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return null if checkpointing is not enabled" time="0.006559954">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return the command if checkpointing is enabled" time="0.003095571">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if temp dir is not found" time="0.00238062">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should inform when no checkpoints are found if no args are passed" time="0.002790106">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should list available checkpoints if no args are passed" time="0.008424078">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if the specified file is not found" time="0.008000315">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should handle file read errors gracefully" time="0.004014859">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore a tool call and project state" time="0.005067274">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore even if only toolCall is present" time="0.002695461">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return an error for a checkpoint file missing the toolCall property" time="0.003102424">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array if temp dir is not found" time="0.005766056">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array on readdir error" time="0.002385147">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return a list of checkpoint names" time="0.002889831">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/settingsCommand.test.ts" timestamp="2025-10-17T11:01:41.465Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.00590304">
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should return a dialog action to open the settings dialog" time="0.003650717">
        </testcase>
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should have the correct name and description" time="0.00092017">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/setupGithubCommand.test.ts" timestamp="2025-10-17T11:01:41.465Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.056976676">
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="setupGithubCommand &gt; returns a tool action to download github workflows and handles paths" time="0.02712055">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; creates a new .gitignore file when none exists" time="0.001188767">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; appends entries to existing .gitignore file" time="0.00734797">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not add duplicate entries" time="0.001827256">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; adds only missing entries when some already exist" time="0.00167741">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not get confused by entries in comments or as substrings" time="0.004659721">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles file system errors gracefully" time="0.007793031">
            <system-out>
Failed to update .gitignore: Error: ENOENT: no such file or directory, open &apos;/tmp/update-gitignore-12CkT6/non-existent/.gitignore&apos;
[90m    at open (node:internal/fs/promises:642:25)[39m
[90m    at Object.writeFile (node:internal/fs/promises:1249:14)[39m
    at Module.updateGitignore [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/commands/setupGithubCommand.ts:71:7[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/commands/setupGithubCommand.test.ts:218:5
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:20 {
  errno: [33m-2[39m,
  code: [32m&apos;ENOENT&apos;[39m,
  syscall: [32m&apos;open&apos;[39m,
  path: [32m&apos;/tmp/update-gitignore-12CkT6/non-existent/.gitignore&apos;[39m
}

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles permission errors gracefully" time="0.00377696">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/statsCommand.test.ts" timestamp="2025-10-17T11:01:41.465Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.015641125">
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display general session stats when run with no subcommand" time="0.010592215">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display model stats when using the &quot;model&quot; subcommand" time="0.001674635">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display tool stats when using the &quot;tools&quot; subcommand" time="0.001667692">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/terminalSetupCommand.test.ts" timestamp="2025-10-17T11:01:41.465Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.005982196">
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should have correct metadata" time="0.001952659">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return success message when terminal setup succeeds" time="0.00142356">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should append restart message when terminal setup requires restart" time="0.000403195">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return error message when terminal setup fails" time="0.000272343">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should handle exceptions from terminal setup" time="0.000377568">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/themeCommand.test.ts" timestamp="2025-10-17T11:01:41.465Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.006419023">
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should return a dialog action to open the theme dialog" time="0.00386892">
        </testcase>
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should have the correct name and description" time="0.000945497">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/toolsCommand.test.ts" timestamp="2025-10-17T11:01:41.465Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.012472449">
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display an error if the tool registry is unavailable" time="0.006181193">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display &quot;No tools available&quot; when none are found" time="0.002569218">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools without descriptions by default" time="0.001472301">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools with descriptions when &quot;desc&quot; arg is passed" time="0.000669928">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/toolsetCommand.test.ts" timestamp="2025-10-17T11:01:41.466Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.014274961">
        <testcase classname="src/ui/commands/toolsetCommand.test.ts" name="toolsetCommand &gt; rejects unknown tool names when adding to a collection" time="0.008873299">
        </testcase>
        <testcase classname="src/ui/commands/toolsetCommand.test.ts" name="toolsetCommand &gt; allows adding tools using display names" time="0.001880195">
        </testcase>
        <testcase classname="src/ui/commands/toolsetCommand.test.ts" name="toolsetCommand &gt; rejects ambiguous tool names" time="0.001745375">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/AuthDialog.test.tsx" timestamp="2025-10-17T11:01:41.466Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="src/ui/components/AuthDialog.test.tsx" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/config/auth.ts:8:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ContextSummaryDisplay.test.tsx" timestamp="2025-10-17T11:01:41.466Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.050643172">
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on a single line on a wide screen" time="0.025895886">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on multiple lines on a narrow screen" time="0.010546511">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should switch layout at the 80-column breakpoint" time="0.009905156">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should not render empty parts" time="0.00248365">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/FolderTrustDialog.test.tsx" timestamp="2025-10-17T11:01:41.466Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.200653277">
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should render the dialog with title and description" time="0.046966707">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call onSelect with DO_NOT_TRUST when escape is pressed and not restarting" time="0.074809923">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call onSelect when escape is pressed and is restarting" time="0.02526989">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should display restart message when isRestarting is true" time="0.015784851">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call process.exit when &quot;r&quot; is pressed and isRestarting is true" time="0.022245781">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call process.exit when &quot;r&quot; is pressed and isRestarting is false" time="0.013334503">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Footer.test.tsx" timestamp="2025-10-17T11:01:41.466Z" hostname="uby" tests="13" failures="4" errors="0" skipped="0" time="0.135764339">
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; renders the component" time="0.043885443">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display shortened path on a wide terminal" time="0.015377559">
            <failure message="expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;...bar/and/some/more/directories/to/m…&apos;" type="AssertionError">
AssertionError: expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;...bar/and/some/more/directories/to/m…&apos;

- Expected
+ Received

- ...bar/and/some/more/directories/to/make/it/long
+ ...bar/and/some/more/directories/to/ma  no sandbox      gemini-pro (130,972/131,072 tokens
+ ke/it/long (main*)                      (see /docs)    available) (100% context left)

 ❯ src/ui/components/Footer.test.tsx:62:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display only the base directory name on a narrow terminal" time="0.007480615">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use wide layout at 80 columns" time="0.00988092">
            <failure message="expected &apos;...e/directories/to/make/it/lo  no sa…&apos; to contain &apos;...e/directories/to/make/it/long&apos;" type="AssertionError">
AssertionError: expected &apos;...e/directories/to/make/it/lo  no sa…&apos; to contain &apos;...e/directories/to/make/it/long&apos;

- Expected
+ Received

- ...e/directories/to/make/it/long
+ ...e/directories/to/make/it/lo  no sandbox (see   gemini-pro (130,972/131,072 tokens available)
+ ng (main*)                      /docs)           (100% context left)

 ❯ src/ui/components/Footer.test.tsx:75:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use narrow layout at 79 columns" time="0.005942181">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the branch name when provided" time="0.005736782">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; does not display the branch name when not provided" time="0.00623345">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the model name and context percentage" time="0.006936219">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display untrusted when isTrustedFolder is false" time="0.008914965">
            <failure message="expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;" type="AssertionError">
AssertionError: expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;

- Expected
+ Received

- untrusted
+ ...bar/and/some/more/directories/to/make/i untrus  gemini-pro (130,972/131,072 tokens available)
+ t/long (main*)                             ted    (100% context left)

 ❯ src/ui/components/Footer.test.tsx:113:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display custom sandbox info when SANDBOX env is set" time="0.007445609">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display macOS Seatbelt info when SANDBOX is sandbox-exec" time="0.005456875">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display &quot;no sandbox&quot; when SANDBOX is not set and folder is trusted" time="0.004353195">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should prioritize untrusted message over sandbox info" time="0.005420688">
            <failure message="expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;" type="AssertionError">
AssertionError: expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;

- Expected
+ Received

- untrusted
+ ...bar/and/some/more/directories/to/make/i untrus  gemini-pro (130,972/131,072 tokens available)
+ t/long (main*)                             ted    (100% context left)

 ❯ src/ui/components/Footer.test.tsx:154:27
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Header.test.tsx" timestamp="2025-10-17T11:01:41.467Z" hostname="uby" tests="4" failures="1" errors="0" skipped="0" time="0.064656258">
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders the long logo on a wide terminal" time="0.03991749">
            <failure message="expected &apos;\n █████                             …&apos; to contain &apos;\n █████                             …&apos;" type="AssertionError">
AssertionError: expected &apos;\n █████                             …&apos; to contain &apos;\n █████                             …&apos;

- Expected
+ Received


-  █████                                  █████████            ████       █████████               █████         
+  █████                                  █████████            ████       █████████               █████
- ░░███                                  ███░░░░░███          ░░███      ███░░░░░███             ░░███          
+ ░░███                                  ███░░░░░███          ░░███      ███░░░░░███             ░░███
-  ░███         ██████  █████ ███ █████ ███     ░░░   ██████   ░███     ███     ░░░   ██████   ███████   ██████ 
+  ░███         ██████  █████ ███ █████ ███     ░░░   ██████   ░███     ███     ░░░   ██████   ███████   ██████
   ░███        ███░░███░░███ ░███░░███ ░███          ░░░░░███  ░███    ░███          ███░░███ ███░░███  ███░░███
-  ░███       ░███ ░███ ░███ ░███ ░███ ░███           ███████  ░███    ░███         ░███ ░███░███ ░███ ░███████ 
+  ░███       ░███ ░███ ░███ ░███ ░███ ░███           ███████  ░███    ░███         ░███ ░███░███ ░███ ░███████
-  ░███      █░███ ░███ ░░███████████  ░░███     ███ ███░░███  ░███    ░░███     ███░███ ░███░███ ░███ ░███░░░  
+  ░███      █░███ ░███ ░░███████████  ░░███     ███ ███░░███  ░███    ░░███     ███░███ ░███░███ ░███ ░███░░░
-  ███████████░░██████   ░░████░████    ░░█████████ ░░████████ █████    ░░█████████ ░░██████ ░░████████░░██████ 
+  ███████████░░██████   ░░████░████    ░░█████████ ░░████████ █████    ░░█████████ ░░██████ ░░████████░░██████
- ░░░░░░░░░░░  ░░░░░░     ░░░░ ░░░░      ░░░░░░░░░   ░░░░░░░░ ░░░░░      ░░░░░░░░░   ░░░░░░   ░░░░░░░░  ░░░░░░   
-                                                                                                    
+ ░░░░░░░░░░░  ░░░░░░     ░░░░ ░░░░      ░░░░░░░░░   ░░░░░░░░ ░░░░░      ░░░░░░░░░   ░░░░░░   ░░░░░░░░  ░░░░░░
+


 ❯ src/ui/components/Header.test.tsx:25:25
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders custom ASCII art when provided" time="0.00182899">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; displays the version number when nightly is true" time="0.010650693">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; does not display the version number when nightly is false" time="0.011218823">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/HistoryItemDisplay.test.tsx" timestamp="2025-10-17T11:01:41.468Z" hostname="uby" tests="7" failures="3" errors="0" skipped="0" time="0.378034797">
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type" time="0.026724919">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type with slash command" time="0.003500759">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders StatsDisplay for &quot;stats&quot; type" time="0.106497022">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders AboutBox for &quot;about&quot; type" time="0.014759607">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ModelStatsDisplay for &quot;model_stats&quot; type" time="0.0800137">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;sessionId&quot; exp…&apos; to contain &apos;No API calls have been made in this s…&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;sessionId&quot; exp…&apos; to contain &apos;No API calls have been made in this s…&apos;

- Expected
+ Received

- No API calls have been made in this session.
+
+   ERROR [vitest] No &quot;sessionId&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you
+        forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - SessionStatsProvider (src/ui/contexts/SessionContext.tsx:70:5)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/HistoryItemDisplay.test.tsx:96:25
            </failure>
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ToolStatsDisplay for &quot;tool_stats&quot; type" time="0.051672443">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;sessionId&quot; exp…&apos; to contain &apos;No tool calls have been made in this …&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;sessionId&quot; exp…&apos; to contain &apos;No tool calls have been made in this …&apos;

- Expected
+ Received

- No tool calls have been made in this session.
+
+   ERROR [vitest] No &quot;sessionId&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you
+        forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - SessionStatsProvider (src/ui/contexts/SessionContext.tsx:70:5)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/HistoryItemDisplay.test.tsx:111:25
            </failure>
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders SessionSummaryDisplay for &quot;quit&quot; type" time="0.092769653">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;sessionId&quot; exp…&apos; to contain &apos;Agent powering down. Goodbye!&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;sessionId&quot; exp…&apos; to contain &apos;Agent powering down. Goodbye!&apos;

- Expected
+ Received

- Agent powering down. Goodbye!
+
+   ERROR [vitest] No &quot;sessionId&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you
+        forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - SessionStatsProvider (src/ui/contexts/SessionContext.tsx:70:5)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/HistoryItemDisplay.test.tsx:127:25
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/InputPrompt.test.tsx" timestamp="2025-10-17T11:01:41.468Z" hostname="uby" tests="61" failures="0" errors="0" skipped="0" time="6.667380642">
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getPreviousCommand on up arrow in shell mode" time="0.146964468">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getNextCommand on down arrow in shell mode" time="0.114462542">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should set the buffer text when a shell history command is retrieved" time="0.112735761">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.addCommandToHistory on submit in shell mode" time="0.114641494">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call shell history methods when not in shell mode" time="0.214682133">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateUp for both up arrow and Ctrl+P when suggestions are showing" time="0.162444535">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateDown for both down arrow and Ctrl+N when suggestions are showing" time="0.16548839">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call completion navigation when suggestions are not showing" time="0.26118892">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle Ctrl+V when clipboard has an image" time="0.116981587">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should not insert anything when clipboard has no image" time="0.109123876">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle image save failure gracefully" time="0.110675354">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should insert image path at cursor position with proper spacing" time="0.108359053">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle errors during clipboard operations" time="0.113832478">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial parent command" time="0.114994786">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should append a sub-command when the parent command is already complete" time="0.11324922">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should handle the &quot;backspace&quot; edge case correctly" time="0.114228459">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial argument for a command" time="0.119002623">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete on Enter when suggestions are active, without submitting" time="0.121149129">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a command based on its altNames" time="0.117904985">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should not submit on Enter when the buffer is empty or only contains whitespace" time="0.115180179">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when isPerfectMatch is true" time="0.114348542">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when a complete leaf command is typed" time="0.114686516">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete an @-path on Enter without submitting" time="0.124776173">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should add a newline on enter when the line ends with a backslash" time="0.116181479">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should clear the buffer on Ctrl+C if it has text" time="0.117149969">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT clear the buffer on Ctrl+C if it is empty" time="0.126198832">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after @ without spaces" time="0.067315913">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after / without spaces" time="0.06717858">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following @" time="0.063128735">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following /" time="0.063494221">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is not after @ or /" time="0.06557685">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiline text correctly" time="0.063547459">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle single line slash command correctly" time="0.0683852">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters (emojis) correctly in paths" time="0.07112897">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with spaces after them" time="0.066115996">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in paths correctly" time="0.069725186">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion after unescaped space following escaped space" time="0.064675163">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiple escaped spaces in paths" time="0.065782269">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in slash commands" time="0.068142982">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with escaped spaces" time="0.065779253">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should not call buffer.handleInput when vim mode is enabled and vim handles the input" time="0.147758264">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call buffer.handleInput when vim mode is enabled but vim does not handle the input" time="0.114768077">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call handleInput when vim mode is disabled" time="0.113263807">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should handle bracketed paste when not focused" time="0.113829512">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should ignore regular keypresses when not focused" time="0.111608248">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \n newlines&apos;" time="0.110601087">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with extra slashes before \n newlines&apos;" time="0.10899042">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \r\n newlines&apos;" time="0.108316514">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should clear buffer on second ESC press" time="0.158555338">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should reset escape state on any non-ESC key" time="0.062840142">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC in shell mode by disabling shell mode" time="0.108097841">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC when completion suggestions are showing" time="0.109306113">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not call onEscapePromptChange when not provided" time="0.107347924">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not interfere with existing keyboard shortcuts" time="0.15891352">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; invokes reverse search on Ctrl+R" time="0.107514442">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; resets reverse search state on Escape" time="0.158115185">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; completes the highlighted entry on Tab and exits reverse-search" time="0.066623404">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; submits the highlighted entry on Enter and exits reverse-search" time="0.063963047">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; text and cursor position should be restored after reverse search" time="0.108643669">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line in multiline input" time="0.106699636">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line for single line input" time="0.107282234">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/LoadingIndicator.test.tsx" timestamp="2025-10-17T11:01:41.472Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.071817442">
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should not render when streamingState is Idle" time="0.017876948">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner, phrase, and time when streamingState is Responding" time="0.012937098">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner (static), phrase but no time/cancel when streamingState is WaitingForConfirmation" time="0.002478941">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the currentLoadingPhrase correctly" time="0.001899871">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly when Responding" time="0.001691867">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly in human-readable format" time="0.001539265">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render rightContent when provided" time="0.001595609">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should transition correctly between states using rerender" time="0.006994487">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display fallback phrase if thought is empty" time="0.004066054">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the subject of a thought" time="0.002648555">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should prioritize thought.subject over currentLoadingPhrase" time="0.002522953">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on a single line on a wide terminal" time="0.002779617">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on multiple lines on a narrow terminal" time="0.004652638">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use wide layout at 80 columns" time="0.003345944">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use narrow layout at 79 columns" time="0.002546806">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSelectionDialog.test.tsx" timestamp="2025-10-17T11:01:41.473Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.114328995">
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should setup escape key handler to call onCancel" time="0.038119747">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should not call onCancel for non-escape keys" time="0.007110851">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set correct initial index for current model" time="0.009553826">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set initial index to 0 when current model is not found" time="0.0061744">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should call onSelect when a model is selected" time="0.006516523">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle empty models array" time="0.006230404">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should create correct option items with proper labels" time="0.004749247">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show vision indicator for vision models" time="0.00533009">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show current indicator for the current model" time="0.008688396">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.009912659">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle multiple onSelect calls correctly" time="0.009833824">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelStatsDisplay.test.tsx" timestamp="2025-10-17T11:01:41.473Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.116552104">
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should render &quot;no API calls&quot; message when there are no active models" time="0.028509577">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should not display conditional rows if no model has data for them" time="0.021416829">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display conditional rows if at least one model has data" time="0.020021881">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display stats for multiple models correctly" time="0.015510835">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.013984674">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display a single model correctly" time="0.014021312">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSwitchDialog.test.tsx" timestamp="2025-10-17T11:01:41.473Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.112765977">
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup RadioButtonSelect with correct options" time="0.036608986">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect when an option is selected" time="0.011518848">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with SwitchSessionToVL when second option is selected" time="0.007688759">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with ContinueWithCurrentModel when third option is selected" time="0.007251261">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup escape key handler to call onSelect with ContinueWithCurrentModel" time="0.007670666">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should not call onSelect for non-escape keys" time="0.006520981">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should set initial index to 0 (first option)" time="0.011709961">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; VisionSwitchOutcome enum &gt; should have correct enum values" time="0.000324961">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle multiple onSelect calls correctly" time="0.007782803">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.006645982">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle escape key multiple times" time="0.006614985">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/OpenAIKeyPrompt.test.tsx" timestamp="2025-10-17T11:01:41.473Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.115266398">
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should render the prompt correctly" time="0.042064708">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should show the component with proper styling" time="0.010116205">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should handle paste with control characters" time="0.061753574">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/QwenOAuthProgress.test.tsx" timestamp="2025-10-17T11:01:41.474Z" hostname="uby" tests="22" failures="0" errors="0" skipped="0" time="0.243778585">
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state when deviceAuth is not provided" time="0.043070035">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state with gray border" time="0.007243556">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should render authentication flow when deviceAuth is provided" time="0.007898457">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should display correct URL in Static component when QR code is generated" time="0.016593997">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format time correctly" time="0.003907792">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format single digit seconds with leading zero" time="0.003451118">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should countdown and call onTimeout when timer expires" time="0.016106044">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should update time remaining display" time="0.007633407">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should use default 300 second timeout when deviceAuth is null" time="0.004349668">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Animated dots &gt; should cycle through animated dots" time="0.029126848">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should generate QR code when deviceAuth is provided" time="0.006108659">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should display QR code in Static component when available" time="0.012593904">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should handle QR code generation errors gracefully" time="0.00538926">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should not generate QR code when deviceAuth is null" time="0.003499657">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC key is pressed" time="0.011436004">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC is pressed in loading state" time="0.005337093">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should not call onCancel for other key presses" time="0.005330341">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should display initial timer value from deviceAuth" time="0.004249864">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should reset to loading state when deviceAuth becomes null" time="0.009377891">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render timeout state when authStatus is timeout" time="0.00416121">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render default timeout message when no authMessage provided" time="0.006358952">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should call onCancel for any key press in timeout state" time="0.028082969">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SessionSummaryDisplay.test.tsx" timestamp="2025-10-17T11:01:41.474Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.064648563">
        <testcase classname="src/ui/components/SessionSummaryDisplay.test.tsx" name="&lt;SessionSummaryDisplay /&gt; &gt; renders the summary display with a title" time="0.063333143">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SettingsDialog.test.tsx" timestamp="2025-10-17T11:01:41.474Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="src/ui/components/SettingsDialog.test.tsx" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/ui/components/SettingsDialog.tsx:11:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ShellConfirmationDialog.test.tsx" timestamp="2025-10-17T11:01:41.475Z" hostname="uby" tests="4" failures="4" errors="0" skipped="0" time="0.552113143">
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; renders correctly" time="0.440391736">
            <failure message="Snapshot `ShellConfirmationDialog &gt; renders correctly 1` mismatched" type="Error">
Error: Snapshot `ShellConfirmationDialog &gt; renders correctly 1` mismatched

- Expected
+ Received

- &quot; ╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
-  │                                                                                                  │
+ &quot;
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
-  │ Shell Command Execution                                                                          │
-  │ A custom command wants to run the following shell commands:                                      │
-  │                                                                                                  │
-  │ ╭──────────────────────────────────────────────────────────────────────────────────────────────╮ │
-  │ │ ls -la                                                                                       │ │
-  │ │ echo &quot;hello&quot;                                                                                 │ │
-  │ ╰──────────────────────────────────────────────────────────────────────────────────────────────╯ │
-  │                                                                                                  │
-  │ Do you want to proceed?                                                                          │
+  - ShellConfirmationDialog (src/ui/components/ShellConfirmationDialog.tsx:55:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
-  │                                                                                                  │
-  │ ● 1. Yes, allow once                                                                             │
-  │   2. Yes, allow always for this session                                                          │
-  │   3. No (esc)                                                                                    │
-  │                                                                                                  │
-  ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯&quot;
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+ &quot;

 ❯ src/ui/components/ShellConfirmationDialog.test.tsx:23:25
            </failure>
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedOnce when &quot;Yes, allow once&quot; is selected" time="0.032317013">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow once&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow once&apos;

- Expected
+ Received

- Yes, allow once
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ShellConfirmationDialog (src/ui/components/ShellConfirmationDialog.tsx:55:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/ShellConfirmationDialog.test.tsx:33:20
            </failure>
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedAlways when &quot;Yes, allow always for this session&quot; is selected" time="0.027181262">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always for this session&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always for this session&apos;

- Expected
+ Received

- Yes, allow always for this session
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ShellConfirmationDialog (src/ui/components/ShellConfirmationDialog.tsx:55:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/ShellConfirmationDialog.test.tsx:42:20
            </failure>
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with Cancel when &quot;No (esc)&quot; is selected" time="0.050693815">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;No (esc)&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;No (esc)&apos;

- Expected
+ Received

- No (esc)
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ShellConfirmationDialog (src/ui/components/ShellConfirmationDialog.tsx:55:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/ShellConfirmationDialog.test.tsx:51:20
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/StatsDisplay.test.tsx" timestamp="2025-10-17T11:01:41.475Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.173386777">
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders only the Performance section in its zero state" time="0.036061504">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders a table with two models correctly" time="0.021566816">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders all sections when all data is present" time="0.01558433">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides User Agreement when no decisions are made" time="0.012210435">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides Efficiency section when cache is not used" time="0.013381269">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in green for high values" time="0.015531072">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in yellow for medium values" time="0.009210792">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in red for low values" time="0.006740877">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; displays Code Changes when line counts are present" time="0.008405424">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; hides Code Changes when no lines are added or removed" time="0.010478164">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the default title when no title prop is provided" time="0.007430151">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the custom title when a title prop is provided" time="0.014619798">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/TodoDisplay.test.tsx" timestamp="2025-10-17T11:01:41.476Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.051532875">
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render todo list" time="0.028192731">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should display correct status icons" time="0.006521923">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle empty todo list" time="0.001228139">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle undefined todos" time="0.000862274">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with different statuses" time="0.006875586">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with mixed statuses" time="0.006161557">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ToolStatsDisplay.test.tsx" timestamp="2025-10-17T11:01:41.476Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.09717762">
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should render &quot;no tool calls&quot; message when there are no active tools" time="0.031077703">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for a single tool correctly" time="0.022166204">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for multiple tools correctly" time="0.014839825">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.014469471">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle zero decisions gracefully" time="0.01292708">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/color-utils.test.ts" timestamp="2025-10-17T11:01:41.476Z" hostname="uby" tests="16" failures="0" errors="0" skipped="0" time="0.00742945">
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate hex colors" time="0.001792693">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names" time="0.000441646">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names case insensitive" time="0.000133466">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names" time="0.000171958">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names case insensitive" time="0.000085197">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should reject invalid color names" time="0.00007018">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve hex colors" time="0.000176126">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve Ink-supported color names" time="0.0001676">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve CSS color names to hex" time="0.000175484">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should handle case insensitive color names" time="0.000072403">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should return undefined for invalid colors" time="0.001123086">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should contain expected CSS color mappings" time="0.000150598">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should not contain Ink-supported color names" time="0.000081901">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should contain all Ink-supported color names" time="0.000253559">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should not contain CSS color names" time="0.000078174">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; Consistency between validation and resolution &gt; should have consistent behavior between isValidColor and resolveColor" time="0.00082785">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme-manager.test.ts" timestamp="2025-10-17T11:01:41.477Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.025678575">
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should load valid custom themes" time="0.002975739">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get the active theme" time="0.000880928">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get a custom active theme" time="0.000624795">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return false when setting a non-existent theme" time="0.000407674">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should list available themes including custom themes" time="0.008695279">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should get a theme by name" time="0.001025445">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should fall back to default theme if active theme is invalid" time="0.000816158">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return NoColorTheme if NO_COLOR is set" time="0.001142081">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should load a theme from a valid file path" time="0.003538179">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme if the file does not exist" time="0.001983817">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from a file with invalid JSON" time="0.00103363">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from an untrusted file path and log a message" time="0.001061531">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme.test.ts" timestamp="2025-10-17T11:01:41.477Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.004730252">
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a valid theme" time="0.001612751">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with an invalid name" time="0.000380733">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a theme missing optional DiffAdded and DiffRemoved colors" time="0.000144196">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with a very long name" time="0.000119611">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="themeManager.loadCustomThemes &gt; should use values from DEFAULT_THEME when DiffAdded and DiffRemoved are not provided" time="0.000902699">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/atCommandProcessor.test.ts" timestamp="2025-10-17T11:01:41.477Z" hostname="uby" tests="39" failures="39" errors="0" skipped="0" time="0.025474398">
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through query if no @ command is present" time="0.009499005">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through original query if only a lone @ symbol is present" time="0.000845713">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid text file path" time="0.00044932">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid directory path and convert to glob" time="0.000387977">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle query with text before and after @command" time="0.000402243">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should correctly unescape paths with escaped spaces" time="0.000365465">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references" time="0.000338746">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references with interleaved text" time="0.000424956">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle a mix of valid, invalid, and lone @ references" time="0.000441746">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should return original query if all @paths are invalid or lone @" time="0.000613033">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should skip git-ignored files in @ commands" time="0.000380664">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should process non-git-ignored files normally" time="0.000358132">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should handle mixed git-ignored and valid files" time="0.000353363">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should always ignore .git directory files" time="0.000346721">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; when recursive file search is disabled &gt; should not use glob search for a nonexistent file" time="0.000377327">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; gemini-ignore filtering &gt; should skip gemini-ignored files in @ commands" time="0.000312056">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process non-ignored files when .qwenignore is present" time="0.000368792">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle mixed gemini-ignored and valid files" time="0.000376857">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;comma&apos;" time="0.000301327">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;period&apos;" time="0.00028147">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;semicolon&apos;" time="0.000313389">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;exclamation mark&apos;" time="0.000529117">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;question mark&apos;" time="0.000385944">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening parenthesis&apos;" time="0.000318418">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing parenthesis&apos;" time="0.000293212">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening square bracket&apos;" time="0.000363361">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing square bracket&apos;" time="0.000356038">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening curly brace&apos;" time="0.000361297">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing curly brace&apos;" time="0.000377688">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle multiple @paths terminated by different punctuation" time="0.000292741">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should still handle escaped spaces in paths before punctuation" time="0.000323448">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not break file paths with periods in extensions" time="0.00038965">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle file paths ending with period followed by space" time="0.000282362">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle comma termination with complex file paths" time="0.000255722">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not terminate at period within file name" time="0.000423883">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle end of string termination for period and comma" time="0.000333747">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle files with special characters in names" time="0.000276831">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle basic file names without special characters" time="0.000308179">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should not add the user&apos;s turn to history, as that is the caller&apos;s responsibility" time="0.000495004">
            <failure message="[vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;ToolRegistry&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/atCommandProcessor.test.ts:85:26
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/shellCommandProcessor.test.ts" timestamp="2025-10-17T11:01:41.485Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.062302769">
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should initiate command execution and set pending state" time="0.021781313">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle successful execution and update history correctly" time="0.00483737">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command failure and display error status" time="0.003497724">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should throttle pending UI updates for text streams" time="0.004749848">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should show binary progress messages correctly" time="0.004977138">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should not wrap the command on Windows" time="0.002619962">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command abort and display cancelled status" time="0.003627324">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle binary output result correctly" time="0.002733642">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle promise rejection and show an error" time="0.00437771">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle synchronous errors during execution and clean up resources" time="0.001888169">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should show a warning if the working directory changes" time="0.001908046">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should NOT show a warning if the directory does not change" time="0.003099649">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/slashCommandProcessor.test.ts" timestamp="2025-10-17T11:01:41.485Z" hostname="uby" tests="35" failures="0" errors="0" skipped="0" time="2.044489778">
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should initialize CommandService with all required loaders" time="0.020391444">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should call loadCommands and populate state after mounting" time="0.060641028">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should provide an immutable array of commands to consumers" time="0.059780317">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should override built-in commands with file-based commands of the same name" time="0.057868915">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display an error for an unknown command" time="0.005858136">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display help for a parent command invoked without a subcommand" time="0.055167803">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should correctly find and execute a nested subcommand" time="0.056974101">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the the input is not a command" time="0.003095631">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the command has an error" time="0.003377442">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should set isProcessing to true during execution and false afterwards" time="0.10802745">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: theme&quot; action" time="0.058605987">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: model&quot; action" time="0.055775265">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;load_history&quot; action" time="0.056498833">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should handle a &quot;quit&quot; action" time="0.059550352">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should call runExitCleanup when handling a &quot;quit&quot; action" time="0.056002335">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a file-based command" time="0.055527076">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a mcp-based command" time="0.056117147">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should set confirmation request when action returns confirm_shell_commands" time="0.107349307">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should do nothing if user cancels confirmation" time="0.111854583">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command with one-time allowlist on &quot;Proceed Once&quot;" time="0.111511489">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command and update session allowlist on &quot;Proceed Always&quot;" time="0.114499231">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should be case-sensitive" time="0.060807225">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should correctly match an altName" time="0.057261652">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle extra whitespace around the command" time="0.060753797">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle `?` as a command prefix" time="0.056591604">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should override mcp-based commands with file-based commands of the same name" time="0.058001279">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should prioritize a command with a primary name over a command with a matching alias" time="0.058745505">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should add an overridden command to the history" time="0.056276301">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Lifecycle &gt; should abort command loading when the hook unmounts" time="0.00391783">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a simple slash command" time="0.056843048">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs nothing for a bogus command" time="0.057674836">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs a failure event for a failed command" time="0.063011087">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a slash command with a subcommand" time="0.05891606">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log the command path when an alias is used" time="0.059605334">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should not log for unknown commands" time="0.058396129">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAtCompletion.test.ts" timestamp="2025-10-17T11:01:41.486Z" hostname="uby" tests="13" failures="13" errors="0" skipped="0" time="9.117960713">
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should perform a recursive search for an empty pattern" time="1.046672681">
            <failure message="expected 0 to be greater than 0

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected 0 to be greater than 0

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;
 ❯ src/ui/hooks/useAtCompletion.test.ts:80:51
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should correctly filter the recursive list based on a pattern" time="1.010407713">
            <failure message="expected 0 to be greater than 0

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected 0 to be greater than 0

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;
 ❯ src/ui/hooks/useAtCompletion.test.ts:110:51
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should append a trailing slash to directory paths in suggestions" time="1.008503354">
            <failure message="expected 0 to be greater than 0

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected 0 to be greater than 0

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;
 ❯ src/ui/hooks/useAtCompletion.test.ts:133:51
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should be in a loading state during initial file system crawl" time="0.007663102">
            <failure message="expected false to be true // Object.is equality" type="AssertionError">
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 ❯ src/ui/hooks/useAtCompletion.test.ts:151:51
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should NOT show a loading indicator for subsequent searches that complete under 200ms" time="1.016296166">
            <failure message="expected [] to deeply equal [ &apos;a.txt&apos; ]

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected [] to deeply equal [ &apos;a.txt&apos; ]

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;

- Expected
+ Received

- [
-   &quot;a.txt&quot;,
- ]
+ []

 ❯ src/ui/hooks/useAtCompletion.test.ts:170:64
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should show a loading indicator and clear old suggestions for subsequent searches that take longer than 200ms" time="0.002622326">
            <failure message="[vitest] No &quot;FileSearchFactory&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;FileSearchFactory&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/useAtCompletion.test.ts:192:30
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should abort the previous search when a new one starts" time="0.002080795">
            <failure message="[vitest] No &quot;FileSearchFactory&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;FileSearchFactory&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/useAtCompletion.test.ts:274:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in a READY state" time="1.005553334">
            <failure message="expected [] to deeply equal [ &apos;a.txt&apos; ]

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected [] to deeply equal [ &apos;a.txt&apos; ]

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;

- Expected
+ Received

- [
-   &quot;a.txt&quot;,
- ]
+ []

 ❯ src/ui/hooks/useAtCompletion.test.ts:327:64
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in an ERROR state" time="0.001630884">
            <failure message="[vitest] No &quot;FileSearchFactory&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;FileSearchFactory&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/ui/hooks/useAtCompletion.test.ts:349:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should respect .gitignore files" time="1.00361362">
            <failure message="expected 0 to be greater than 0

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected 0 to be greater than 0

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;
 ❯ src/ui/hooks/useAtCompletion.test.ts:390:51
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should work correctly when config is undefined" time="1.003474113">
            <failure message="expected 0 to be greater than 0

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected 0 to be greater than 0

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;
 ❯ src/ui/hooks/useAtCompletion.test.ts:411:51
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should reset and re-initialize when the cwd changes" time="1.003349062">
            <failure message="expected [] to deeply equal [ &apos;file1.txt&apos; ]

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected [] to deeply equal [ &apos;file1.txt&apos; ]

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;

- Expected
+ Received

- [
-   &quot;file1.txt&quot;,
- ]
+ []

 ❯ src/ui/hooks/useAtCompletion.test.ts:439:64
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should perform a non-recursive search when enableRecursiveFileSearch is false" time="1.003463295">
            <failure message="expected 0 to be greater than 0

Ignored nodes: comments, script, style
[36m&lt;html&gt;[39m
  [36m&lt;head /&gt;[39m
  [36m&lt;body&gt;[39m
    [36m&lt;div /&gt;[39m
  [36m&lt;/body&gt;[39m
[36m&lt;/html&gt;[39m" type="AssertionError">
AssertionError: expected 0 to be greater than 0

Ignored nodes: comments, script, style
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div /&gt;
  &lt;/body&gt;
&lt;/html&gt;
 ❯ src/ui/hooks/useAtCompletion.test.ts:495:51
 ❯ runWithExpensiveErrorDiagnosticsDisabled node_modules/@testing-library/dom/dist/config.js:47:12
 ❯ checkCallback node_modules/@testing-library/dom/dist/wait-for.js:124:77
 ❯ Timeout.checkRealTimersCallback node_modules/@testing-library/dom/dist/wait-for.js:118:16
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAutoAcceptIndicator.test.ts" timestamp="2025-10-17T11:01:41.488Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.045653981">
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.AUTO_EDIT if config.getApprovalMode returns ApprovalMode.AUTO_EDIT" time="0.014120145">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.DEFAULT if config.getApprovalMode returns ApprovalMode.DEFAULT" time="0.001947649">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.YOLO if config.getApprovalMode returns ApprovalMode.YOLO" time="0.001668053">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.PLAN if config.getApprovalMode returns ApprovalMode.PLAN" time="0.002488919">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should cycle approval modes when Shift+Tab is pressed" time="0.006630594">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should not toggle if only one key or other keys combinations are pressed" time="0.003948226">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should update indicator when config value changes externally (useEffect dependency)" time="0.003118514">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from DEFAULT to AUTO_EDIT" time="0.004082134">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from AUTO_EDIT to YOLO" time="0.003048224">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should cycle from YOLO to PLAN when Shift+Tab is pressed" time="0.002428769">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useCommandCompletion.test.ts" timestamp="2025-10-17T11:01:41.488Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.115400085">
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.033085464">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when completion mode becomes IDLE" time="0.01757492">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset all state to default values" time="0.003574656">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should call useAtCompletion with the correct query for an escaped space" time="0.004538547">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should correctly identify the completion context with multiple @ symbols" time="0.003926978">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.001702737">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.00174244">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.003534131">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.00573061">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.008291703">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should automatically select the first item when suggestions are available" time="0.003972812">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a partial command" time="0.004752513">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path" time="0.004155029">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path when cursor is not at the end of the line" time="0.00451817">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for line comments" time="0.002679322">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for block comments" time="0.002268963">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should trigger prompt completion for regular text when enabled" time="0.002354792">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useConsoleMessages.test.ts" timestamp="2025-10-17T11:01:41.489Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.058487147">
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should initialize with an empty array of console messages" time="0.022822978">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should add a new message when log is called" time="0.006486738">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should batch and count identical consecutive messages" time="0.005635004">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should not batch different messages" time="0.004730973">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear all messages when clearConsoleMessages is called" time="0.010563412">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear the pending timeout when clearConsoleMessages is called" time="0.003969426">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clean up the timeout on unmount" time="0.002102175">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useEditorSettings.test.ts" timestamp="2025-10-17T11:01:41.489Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.062773508">
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should initialize with dialog closed" time="0.020303852">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should open editor dialog when openEditorDialog is called" time="0.004680169">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should close editor dialog when exitEditorDialog is called" time="0.00489737">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle editor selection successfully" time="0.008346955">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle clearing editor preference (undefined editor)" time="0.005672393">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different editor types" time="0.004509153">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different setting scopes" time="0.002647363">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for unavailable editors" time="0.002910749">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for editors not allowed in sandbox" time="0.003716629">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle errors during editor selection" time="0.002516641">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFocus.test.ts" timestamp="2025-10-17T11:01:41.490Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.033168557">
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should initialize with focus and enable focus reporting" time="0.017735516">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to false when a focus-out event is received" time="0.004151582">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to true when a focus-in event is received" time="0.003813658">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should clean up and disable focus reporting on unmount" time="0.002369028">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should handle multiple focus events correctly" time="0.002950432">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFolderTrust.test.ts" timestamp="2025-10-17T11:01:41.490Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.041295786">
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already trusted" time="0.020463207">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already untrusted" time="0.003521077">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should open dialog when folder trust is undefined" time="0.002660547">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_FOLDER choice" time="0.003155963">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_PARENT choice" time="0.002297556">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle DO_NOT_TRUST choice and trigger restart" time="0.001590869">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should do nothing for default choice" time="0.001633338">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should set isRestarting to true when trust status changes from false to true" time="0.001712195">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not set isRestarting to true when trust status does not change" time="0.002382123">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGeminiStream.test.tsx" timestamp="2025-10-17T11:01:41.490Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.511522669">
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not submit tool responses if not all tool calls are completed" time="0.020106748">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should submit tool responses when all tool calls are completed and ready" time="0.012971392">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should handle all tool calls being cancelled" time="0.005105906">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should group multiple cancelled tool call responses into a single history entry" time="0.005334538">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not flicker streaming state to Idle between tool completion and submission" time="0.007976571">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should cancel an in-progress stream when escape is pressed" time="0.010630336">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should call onCancelSubmit handler when escape is pressed" time="0.005088905">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not do anything if escape is pressed when not responding" time="0.003711439">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should prevent further processing after cancellation" time="0.058352248">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not cancel if a tool call is in progress (not just responding)" time="0.003331277">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should schedule a tool call when the command processor returns a schedule_tool action" time="0.005077743">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should stop processing and not call Gemini when a command is handled without a tool call" time="0.004449654">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should call Gemini with prompt content when slash command returns a `submit_prompt` action" time="0.004796153">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should correctly handle a submit_prompt action with empty content" time="0.005139258">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for line comments" time="0.004885438">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for block comments" time="0.003643614">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Memory Refresh on save_memory &gt; should call performMemoryRefresh when a save_memory tool call completes successfully" time="0.004153476">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Error Handling &gt; should call parseAndFormatApiError with the correct authType on stream initialization failure" time="0.004033504">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add info message for MAX_TOKENS finish reason" time="0.004818725">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for STOP finish reason" time="0.106876133">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for FINISH_REASON_UNSPECIFIED" time="0.105439648">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add appropriate messages for other finish reasons" time="0.041452376">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should process @include commands, adding user turn after processing to prevent race conditions" time="0.005478715">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when starting a new prompt" time="0.00817608">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when user cancels" time="0.006089603">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when there is an error" time="0.005950918">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should prevent concurrent submitQuery calls" time="0.015234083">
            <system-err>
You called act(async () =&gt; ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () =&gt; ...);

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should allow subsequent calls after first call completes" time="0.005546931">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should reset execution flag even when query preparation fails" time="0.005590151">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should call handleVisionSwitch and proceed to send when allowed" time="0.006346228">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should gate submission when handleVisionSwitch returns shouldProceed=false" time="0.0071161">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model after successful stream completion" time="0.008451759">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model when an error occurs during streaming" time="0.005569392">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGitBranchName.test.ts" timestamp="2025-10-17T11:01:41.491Z" hostname="uby" tests="7" failures="0" errors="0" skipped="2" time="0.040215881">
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return branch name" time="0.022673081">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if git command fails" time="0.003359408">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return short commit hash if branch is HEAD (detached state)" time="0.006198756">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if branch is HEAD and getting commit hash fails" time="0.002822616">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should update branch name when .git/HEAD changes" time="0.000644371">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should handle watcher setup error silently" time="0.002727351">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should cleanup watcher on unmount" time="0.000413314">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useHistoryManager.test.ts" timestamp="2025-10-17T11:01:41.491Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.039683657">
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should initialize with an empty history" time="0.015407974">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add an item to history with a unique ID" time="0.005106337">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should generate unique IDs for items added with the same base timestamp" time="0.003342507">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should update an existing history item" time="0.002709337">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not change history if updateHistoryItem is called with a nonexistent ID" time="0.005350869">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should clear the history" time="0.001950214">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not add consecutive duplicate user messages" time="0.002390919">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add duplicate user messages if they are not consecutive" time="0.001455009">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useInputHistory.test.ts" timestamp="2025-10-17T11:01:41.492Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.032457924">
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; should initialize with historyIndex -1 and empty originalQueryBeforeNav" time="0.013527901">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should call onSubmit with trimmed value and reset history" time="0.003346194">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should not call onSubmit if value is empty after trimming" time="0.001975882">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if isActive is false" time="0.002592481">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if userMessages is empty" time="0.001483622">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should call onChange with the last message when navigating up from initial state" time="0.001849589">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should store currentQuery as originalQueryBeforeNav on first navigateUp" time="0.001130349">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should navigate through history messages on subsequent navigateUp calls" time="0.001284634">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if isActive is false" time="0.00134754">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if historyIndex is -1 (not in history navigation)" time="0.000869096">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should restore originalQueryBeforeNav when navigating down to initial state" time="0.000975442">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useKeypress.test.ts" timestamp="2025-10-17T11:01:41.492Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.078822218">
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should not listen if isActive is false" time="0.021009126">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;a&apos;" time="0.005549225">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;left&apos;" time="0.003798981">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;right&apos;" time="0.003496071">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;up&apos;" time="0.002623519">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;down&apos;" time="0.001757158">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should set and release raw mode" time="0.002171373">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should stop listening after being unmounted" time="0.001580351">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should correctly identify alt+enter (meta key)" time="0.001671279">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should process a paste as a single event" time="0.010765345">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should handle keypress interspersed with pastes" time="0.007182934">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.002112764">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should process a paste as a single event" time="0.003563275">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should handle keypress interspersed with pastes" time="0.006108839">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.002031494">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useLoadingIndicator.test.ts" timestamp="2025-10-17T11:01:41.493Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.043671107">
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should initialize with default values when Idle" time="0.016772667">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reflect values when Responding" time="0.008791537">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should show waiting phrase and retain elapsedTime when WaitingForConfirmation" time="0.006624843">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset elapsedTime and use a witty phrase when transitioning from WaitingForConfirmation to Responding" time="0.005181966">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset timer and phrase when streamingState changes from Responding to Idle" time="0.004126045">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useMessageQueue.test.ts" timestamp="2025-10-17T11:01:41.493Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.049253673">
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should initialize with empty queue" time="0.02239623">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should add messages to queue" time="0.004758924">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should filter out empty messages" time="0.003131487">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should clear queue" time="0.003311139">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should return queued messages as text with double newlines" time="0.002777543">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should auto-submit queued messages when transitioning to Idle" time="0.003079651">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when queue is empty" time="0.002431113">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when not transitioning to Idle" time="0.001950545">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should handle multiple state transitions correctly" time="0.003025221">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePhraseCycler.test.ts" timestamp="2025-10-17T11:01:41.493Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.046536693">
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should initialize with the first witty phrase when not active and not waiting" time="0.019445116">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should show &quot;Waiting for user confirmation...&quot; when isWaiting is true" time="0.00499992">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should not cycle phrases if isActive is false and not waiting" time="0.003468049">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should cycle through witty phrases when isActive is true and not waiting" time="0.005376255">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when isActive becomes true after being false (and not waiting)" time="0.005921143">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should clear phrase interval on unmount when active" time="0.002168728">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when transitioning from waiting to active" time="0.00310598">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePrivacySettings.test.ts" timestamp="2025-10-17T11:01:41.493Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.296602416">
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle LoggingContentGenerator wrapper correctly and not throw &quot;Oauth not being used&quot; error" time="0.067814114">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should work with direct CodeAssistServer (no wrapper)" time="0.057266872">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle paid tier users correctly" time="0.05447361">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when content generator is not a CodeAssistServer" time="0.003669662">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when CodeAssistServer has no projectId" time="0.002973716">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should update data collection opt-in setting" time="0.108810107">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useQwenAuth.test.ts" timestamp="2025-10-17T11:01:41.493Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.05143804">
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when not Qwen auth" time="0.016594417">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when Qwen auth but not authenticating" time="0.002193183">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set up event listeners when Qwen auth and authenticating" time="0.003823316">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle device auth event" time="0.002600576">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - success" time="0.002518554">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - error" time="0.001492759">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - polling" time="0.001514259">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - rate_limit" time="0.001931479">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event without message" time="0.001875757">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when auth type changes" time="0.002195978">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when authentication stops" time="0.002609592">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners on unmount" time="0.0017046">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when switching from Qwen auth to another auth type" time="0.001702486">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when authentication stops" time="0.001548401">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle cancelQwenAuth function" time="0.001445301">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should maintain isQwenAuth flag correctly" time="0.002710168">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set isQwenAuthenticating to true when starting authentication with Qwen auth" time="0.001032859">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useReverseSearchCompletion.test.tsx" timestamp="2025-10-17T11:01:41.494Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.043037956">
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.020985562">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when reverseSearchActive becomes false" time="0.00372265">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.00161261">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.002209954">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.003419569">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.001675387">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.001856611">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with large suggestion lists and scrolling" time="0.002544803">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; filters history by buffer.text and sets showSuggestions" time="0.001362869">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; hides suggestions when there are no matches" time="0.001513998">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useShellHistory.test.ts" timestamp="2025-10-17T11:01:41.494Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.562722789">
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should initialize and read the history file from the correct path" time="0.067524528">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should handle a nonexistent history file gracefully" time="0.054780708">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should add a command and write to the history file" time="0.105964868">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should navigate history correctly with previous/next commands" time="0.056702799">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should not add empty or whitespace-only commands to history" time="0.05690322">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should truncate history to MAX_HISTORY_LENGTH (100)" time="0.109698087">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should move an existing command to the top when re-added" time="0.109209254">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useSlashCompletion.test.ts" timestamp="2025-10-17T11:01:41.495Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.045130693">
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest all top-level commands for the root slash" time="0.012428158">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should filter commands based on partial input" time="0.002320749">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest commands based on partial altNames" time="0.003194774">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should NOT provide suggestions for a perfectly typed command that is a leaf node" time="0.002945374">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.001533905">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.001008694">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for a fully typed command that has no sub-commands or argument completion" time="0.000900815">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for an unknown command" time="0.001263736">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest sub-commands for a parent command" time="0.001018813">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest all sub-commands when the query ends with the parent command and a space" time="0.000865119">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should filter sub-commands by prefix" time="0.000743964">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should provide no suggestions for an invalid sub-command" time="0.000791363">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call the command.completion function for argument suggestions" time="0.006601591">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call command.completion with an empty string when args start with a space" time="0.004656836">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should handle completion function that returns null" time="0.003138339">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useTimer.test.ts" timestamp="2025-10-17T11:01:41.495Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.05129693">
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should initialize with 0" time="0.019559026">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should not increment time if isActive is false" time="0.00298153">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should increment time every second if isActive is true" time="0.007057793">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 and start incrementing when isActive becomes true from false" time="0.004020089">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 when resetKey changes while active" time="0.006225625">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should be 0 if isActive is false, regardless of resetKey changes" time="0.002598172">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should clear timer on unmount" time="0.00326814">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should preserve elapsedTime when isActive becomes false, and reset to 0 when it becomes active again" time="0.003384435">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useToolScheduler.test.ts" timestamp="2025-10-17T11:01:41.495Z" hostname="uby" tests="21" failures="0" errors="0" skipped="4" time="0.058917873">
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler in YOLO Mode &gt; should skip confirmation and execute tool directly when yoloMode is true" time="0.031152922">
            <system-out>
[Tool] Starting: mockToolRequiresConfirmation (yoloCall...)
[Tool] Args: {
  &quot;data&quot;: &quot;any data&quot;
}

[Tool] Completed: mockToolRequiresConfirmation in 0ms
[Tool] Success: mockToolRequiresConfirmation

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; initial state should be empty" time="0.002722211">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute a tool call successfully" time="0.004232241">
            <system-out>
[Tool] Starting: mockTool (call1...)
[Tool] Args: {
  &quot;param&quot;: &quot;value&quot;
}

[Tool] Completed: mockTool in 0ms
[Tool] Success: mockTool

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool not found" time="0.003412417">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during shouldConfirmExecute" time="0.003018028">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during execute" time="0.003074482">
            <system-out>
[Tool] Starting: mockTool (call1...)

[Tool] Exception: mockTool after 0ms - Execution failed

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - approved" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - cancelled by user" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle live output updates" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute multiple tool calls" time="0.005393647">
            <system-out>
[Tool] Starting: tool1 (multi1...)
[Tool] Args: {
  &quot;p&quot;: 1
}
[Tool] Starting: tool2 (multi2...)
[Tool] Args: {
  &quot;p&quot;: 2
}
[Tool] Completed: tool1 in 0ms
[Tool] Success: tool1
[Tool] Completed: tool2 in 0ms
[Tool] Success: tool2

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should throw error if scheduling while already running" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;validating&apos; (validating) correctly" time="0.000797884">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;awaiting_approval&apos; (awaiting_approval) correctly" time="0.00033506">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;scheduled&apos; (scheduled) correctly" time="0.000187937">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing no live output) correctly" time="0.000168772">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing with live output) correctly" time="0.000176516">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;success&apos; (success) correctly" time="0.000175855">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool not found) correctly" time="0.000185643">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool execution failed) correctly" time="0.00016801">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;cancelled&apos; (cancelled) correctly" time="0.00027041">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map an array of ToolCalls correctly" time="0.001180541">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useVisionAutoSwitch.test.ts" timestamp="2025-10-17T11:01:41.496Z" hostname="uby" tests="36" failures="8" errors="0" skipped="0" time="0.098889162">
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH" time="0.001546207">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when current model is already a vision model" time="0.000219686">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist, QWEN_OAUTH, and model is not vision" time="0.000141832">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; detects image when provided as a single Part object (non-array)" time="0.000101859">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts contain no images" time="0.000109282">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts is a plain string" time="0.000107078">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when visionModelPreviewEnabled is false" time="0.000096979">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist in YOLO mode context" time="0.000098102">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when no image parts exist in YOLO mode context" time="0.00014611">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when already using vision model in YOLO mode context" time="0.000122336">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH in YOLO mode context" time="0.000086289">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchOnce to a one-time model override" time="0.000702338">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchSessionToVL to a persistent session model" time="0.00011367">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps ContinueWithCurrentModel to empty result" time="0.000058919">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; getVisionSwitchGuidanceMessage &gt; returns the expected guidance message" time="0.000085268">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true immediately for continuations" time="0.019852919">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when authType is not QWEN_OAUTH" time="0.003290622">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when there are no image parts" time="0.003283618">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; continues with current model when dialog returns empty result" time="0.004284488">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; applies a one-time override and returns originalModel, then restores" time="0.014886411">
            <failure message="expected { shouldProceed: false } to deeply equal { shouldProceed: true, …(1) }" type="AssertionError">
AssertionError: expected { shouldProceed: false } to deeply equal { shouldProceed: true, …(1) }

- Expected
+ Received

  {
-   &quot;originalModel&quot;: &quot;qwen3-coder-plus&quot;,
-   &quot;shouldProceed&quot;: true,
+   &quot;shouldProceed&quot;: false,
  }

 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:352:17
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; persists session model when dialog requests persistence" time="0.005628081">
            <failure message="expected { shouldProceed: false } to deeply equal { shouldProceed: true }" type="AssertionError">
AssertionError: expected { shouldProceed: false } to deeply equal { shouldProceed: true }

- Expected
+ Received

  {
-   &quot;shouldProceed&quot;: true,
+   &quot;shouldProceed&quot;: false,
  }

 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:386:17
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true when dialog returns no special flags" time="0.002756124">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; blocks when dialog throws or is cancelled" time="0.002606577">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when visionModelPreviewEnabled is false" time="0.005479697">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; automatically switches to vision model in YOLO mode without showing dialog" time="0.005280629">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:259:16
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:483:36
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ Proxy.&lt;anonymous&gt; node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:482:13
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when no images are present" time="0.003845767">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when already using vision model" time="0.002810504">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; restores original model after YOLO mode auto-switch" time="0.002560813">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:259:16
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:579:30
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ Proxy.&lt;anonymous&gt; node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:578:13
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when authType is not QWEN_OAUTH" time="0.002444698">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when visionModelPreviewEnabled is false" time="0.002134224">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; handles multiple image formats in YOLO mode" time="0.001890814">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:259:16
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:686:36
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ Proxy.&lt;anonymous&gt; node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:685:13
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should automatically switch once when vlmSwitchMode is &quot;once&quot;" time="0.002043927">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:296:18
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:723:49
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should switch session when vlmSwitchMode is &quot;session&quot;" time="0.001751376">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:310:18
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:759:49
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should continue with current model when vlmSwitchMode is &quot;persist&quot;" time="0.001713937">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to user prompt when vlmSwitchMode is not set" time="0.00248379">
            <failure message="expected false to be true // Object.is equality" type="AssertionError">
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:836:42
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to persist behavior when vlmSwitchMode has invalid value" time="0.001514589">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/vim.test.ts" timestamp="2025-10-17T11:01:41.498Z" hostname="uby" tests="87" failures="0" errors="0" skipped="0" time="0.430175334">
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should start in NORMAL mode" time="0.017723173">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch to INSERT mode with i command" time="0.00543805">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch back to NORMAL mode with Escape" time="0.004187398">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should properly handle escape followed immediately by a command" time="0.00546524">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle h (left movement)" time="0.003034679">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle l (right movement)" time="0.00281967">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle j (down movement)" time="0.003531346">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle k (up movement)" time="0.006930257">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle 0 (move to start of line)" time="0.00620639">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle $ (move to end of line)" time="0.003052782">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle a (append after cursor)" time="0.003112943">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle A (append at end of line)" time="0.00397176">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle o (open line below)" time="0.003302143">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle O (open line above)" time="0.003985465">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle x (delete character)" time="0.003873458">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should move cursor left when deleting last character on line (vim behavior)" time="0.003698094">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle first d key (sets pending state)" time="0.003691923">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should handle count input and return to count 0 after command" time="0.004421451">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should only delete 1 character with x command when no count is specified" time="0.004862736">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should properly initialize vim hook with word movement support" time="0.003925695">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should support vim mode and basic operations across multiple lines" time="0.003905447">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w (next word)" time="0.003313764">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle b (previous word)" time="0.013613087">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle e (end of word)" time="0.003000936">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w when cursor is on the last word" time="0.002403882">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle first c key (sets pending change state)" time="0.002059005">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state on invalid command sequence (df)" time="0.002327862">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state with Escape in NORMAL mode" time="0.00244613">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Disabled vim mode &gt; should not respond to vim commands when disabled" time="0.003002589">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat x command from current cursor position" time="0.003735363">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat dd command from current position" time="0.004163525">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat ce command from current position" time="0.004969434">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cc command from current position" time="0.003932477">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cw command from current position" time="0.004818715">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat D command from current position" time="0.006524377">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat C command from current position" time="0.003901751">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat command after cursor movement" time="0.003829277">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should move cursor to the correct position after exiting INSERT mode with &quot;a&quot;" time="0.005446986">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle ^ (move to first non-whitespace character)" time="0.003269994">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle G without count (go to last line)" time="0.003592119">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle gg (go to first line)" time="0.010726022">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle count with movement commands" time="0.003584054">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete from cursor to start of next word" time="0.005684866">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should actually delete the complete word including trailing space" time="0.005425728">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete word from middle of word correctly" time="0.002035381">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should handle dw at end of line" time="0.001914538">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete multiple words with count" time="0.004081853">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should record command for repeat with dot" time="0.009054213">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.012496073">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should handle count with de" time="0.008264733">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should change from cursor to start of next word and enter INSERT mode" time="0.007339624">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should handle count with cw" time="0.006211018">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should be repeatable with dot" time="0.011714269">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should change from cursor to end of word and enter INSERT mode" time="0.0030359">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should handle count with ce" time="0.004964304">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change entire line and enter INSERT mode" time="0.005234724">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change multiple lines with count" time="0.011332193">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should be repeatable with dot" time="0.007939052">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.00432312">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should handle count with db" time="0.003482516">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should change from cursor to start of previous word and enter INSERT mode" time="0.00475627">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should handle count with cb" time="0.004510265">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending delete state after dw" time="0.004214769">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending change state after cw" time="0.004239776">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending state with escape" time="0.003400504">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should pass escape through when no pending operator is active" time="0.002390688">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should handle escape and clear pending operator" time="0.003551874">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ctrl+r in INSERT mode" time="0.004996013">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ! in INSERT mode when buffer is empty" time="0.00349001">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should handle ! as input in INSERT mode when buffer is not empty" time="0.005103121">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.004201204">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete multiple word ends with count" time="0.003378693">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.003698094">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete multiple words backward with count" time="0.002757696">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should delete from cursor to start of next word" time="0.003794963">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should change multiple words with count" time="0.00393382">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change from cursor to end of current word" time="0.003431281">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change multiple word ends with count" time="0.003952434">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cb (change word backward) &gt; should change from cursor to start of previous word" time="0.003424739">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cc (change line) &gt; should clear the line and place cursor at the start" time="0.003110668">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete the current line" time="0.003269171">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete multiple lines with count" time="0.00399866">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should handle deleting last line" time="0.00551956">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should delete from cursor to end of line" time="0.003539962">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should handle D at end of line" time="0.005452737">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should change from cursor to end of line" time="0.005601592">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should handle C at beginning of line" time="0.011214144">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/MarkdownDisplay.test.tsx" timestamp="2025-10-17T11:01:41.501Z" hostname="uby" tests="1" failures="1" errors="0" skipped="0" time="0">
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="src/ui/utils/MarkdownDisplay.test.tsx" time="0">
            <failure message="[vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;Storage&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ src/config/settings.ts:26:35
 ❯ src/ui/utils/MarkdownDisplay.test.tsx:10:1
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/clipboardUtils.test.ts" timestamp="2025-10-17T11:01:41.501Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.005656855">
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return false on non-macOS platforms" time="0.00145039">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return boolean on macOS" time="0.000305675">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should return null on non-macOS platforms" time="0.000310183">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should handle errors gracefully" time="0.000121404">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should not throw errors" time="0.001624231">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should complete without errors on valid directory" time="0.00035716">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/commandUtils.test.ts" timestamp="2025-10-17T11:01:41.501Z" hostname="uby" tests="26" failures="0" errors="0" skipped="0" time="0.031131954">
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query starts with @" time="0.001472582">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query contains @ preceded by whitespace" time="0.000332525">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when query does not start with @ and has no spaced @" time="0.000190613">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when @ is not preceded by whitespace" time="0.000115764">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return true when query starts with /" time="0.00023283">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false when query does not start with /" time="0.000172759">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for line comments starting with //" time="0.000137765">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for block comments starting with /*" time="0.000111717">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should successfully copy text to clipboard using pbcopy" time="0.001718286">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle pbcopy command failure" time="0.002352959">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle spawn error" time="0.001502156">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle stdin write error" time="0.001370243">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Windows (win32) &gt; should successfully copy text to clipboard using clip" time="0.001492207">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should successfully copy text to clipboard using xclip" time="0.001652484">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should fall back to xsel when xclip fails" time="0.003085201">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should throw error when both xclip and xsel are not found" time="0.003252992">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should emit error when xclip or xsel fail with stderr output (command installed)" time="0.003164238">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on unsupported platform &gt; should throw error for unsupported platform" time="0.000523888">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle command exit without stderr" time="0.001500252">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle empty text" time="0.001381163">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle multiline text" time="0.001300764">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle special characters" time="0.001296677">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on macOS (darwin) &gt; should return open" time="0.000179973">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Windows (win32) &gt; should return start" time="0.000113299">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Linux (linux) &gt; should return xdg-open" time="0.000107839">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on unmatched OS &gt; should return xdg-open" time="0.000866061">
            <system-err>
Unknown platform: unmatched. Attempting to open URLs with: xdg-open.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/computeStats.test.ts" timestamp="2025-10-17T11:01:41.502Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.003701981">
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should return 0 if totalRequests is 0" time="0.001008954">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should calculate the error rate correctly" time="0.000157892">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should return 0 if totalRequests is 0" time="0.000136322">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should calculate the average latency correctly" time="0.000053188">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should return 0 if prompt tokens is 0" time="0.000060422">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should calculate the cache hit rate correctly" time="0.000041918">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should return all zeros for initial empty metrics" time="0.000586003">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate API and tool time percentages" time="0.000183469">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate cache efficiency" time="0.000138937">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate success and agreement rates" time="0.000082332">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should handle division by zero gracefully" time="0.000091329">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly include line counts" time="0.000057506">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/displayUtils.test.ts" timestamp="2025-10-17T11:01:41.502Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.003258532">
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return green for values &gt;= green threshold" time="0.001424533">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return yellow for values &lt; green and &gt;= yellow threshold" time="0.000194399">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return red for values &lt; yellow threshold" time="0.000098912">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return defaultColor for values &lt; yellow threshold when provided" time="0.000076682">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; Threshold Constants &gt; should have the correct values" time="0.000181205">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/formatters.test.ts" timestamp="2025-10-17T11:01:41.503Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.004747915">
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into KB" time="0.001694352">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into MB" time="0.00022735">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into GB" time="0.000124861">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format milliseconds less than a second" time="0.000210879">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration of 0" time="0.000253799">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of seconds" time="0.000084056">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in seconds with one decimal place" time="0.000053599">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of minutes" time="0.000072604">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in minutes and seconds" time="0.000083464">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of hours" time="0.000056093">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours and seconds" time="0.000046957">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours, minutes, and seconds" time="0.000049411">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle large durations" time="0.000044923">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle negative durations" time="0.000043901">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/markdownUtilities.test.ts" timestamp="2025-10-17T11:01:41.503Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.005202484">
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should split at the last double newline if not in a code block" time="0.002490814">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if no safe split point is found" time="0.000251846">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should prioritize splitting at 

 over being at the very end of the string if the end is not in a code block" time="0.000131944">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if the only 

 is inside a code block and the end of content is not" time="0.000265711">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should correctly identify the last 

 even if it is followed by text not in a code block" time="0.000100245">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content is empty" time="0.000087131">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content has no newlines and no code blocks" time="0.00007082">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/updateCheck.test.ts" timestamp="2025-10-17T11:01:41.503Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.015085909">
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null when running from source (DEV=true)" time="0.005252627">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if package.json is missing" time="0.001067803">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if there is no update" time="0.000702358">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return a message if a newer version is available" time="0.001807711">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is the same as the current version" time="0.000552892">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is older than the current version" time="0.000409988">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if fetchInfo rejects" time="0.001495254">
            <system-err>
Failed to check for updates: Error: Timeout

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should handle errors gracefully" time="0.000619465">
            <system-err>
Failed to check for updates: Error: test error

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; nightly updates &gt; should notify for a newer nightly version when current is nightly" time="0.001425785">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/MaxSizedBox.test.tsx" timestamp="2025-10-17T11:01:41.504Z" hostname="uby" tests="21" failures="0" errors="0" skipped="0" time="0.098417089">
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders children without truncation when they fit" time="0.024922037">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines when content exceeds maxHeight" time="0.003935834">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines at the end when content exceeds maxHeight and overflowDirection is bottom" time="0.004019669">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text that exceeds maxWidth" time="0.005035286">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles mixed wrapping and non-wrapping segments" time="0.013259244">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles words longer than maxWidth by splitting them" time="0.006404095">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; does not truncate when maxHeight is undefined" time="0.002780328">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden" time="0.002789265">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden and overflowDirection is bottom" time="0.003483538">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders an empty box for empty children" time="0.001307036">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte unicode characters correctly" time="0.002074835">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte emoji characters correctly" time="0.002425012">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; falls back to an ellipsis when width is extremely small" time="0.001705702">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates long non-wrapping text with ellipsis" time="0.001655089">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates non-wrapping text containing line breaks" time="0.001485605">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates emoji characters correctly with ellipsis" time="0.001343783">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows ellipsis for multiple rows with long non-wrapping text" time="0.003067088">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; accounts for additionalHiddenLinesCount" time="0.003735834">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles React.Fragment as a child" time="0.002216115">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the top" time="0.00436637">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the bottom" time="0.004105027">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/RadioButtonSelect.test.tsx" timestamp="2025-10-17T11:01:41.504Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.339081499">
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list of items and matches snapshot" time="0.042329537">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with the second item selected and matches snapshot" time="0.00826801">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with numbers hidden and matches snapshot" time="0.008509476">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with scroll arrows and matches snapshot" time="0.008882746">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with special theme display and matches snapshot" time="0.00530797">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list with &gt;10 items and matches snapshot" time="0.011734516">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders nothing when no items are provided" time="0.002306252">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; should call onSelect when &quot;enter&quot; is pressed" time="0.00657444">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; when isFocused is false &gt; should not handle any keyboard input" time="0.00633679">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate down with arrow key and select with enter" time="0.059801025">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate up with arrow key and select with enter" time="0.05892695">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate down with arrow key and select with enter" time="0.060456357">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate up with arrow key and select with enter" time="0.056832499">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/text-buffer.test.ts" timestamp="2025-10-17T11:01:41.505Z" hostname="uby" tests="103" failures="3" errors="0" skipped="0" time="0.236789969">
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; should return the initial state if state is undefined" time="0.003892193">
            <system-err>
Unknown action encountered: [object Object]

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should set new text and move cursor to the end" time="0.000734858">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should not create an undo snapshot if pushToUndo is false" time="0.000218254">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a character" time="0.000525191">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a newline" time="0.000246045">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should remove a character" time="0.000217532">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should join lines if at the beginning of a line" time="0.001985609">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; undo/redo actions &gt; should undo and redo a change" time="0.000480729">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; create_undo_snapshot action &gt; should create a snapshot without changing state" time="0.000281851">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with empty text and cursor at (0,0) by default" time="0.020048501">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with provided initialText" time="0.004206393">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with initialText and initialCursorOffset" time="0.003041571">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines" time="0.003974305">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines with multiple spaces" time="0.004038684">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines even without spaces" time="0.002027206">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with multi-byte unicode characters and correct cursor offset" time="0.004778">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert a character and update cursor" time="0.003860785">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert text in the middle of a line" time="0.005340138">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; newline: should create a new line and move cursor" time="0.002884872">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; backspace: should delete char to the left or merge lines" time="0.003587159">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; del: should delete char to the right or merge lines" time="0.002418069">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should prepend @ to a valid file path on insert" time="0.022329786">
            <failure message="[vitest] No &quot;unescapePath&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;unescapePath&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.insert src/ui/components/shared/text-buffer.ts:1538:25
 ❯ src/ui/components/shared/text-buffer.test.ts:432:32
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/components/shared/text-buffer.test.ts:432:7
            </failure>
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to an invalid file path on insert" time="0.003073259">
            <failure message="[vitest] No &quot;unescapePath&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;unescapePath&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.insert src/ui/components/shared/text-buffer.ts:1538:25
 ❯ src/ui/components/shared/text-buffer.test.ts:441:32
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/components/shared/text-buffer.test.ts:441:7
            </failure>
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should handle quoted paths" time="0.002830531">
            <failure message="[vitest] No &quot;unescapePath&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;unescapePath&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;@qwen-code/qwen-code-core&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.insert src/ui/components/shared/text-buffer.ts:1538:25
 ❯ src/ui/components/shared/text-buffer.test.ts:450:32
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/components/shared/text-buffer.test.ts:450:7
            </failure>
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to short text that is not a path" time="0.006603163">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to valid file paths when shellModeActive is true" time="0.002980388">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to quoted paths when shellModeActive is true" time="0.002156115">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with invalid paths when shellModeActive is true" time="0.001697327">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with short text when shellModeActive is true" time="0.001164352">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: left/right should work within and across visual lines (due to wrapping)" time="0.004040166">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: up/down should preserve preferred visual column" time="0.003691462">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: home/end should go to visual line start/end" time="0.003754589">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should wrap long lines correctly into visualLines" time="0.004083647">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should update visualScrollRow when visualCursor moves out of viewport" time="0.006105804">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo an insert operation" time="0.002514977">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo a newline operation" time="0.002027547">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; insert: should correctly handle multi-byte unicode characters" time="0.001856611">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; backspace: should correctly delete multi-byte unicode characters" time="0.00207832">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; move: left/right should treat multi-byte chars as single units for visual cursor" time="0.00226752">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should insert printable characters" time="0.001894752">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Enter&quot; key as newline" time="0.001611388">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Backspace&quot; key" time="0.002129275">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle multiple delete characters in one input" time="0.00211036">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts that contain delete characters" time="0.00188329">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts with a mix of regular and delete characters" time="0.001975291">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle arrow keys for movement" time="0.009167903">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should strip ANSI escape codes when pasting text" time="0.004267466">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle VSCode terminal Shift+Enter as newline" time="0.001246304">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should correctly handle repeated pasting of long text" time="0.027241824">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with single-line text" time="0.002537109">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a multi-line range with single-line text" time="0.00112021">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should delete a range when replacing with an empty string" time="0.001064518">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the beginning of the text" time="0.001215647">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the end of the text" time="0.001120401">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing the entire buffer content" time="0.000921213">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should correctly replace with unicode characters" time="0.000953142">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle invalid range by returning false and not changing text" time="0.001594306">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; replaceRange: multiple lines with a single character" time="0.001830643">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with multi-line text" time="0.001403023">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip ANSI escape codes from input" time="0.001381383">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip control characters from input" time="0.001471198">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip mixed ANSI and control characters from input" time="0.002075756">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip standard characters or newlines" time="0.001713707">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should sanitize pasted text via handleInput" time="0.002431273">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip popular emojis" time="0.002152598">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should correctly strip ANSI escape codes" time="0.000224054">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle multiple ANSI codes" time="0.000118098">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should not modify text without ANSI codes" time="0.000100346">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle empty string" time="0.000105926">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should return [0,0] for offset 0" time="0.000137324">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle single line text" time="0.000246806">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-line text" time="0.000401662">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty lines" time="0.000242478">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text ending with a newline" time="0.000145469">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text starting with a newline" time="0.000164504">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty string input" time="0.00013531">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-byte unicode characters correctly" time="0.000306998">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset exactly at newline character" time="0.000163652">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset in the middle of a multi-byte character (should place at start of that char)" time="0.000145108">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should convert row/col position to offset correctly" time="0.000305394">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle empty lines" time="0.000160066">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle single empty line" time="0.000085999">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should be inverse of offsetToLogicalPos" time="0.00038946">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle out-of-bounds positions" time="0.000188849">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete a single line including newline in multi-line text" time="0.001181624">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete multiple lines when count &gt; 1" time="0.000278885">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should clear single line content when only one line exists" time="0.000246826">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting the last line properly" time="0.000221269">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting all lines and maintain valid state for subsequent paste" time="0.000358612">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle combining characters" time="0.001814023">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000136082">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should return null when no word end found" time="0.00019482">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle right-to-left text" time="0.000234904">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle Chinese characters" time="0.000320092">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should return null at end of line" time="0.000106657">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle combining characters" time="0.000284256">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000126644">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for ASCII word characters" time="0.000244292">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for punctuation" time="0.000122987">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for non-Latin scripts" time="0.000102199">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for whitespace" time="0.000088644">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle combining characters" time="0.000110455">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle Chinese and Arabic text" time="0.000095918">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/vim-buffer-actions.test.ts" timestamp="2025-10-17T11:01:41.508Z" hostname="uby" tests="74" failures="0" errors="0" skipped="0" time="0.027162377">
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should move cursor left by count" time="0.002578746">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should not move past beginning of line" time="0.00028686">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should wrap to previous line when at beginning" time="0.000233071">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should handle multiple line wrapping" time="0.000153343">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should correctly handle h/l movement between lines" time="0.000229875">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should move cursor right by count" time="0.000402835">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should not move past last character of line" time="0.00017319">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should wrap to next line when at end" time="0.000373781">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should skip over combining marks to avoid cursor disappearing" time="0.000532114">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should move cursor up by count" time="0.000160937">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should not move past first line" time="0.000118929">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should adjust column for shorter lines" time="0.000125101">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should move cursor down by count" time="0.000132415">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should not move past last line" time="0.000105435">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move to start of next word" time="0.0013905">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle multiple words" time="0.000154385">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle punctuation correctly" time="0.000105175">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move across empty lines when starting from within a word" time="0.000510804">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should move to start of previous word" time="0.000316264">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should handle multiple words" time="0.000149656">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of current word" time="0.000316155">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of next word if already at word end" time="0.000144046">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move across empty lines when at word end" time="0.000154676">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle consecutive word-end movements across empty lines" time="0.000183779">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle combining characters - advance from end of base character" time="0.000447187">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle precomposed characters with diacritics" time="0.000604817">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_start should move to column 0" time="0.000717687">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_end should move to last character" time="0.000089906">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_nonwhitespace should skip leading whitespace" time="0.000082212">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_line should move to row 0" time="0.000093934">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_last_line should move to last row" time="0.000095457">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should move to specific line" time="0.000103261">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should clamp to valid range" time="0.000073305">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete single character" time="0.000415437">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete multiple characters" time="0.000137775">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should not delete past end of line" time="0.000220468">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should do nothing at end of line" time="0.000144757">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete from cursor to next word start" time="0.000652426">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete multiple words" time="0.000198186">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete to end if no more words" time="0.000181325">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete from cursor to previous word start" time="0.000174302">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete multiple words backward" time="0.000151029">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete current line" time="0.000910884">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete multiple lines" time="0.000218955">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should leave empty line when deleting all lines" time="0.000190412">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should delete from cursor to end of line" time="0.000455792">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should do nothing at end of line" time="0.000140049">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_cursor &gt; should not change cursor position" time="0.000845563">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should move cursor right by one" time="0.000402353">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should not move past end of line" time="0.000159996">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_line_end &gt; should move cursor to end of line" time="0.000122807">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to first non-whitespace character" time="0.000125171">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to column 0 for line with only whitespace" time="0.000116255">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_below &gt; should insert a new line below the current one" time="0.000228372">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_above &gt; should insert a new line above the current one" time="0.000312768">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should move cursor left" time="0.000148605">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should not move past beginning of line" time="0.000114121">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_word_forward &gt; should delete from cursor to next word start" time="0.000594709">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_line &gt; should delete entire line content" time="0.000344537">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the left" time="0.000152081">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the right" time="0.000121925">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change multiple lines down" time="0.000320081">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty text" time="0.00014581">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle single character line" time="0.000093623">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty lines in multi-line text" time="0.000127215">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should preserve undo stack in operations" time="0.001273143">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Right-to-left text handling &gt; should handle Arabic text in word movements" time="0.000682762">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Chinese character handling &gt; should handle Chinese characters in word movements" time="0.000197094">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word end commands" time="0.000203085">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word forward commands" time="0.00089266">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word backward commands" time="0.000215448">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle Unicode block characters consistently with w and e commands" time="0.000321414">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Chinese characters" time="0.000231618">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Arabic characters" time="0.000241857">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/DiffRenderer.test.tsx" timestamp="2025-10-17T11:01:41.511Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.282707998">
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with correct language for new file with known extension" time="0.040374745">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file with unknown extension" time="0.114638627">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file if no filename is provided" time="0.012440792">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render diff content for existing file (not calling colorizeCode directly for the whole block)" time="0.006942039">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle diff with only header and no changes" time="0.00389616">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle empty diff content" time="0.001544815">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render a gap indicator for skipped lines" time="0.013832854">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should not render a gap indicator for small gaps (&lt;= MAX_CONTEXT_LINES_WITHOUT_GAP)" time="0.02207713">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height undefined" time="0.016603745">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height 6" time="0.010517657">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 30 and height 6" time="0.012287498">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with a SVN diff format" time="0.017747278">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a new file with no file extension correctly" time="0.007620032">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolConfirmationMessage.test.tsx" timestamp="2025-10-17T11:01:41.511Z" hostname="uby" tests="15" failures="10" errors="0" skipped="0" time="0.944218242">
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should not display urls if prompt and url are the same" time="0.156179798">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should display urls if prompt and url are different" time="0.057962187">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;URLs to fetch:&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;URLs to fetch:&apos;

- Expected
+ Received

- URLs to fetch:
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:275:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:64:25
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should render plan confirmation with markdown plan content" time="0.106148408">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, and auto-accept edits&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, and auto-accept edits&apos;

- Expected
+ Received

- Yes, and auto-accept edits
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:245:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:87:25
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.050301129">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;

- Expected
+ Received

- Yes, allow always
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:169:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:168:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.051397876">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;

- Expected
+ Received

- Yes, allow always
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:169:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:186:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.081375837">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.044075434">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;

- Expected
+ Received

- Yes, allow always
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:208:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:168:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.042472441">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;

- Expected
+ Received

- Yes, allow always
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:208:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:186:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.040021281">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.049058553">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;

- Expected
+ Received

- Yes, allow always
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:275:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:168:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.098476569">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;Yes, allow always&apos;

- Expected
+ Received

- Yes, allow always
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:275:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:186:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.033217998">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.03815908">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;always allow&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;always allow&apos;

- Expected
+ Received

- always allow
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:320:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:168:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.046235556">
            <failure message="expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;always allow&apos;" type="AssertionError">
AssertionError: expected &apos;\n  ERROR [vitest] No &quot;ToolConfirmati…&apos; to contain &apos;always allow&apos;

- Expected
+ Received

- always allow
+
+   ERROR [vitest] No &quot;ToolConfirmationOutcome&quot; export is defined on the &quot;@qwen-code/qwen-code-core&quot;
+        mock. Did you forget to return it from &quot;vi.mock&quot;?
+        If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
+
+
+  - If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:\t
+  - \t
+  -VitestMocker.createE (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h
+   ror                 3T_Hc.js:284:17)
+  -Object.get (file:///home/atmandk/LowCal-dev/node_modules/vitest/dist/chunks/execute.B7h3T_Hc.js:3
+             30:16)
+  - ToolConfirmationMessage (src/ui/components/messages/ToolConfirmationMessage.tsx:320:14)
+  -Object.react-stack-bott (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconci
+   m-frame                ler.development.js:15859:20)
+  -renderWithHoo (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.develo
+   s            pment.js:3221:22)
+  -updateFunctionComp (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.d
+   nent              evelopment.js:6475:19)
+  -beginWor (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.development
+           .js:8009:18)
+  -runWithFiberIn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   EV            opment.js:1738:13)
+  -performUnitOfW (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.devel
+   rk            opment.js:12834:22)
+  -workLoopSyn (/home/atmandk/LowCal-dev/node_modules/react-reconciler/cjs/react-reconciler.developm
+              ent.js:12644:41)
+

 ❯ src/ui/components/messages/ToolConfirmationMessage.test.tsx:186:29
            </failure>
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.044457409">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolGroupMessage.test.tsx" timestamp="2025-10-17T11:01:41.513Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.089102245">
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders single successful tool call" time="0.026023552">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders multiple tool calls with different statuses" time="0.006792753">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders tool call awaiting confirmation" time="0.00564404">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders shell command with yellow border" time="0.002723774">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders mixed tool calls including shell command" time="0.004554026">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with limited terminal height" time="0.003410733">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders when not focused" time="0.003237023">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with narrow terminal width" time="0.009309835">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders empty tool calls array" time="0.003100169">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border when tools are pending" time="0.003727799">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border for shell commands even when successful" time="0.003236341">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses gray border when all tools are successful and no shell commands" time="0.004634334">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Height Calculation &gt; calculates available height correctly with multiple tools with results" time="0.00426372">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Confirmation Handling &gt; shows confirmation dialog for first confirming tool only" time="0.005816269">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolMessage.test.tsx" timestamp="2025-10-17T11:01:41.513Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.059925926">
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders basic tool information" time="0.023868541">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows ✓ for Success status" time="0.00307346">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows o for Pending status" time="0.003037644">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows ? for Confirming status" time="0.006220045">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows - for Canceled status" time="0.002941917">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows x for Error status" time="0.002579206">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is Idle" time="0.002288058">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is WaitingForConfirmation" time="0.002325056">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows MockRespondingSpinner for Executing status when streamingState is Responding" time="0.002326649">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders DiffRenderer for diff results" time="0.002858743">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders emphasis correctly" time="0.004316467">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; shows subagent execution display for task tool with proper result display" time="0.002590777">
        </testcase>
    </testsuite>
</testsuites>
