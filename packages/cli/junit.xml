<?xml version="1.0" encoding="UTF-8" ?>
<testsuites name="vitest tests" tests="1989" failures="25" errors="0" time="29.77828964">
    <testsuite name="src/gemini.test.tsx" timestamp="2025-10-09T09:06:18.927Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.01828402">
        <testcase classname="src/gemini.test.tsx" name="gemini.tsx main function &gt; should throw InvalidConfigurationError if settings have errors" time="0.004380568">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="gemini.tsx main function &gt; should log unhandled promise rejections and open debug console on first error" time="0.008187445">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return &quot;ipv4first&quot; when the input is &quot;ipv4first&quot;" time="0.000485146">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return &quot;verbatim&quot; when the input is &quot;verbatim&quot;" time="0.000163342">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return the default &quot;ipv4first&quot; when the input is undefined" time="0.000125122">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="validateDnsResolutionOrder &gt; should return the default &quot;ipv4first&quot; and log a warning for an invalid string" time="0.000229233">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="startInteractiveUI &gt; should render the UI with proper React context and exitOnCtrlC disabled" time="0.002201078">
        </testcase>
        <testcase classname="src/gemini.test.tsx" name="startInteractiveUI &gt; should perform all startup tasks in correct order" time="0.000685888">
        </testcase>
    </testsuite>
    <testsuite name="src/nonInteractiveCli.test.ts" timestamp="2025-10-09T09:06:18.928Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.018627004">
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should process input and write text output" time="0.007429364">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle a single tool call and respond" time="0.00222871">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should handle error during tool execution and should send error back to the model" time="0.001429943">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit with error if sendMessageStream throws initially" time="0.001382266">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should not exit if a tool is not found, and should send error back to model" time="0.001768289">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should exit when max session turns are exceeded" time="0.00152546">
        </testcase>
        <testcase classname="src/nonInteractiveCli.test.ts" name="runNonInteractive &gt; should preprocess @include commands before sending to the model" time="0.001402552">
        </testcase>
    </testsuite>
    <testsuite name="src/validateNonInterActiveAuth.test.ts" timestamp="2025-10-09T09:06:18.929Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.02529519">
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; exits if no auth type is configured or env vars set" time="0.011977411">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set" time="0.00249935">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_GEMINI if GEMINI_API_KEY is set" time="0.001003445">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_OPENAI if OPENAI_API_KEY is set" time="0.001494703">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses configured QWEN_OAUTH if provided" time="0.000552051">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; normalizes openrouter string auth type to USE_OPENAI" time="0.000606371">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true (with GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION)" time="0.000484696">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if GOOGLE_GENAI_USE_VERTEXAI is true and GOOGLE_API_KEY is set" time="0.000763632">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses LOGIN_WITH_GOOGLE if GOOGLE_GENAI_USE_GCA is set, even with other env vars" time="0.000841265">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_VERTEX_AI if both GEMINI_API_KEY and GOOGLE_GENAI_USE_VERTEXAI are set" time="0.000509933">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses USE_GEMINI if GOOGLE_GENAI_USE_VERTEXAI is false, GEMINI_API_KEY is set, and project/location are available" time="0.000634292">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; uses configuredAuthType if provided" time="0.000407142">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; exits if validateAuthMethod returns error" time="0.000877422">
        </testcase>
        <testcase classname="src/validateNonInterActiveAuth.test.ts" name="validateNonInterActiveAuth &gt; skips validation if useExternalAuth is true" time="0.000760035">
        </testcase>
    </testsuite>
    <testsuite name="src/config/auth.test.ts" timestamp="2025-10-09T09:06:18.929Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.009778295">
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for LOGIN_WITH_GOOGLE" time="0.003780488">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return null for CLOUD_SHELL" time="0.000665319">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return null if GEMINI_API_KEY is set" time="0.000552431">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_GEMINI &gt; should return an error message if GEMINI_API_KEY is not set" time="0.000522906">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_CLOUD_PROJECT and GOOGLE_CLOUD_LOCATION are set" time="0.000465721">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return null if GOOGLE_API_KEY is set" time="0.000377999">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; USE_VERTEX_AI &gt; should return an error message if no required environment variables are set" time="0.000398747">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; should return an error message for an invalid auth method" time="0.00035156">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; OpenAI-compatible providers &gt; normalizes openrouter to USE_OPENAI" time="0.000394559">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; OpenAI-compatible providers &gt; requires OPENAI_API_KEY for openrouter" time="0.000525271">
        </testcase>
        <testcase classname="src/config/auth.test.ts" name="validateAuthMethod &gt; OpenAI-compatible providers &gt; accepts lmstudio when OPENAI_API_KEY is set" time="0.000339458">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.integration.test.ts" timestamp="2025-10-09T09:06:18.930Z" hostname="uby" tests="19" failures="0" errors="0" skipped="0" time="0.786865028">
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load default file filtering settings" time="0.028150438">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should load custom file filtering settings from configuration" time="0.001301235">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; File Filtering Configuration &gt; should merge user and workspace file filtering settings" time="0.000818864">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle partial configuration objects gracefully" time="0.000591945">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle empty configuration objects gracefully" time="0.000713519">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Configuration Integration &gt; should handle missing configuration sections gracefully" time="0.00061116">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a security-focused configuration" time="0.000613324">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Real-world Configuration Scenarios &gt; should handle a CI/CD environment configuration" time="0.00070315">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Checkpointing Configuration &gt; should enable checkpointing when the setting is true" time="0.001314991">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should have an empty array for extension context files by default" time="0.001277121">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Extension Context Files &gt; should correctly store and return extension context file paths" time="0.000889324">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=auto-edit correctly through the full argument parsing flow" time="0.695597313">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=plan correctly through the full argument parsing flow" time="0.004786448">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=yolo correctly through the full argument parsing flow" time="0.004250988">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse --approval-mode=default correctly through the full argument parsing flow" time="0.003903576">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should parse legacy --yolo flag correctly" time="0.003520759">
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject invalid approval mode values during argument parsing" time="0.02042661">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Invalid values:
  Argument: approval-mode, Given: &quot;invalid_mode&quot;, Choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should reject conflicting --yolo and --approval-mode flags" time="0.009831645">
            <system-err>
Usage: qwen [options] [command]

Qwen Code - Launch an interactive CLI, use -p/--prompt for non-interactive mode

Commands:
  qwen      Launch Qwen Code  [default]
  qwen mcp  Manage MCP servers

Options:
  -m, --model                     Model  [string]
  -p, --prompt                    Prompt. Appended to input on stdin (if any).  [string]
  -i, --prompt-interactive        Execute the provided prompt and continue in interactive mode  [string]
  -s, --sandbox                   Run in sandbox?  [boolean]
      --sandbox-image             Sandbox image URI.  [string]
  -d, --debug                     Run in debug mode?  [boolean] [default: false]
  -a, --all-files                 Include ALL files in context?  [boolean] [default: false]
      --show-memory-usage         Show memory usage in status bar  [boolean] [default: false]
  -y, --yolo                      Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?  [boolean] [default: false]
      --approval-mode             Set the approval mode: plan (plan only), default (prompt for approval), auto-edit (auto-approve edit tools), yolo (auto-approve all tools)  [string] [choices: &quot;plan&quot;, &quot;default&quot;, &quot;auto-edit&quot;, &quot;yolo&quot;]
      --telemetry                 Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.  [boolean]
      --telemetry-target          Set the telemetry target (local or gcp). Overrides settings files.  [string] [choices: &quot;local&quot;, &quot;gcp&quot;]
      --telemetry-otlp-endpoint   Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.  [string]
      --telemetry-otlp-protocol   Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.  [string] [choices: &quot;grpc&quot;, &quot;http&quot;]
      --telemetry-log-prompts     Enable or disable logging of user prompts for telemetry. Overrides settings files.  [boolean]
      --telemetry-outfile         Redirect all telemetry output to the specified file.  [string]
  -c, --checkpointing             Enables checkpointing of file edits  [boolean] [default: false]
      --experimental-acp          Starts the agent in ACP mode  [boolean]
      --allowed-mcp-server-names  Allowed MCP server names  [array]
      --allowed-tools             Tools that are allowed to run without confirmation  [array]
  -e, --extensions                A list of extensions to use. If not provided, all extensions are used.  [array]
  -l, --list-extensions           List all available extensions and exit.  [boolean]
      --proxy                     Proxy for qwen client, like schema://user:password@host:port  [string]
      --include-directories       Additional directories to include in the workspace (comma-separated or multiple --include-directories)  [array]
      --openai-logging            Enable logging of OpenAI API calls for debugging and analysis  [boolean]
      --openai-api-key            OpenAI API key to use for authentication  [string]
      --openai-base-url           OpenAI base URL (for custom endpoints)  [string]
      --tavily-api-key            Tavily API key for web search functionality  [string]
      --screen-reader             Enable screen reader mode for accessibility.  [boolean] [default: false]
      --vlm-switch-mode           Default behavior when images are detected in input. Values: once (one-time switch), session (switch for entire session), persist (continue with current model). Overrides settings files.  [string] [choices: &quot;once&quot;, &quot;session&quot;, &quot;persist&quot;]
  -v, --version                   Show version number  [boolean]
  -h, --help                      Show help  [boolean]

Cannot use both --yolo (-y) and --approval-mode together. Use --approval-mode=yolo instead.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.integration.test.ts" name="Configuration Integration Tests &gt; Approval Mode Integration Tests &gt; should handle backward compatibility with mixed scenarios" time="0.00353281">
        </testcase>
    </testsuite>
    <testsuite name="src/config/config.test.ts" timestamp="2025-10-09T09:06:18.931Z" hostname="uby" tests="125" failures="0" errors="0" skipped="1" time="0.491584898">
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --prompt and --prompt-interactive are used together" time="0.029621087">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -p and -i together" time="0.019667597">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt without --prompt-interactive" time="0.003306663">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --prompt-interactive without --prompt" time="0.003886345">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow -i flag as alias for --prompt-interactive" time="0.003300432">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when both --yolo and --approval-mode are used together" time="0.010352136">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should throw an error when using short flags -y and --approval-mode together" time="0.013609398">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --approval-mode without --yolo" time="0.003349441">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should allow --yolo without --approval-mode" time="0.003474914">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="parseArguments &gt; should reject invalid --approval-mode values" time="0.010037304">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to true when --show-memory-usage flag is present" time="0.02165451">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false when --memory flag is not present" time="0.006390874">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should set showMemoryUsage to false by default from settings if CLI flag is not present" time="0.003595677">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; should prioritize CLI flag over settings for showMemoryUsage (CLI true, settings false)" time="0.002204225">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should leave proxy to empty by default" time="0.001897618">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [https_proxy]" time="0.001835503">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [http_proxy]" time="0.001581855">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTPS_PROXY]" time="0.002371904">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy to http://localhost:7890 according to environment variable [HTTP_PROXY]" time="0.002756606">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should set proxy when --proxy flag is present" time="0.00261847">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig &gt; Proxy configuration &gt; should prioritize CLI flag over environment variable for proxy (CLI http://localhost:7890, environment variable http://localhost:7891)" time="0.002294051">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false by default when no flag or setting is present" time="0.002102126">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to true when --telemetry flag is present" time="0.015351048">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should set telemetry to false when --no-telemetry flag is present" time="0.004147928">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings true)" time="0.003735645">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry value from settings if CLI flag is not present (settings false)" time="0.003135836">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry CLI flag (true) over settings (false)" time="0.003558278">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry CLI flag (false) over settings (true)" time="0.00242896">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP endpoint from settings if CLI flag is not present" time="0.002554031">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-endpoint CLI flag over settings" time="0.002224592">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default endpoint if no OTLP endpoint is provided via CLI or settings" time="0.002603723">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry target from settings if CLI flag is not present" time="0.003813781">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-target CLI flag over settings" time="0.003098588">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default target if no target is provided via CLI or settings" time="0.00362428">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry log prompts from settings if CLI flag is not present" time="0.003086946">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-log-prompts CLI flag (true) over settings (false)" time="0.002673993">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --no-telemetry-log-prompts CLI flag (false) over settings (true)" time="0.003212709">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default log prompts (true) if no value is provided via CLI or settings" time="0.012369566">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use telemetry OTLP protocol from settings if CLI flag is not present" time="0.003055999">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should prioritize --telemetry-otlp-protocol CLI flag over settings" time="0.003084692">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should use default protocol if no OTLP protocol is provided via CLI or settings" time="0.002939754">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig telemetry &gt; should reject invalid --telemetry-otlp-protocol values" time="0.008475588">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should pass extension context file paths to loadServerHierarchicalMemory" time="0.00388439">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Hierarchical Memory Loading (config.ts) - Placeholder Suite &gt; should correctly use mocked homedir for global path" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeMcpServers &gt; should not modify the original settings object" time="0.003033167">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use default systemPromptMappings when not provided in settings" time="0.000718718">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig systemPromptMappings &gt; should use custom systemPromptMappings when provided in settings" time="0.0003948">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should merge excludeTools from settings and extensions" time="0.002863553">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between settings and extensions" time="0.002655259">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle overlapping excludeTools between extensions" time="0.001760565">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return an empty array when no excludeTools are specified and it is interactive" time="0.001746308">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should return default excludes when no excludeTools are specified and it is not interactive" time="0.002068464">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle settings with excludeTools but no extensions" time="0.002296656">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should handle extensions with excludeTools but no settings" time="0.001896667">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="mergeExcludeTools &gt; should not modify the original settings object" time="0.002406438">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with default approval mode" time="0.002944133">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with plan approval mode" time="0.003320619">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude all interactive tools in non-interactive mode with explicit default approval mode" time="0.00267815">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude only shell tools in non-interactive mode with auto-edit approval mode" time="0.002872329">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with yolo approval mode" time="0.003114918">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should exclude no interactive tools in non-interactive mode with legacy yolo flag" time="0.001967758">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should not exclude interactive tools in interactive mode regardless of approval mode" time="0.01470859">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should merge approval mode exclusions with settings exclusions in auto-edit mode" time="0.00215848">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="Approval mode tool exclusion logic &gt; should throw an error for invalid approval mode values in loadCliConfig" time="0.000431517">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow all MCP servers if the flag is not provided" time="0.002928834">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow only the specified MCP server" time="0.003211677">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow multiple specified MCP servers" time="0.002929255">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should handle server names that do not exist" time="0.002914377">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should allow no MCP servers if the flag is provided but empty" time="0.002651001">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read allowMCPServers from settings" time="0.002805176">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should read excludeMCPServers from settings" time="0.002730798">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should override allowMCPServers with excludeMCPServers if overlapping" time="0.002293149">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize mcp server flag if set" time="0.002839298">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with allowed-mcp-server-names &gt; should prioritize CLI flag over both allowed and excluded settings" time="0.002717583">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should not filter extensions if --extensions flag is not used" time="0.002185811">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig extensions &gt; should filter extensions if --extensions flag is used" time="0.001894722">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects a model from settings.json if provided" time="0.001558731">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; uses the default gemini model if nothing is set" time="0.001504612">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; always prefers model from argvs" time="0.002406959">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig model selection &gt; selects the model from argvs if provided" time="0.002844749">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be false by default" time="0.002983505">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrustFeature &gt; should be true when settings.folderTrustFeature is true" time="0.002574589">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is false" time="0.002469636">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is true and folderTrust is false" time="0.003295733">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be false if folderTrustFeature is false and folderTrust is true" time="0.002487047">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig folderTrust &gt; should be true when folderTrustFeature is true and folderTrust is true" time="0.002524096">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig with includeDirectories &gt; should combine and resolve paths from settings and CLI arguments" time="0.003879842">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should pass chatCompression settings to the core config" time="0.003260116">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig chatCompression &gt; should have undefined chatCompression if not in settings" time="0.004645177">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false by default when useRipgrep is not set in settings" time="0.002676097">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be true when useRipgrep is set to true in settings" time="0.002606538">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig useRipgrep &gt; should be false when useRipgrep is explicitly set to false in settings" time="0.002512114">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode without YOLO" time="0.002773547">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in interactive mode with YOLO" time="0.002759341">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should exclude interactive tools in non-interactive mode without YOLO" time="0.011847572">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig tool exclusions &gt; should not exclude interactive tools in non-interactive mode with YOLO" time="0.003811025">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if isTTY and no prompt" time="0.003413229">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should be interactive if prompt-interactive is set" time="0.002724306">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if not isTTY and no prompt" time="0.002404044">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig interactive &gt; should not be interactive if prompt is set" time="0.003321941">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should default to DEFAULT approval mode when no flags are set" time="0.002936158">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set PLAN approval mode when --approval-mode=plan" time="0.004005405">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --yolo flag is used" time="0.002579028">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when -y flag is used" time="0.002703418">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set DEFAULT approval mode when --approval-mode=default" time="0.002854256">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set AUTO_EDIT approval mode when --approval-mode=auto-edit" time="0.002999555">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should set YOLO approval mode when --approval-mode=yolo" time="0.003113165">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should use approval mode from settings when CLI flags are not provided" time="0.002727903">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should normalize approval mode values from settings" time="0.002756596">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should throw when approval mode in settings is invalid" time="0.002858745">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should prioritize --approval-mode over --yolo when both would be valid (but validation prevents this)" time="0.002648156">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; should fall back to --yolo behavior when --approval-mode is not set" time="0.00253715">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=yolo to DEFAULT" time="0.003855868">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --approval-mode=auto-edit to DEFAULT" time="0.00379756">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should override --yolo flag to DEFAULT" time="0.003200406">
            <system-err>
[WARN] Approval mode overridden to &quot;default&quot; because the current folder is not trusted.

            </system-err>
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should remain DEFAULT when --approval-mode=default" time="0.003027617">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig approval mode &gt; when folder is NOT trusted &gt; should allow PLAN approval mode in untrusted folders" time="0.002926079">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace trusted -&gt; behave as trusted" time="0.003336478">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust true, workspace not trusted -&gt; behave as trusted" time="0.005573212">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature disabled, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.002277821">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace trusted -&gt; behave as trusted" time="0.001838759">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust false, workspace not trusted -&gt; behave as trusted" time="0.002731489">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trusted -&gt; is trusted" time="0.002543151">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace NOT trusted -&gt; is NOT trusted" time="0.002528223">
        </testcase>
        <testcase classname="src/config/config.test.ts" name="loadCliConfig trustedFolder &gt; should be correct for: feature on, folderTrust on, workspace trust unknown -&gt; is unknown" time="0.002946838">
        </testcase>
    </testsuite>
    <testsuite name="src/config/extension.test.ts" timestamp="2025-10-09T09:06:18.934Z" hostname="uby" tests="26" failures="0" errors="0" skipped="0" time="0.065243939">
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should include extension path in loaded extension" time="0.007328126">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should load context file path when QWEN.md is present" time="0.002110882">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should load context file path from the extension config" time="0.000961668">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should filter out disabled extensions" time="0.00172579">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="loadExtensions &gt; should hydrate variables" time="0.00091434">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark all extensions as active if no enabled extensions are provided" time="0.000405079">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark only the enabled extensions as active" time="0.000386554">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should mark all extensions as inactive when &quot;none&quot; is provided" time="0.000318109">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should handle case-insensitivity" time="0.000277212">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="annotateActiveExtensions &gt; should log an error for unknown extensions" time="0.000851974">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should install an extension from a local path" time="0.011153028">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should throw an error if the extension already exists" time="0.004269543">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should throw an error and cleanup if qwen-extension.json is missing" time="0.001794196">
            <system-err>
Warning: extension directory /tmp/qwen-code-test-home-1I2GNC/bad-extension does not contain a config file /tmp/qwen-code-test-home-1I2GNC/bad-extension/qwen-extension.json.

            </system-err>
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="installExtension &gt; should install an extension from a git URL" time="0.004689108">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should uninstall an extension by name" time="0.002578777">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should uninstall an extension by name and retain existing extensions" time="0.002377706">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="uninstallExtension &gt; should throw an error if the extension does not exist" time="0.000549306">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="performWorkspaceExtensionMigration &gt; should install the extensions in the user directory" time="0.004989905">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="performWorkspaceExtensionMigration &gt; should return the names of failed installations" time="0.001947871">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="updateExtension &gt; should update a git-installed extension" time="0.00655664">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should disable an extension at the user scope" time="0.001166687">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should disable an extension at the workspace scope" time="0.00098998">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should handle disabling the same extension twice" time="0.000673706">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="disableExtension &gt; should throw an error if you request system scope" time="0.000463096">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="enableExtension &gt; should enable an extension at the user scope" time="0.001949344">
        </testcase>
        <testcase classname="src/config/extension.test.ts" name="enableExtension &gt; should enable an extension at the workspace scope" time="0.001662423">
        </testcase>
    </testsuite>
    <testsuite name="src/config/keyBindings.test.ts" timestamp="2025-10-09T09:06:18.935Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.006518861">
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have bindings for all commands" time="0.002851522">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should have valid key binding structures" time="0.002190088">
        </testcase>
        <testcase classname="src/config/keyBindings.test.ts" name="keyBindings config &gt; defaultKeyBindings &gt; should export all required types" time="0.000177919">
        </testcase>
    </testsuite>
    <testsuite name="src/config/settings.test.ts" timestamp="2025-10-09T09:06:18.935Z" hostname="uby" tests="65" failures="0" errors="0" skipped="0" time="0.043733195">
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load empty settings if no files exist" time="0.004665725">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load system settings if only system file exists" time="0.002352299">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load user settings if only user file exists" time="0.00083305">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should restore selected auth type when provider data is persisted in V1 format" time="0.001131081">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load workspace settings if only workspace file exists" time="0.000926233">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge user and workspace settings, with workspace taking precedence" time="0.001076961">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge system, user and workspace settings, with system taking precedence over workspace, and workspace over user" time="0.001229543">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly migrate a complex legacy (v1) settings file" time="0.001235083">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly merge and migrate legacy array properties from multiple scopes" time="0.001429582">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge all settings files with the correct precedence" time="0.000819605">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should ignore folderTrust from workspace settings" time="0.00037344">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should use system folderTrust over user setting" time="0.000295567">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle contextFileName correctly when only in user settings" time="0.00028145">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle contextFileName correctly when only in workspace settings" time="0.000738385">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle excludedProjectEnvVars correctly when only in user settings" time="0.000377037">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle excludedProjectEnvVars correctly when only in workspace settings" time="0.000268756">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge excludedProjectEnvVars with workspace taking precedence over user" time="0.000365125">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should default contextFileName to undefined if not in any settings file" time="0.000378791">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load telemetry setting from user settings" time="0.000300075">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should load telemetry setting from workspace settings" time="0.000683744">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should prioritize workspace telemetry setting over user setting" time="0.000342814">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have telemetry as undefined if not in any settings file" time="0.000247618">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge MCP servers correctly, with workspace taking precedence" time="0.002112145">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle MCP servers when only in user settings" time="0.000408035">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle MCP servers when only in workspace settings" time="0.000294685">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have mcpServers as empty object if not in any settings file" time="0.000252467">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge MCP servers from system, user, and workspace with system taking precedence" time="0.000483964">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge mcp allowed/excluded lists with system taking precedence over workspace" time="0.000429615">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge chatCompression settings, with workspace taking precedence" time="0.001578979">
            <system-out>
{ contextPercentageThreshold: [33m0.5[39m }

            </system-out>
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle chatCompression when only in user settings" time="0.000358272">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should have chatCompression as an empty object if not in any settings file" time="0.000207334">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should ignore chatCompression if contextPercentageThreshold is invalid" time="0.000564594">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should deep merge chatCompression settings" time="0.000323407">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should merge includeDirectories from all scopes" time="0.000694734">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should handle JSON parsing errors gracefully" time="0.001638649">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in user settings" time="0.000603996">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in workspace settings" time="0.000509282">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly resolve and merge env variables from different scopes" time="0.000694324">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly merge dnsResolutionOrder with workspace taking precedence" time="0.000425557">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should use user dnsResolutionOrder if workspace is not defined" time="0.000286089">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should leave unresolved environment variables as is" time="0.000349757">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve multiple environment variables in a single string" time="0.000362119">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve environment variables in arrays" time="0.000315864">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should correctly pass through null, boolean, and number types, and handle undefined properties" time="0.000438861">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; should resolve multiple concatenated environment variables in a single string value" time="0.000257757">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; loadSettings &gt; when QWEN_CODE_SYSTEM_SETTINGS_PATH is set &gt; should load system settings from the path specified in the environment variable" time="0.000636717">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should exclude DEBUG and DEBUG_MODE from project .env files by default" time="0.000486689">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should respect custom excludedProjectEnvVars from user settings" time="0.00045443">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; excludedProjectEnvVars integration &gt; should merge excludedProjectEnvVars with workspace taking precedence" time="0.000451875">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; with workspace trust &gt; should merge workspace settings when workspace is trusted" time="0.000444201">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; with workspace trust &gt; should NOT merge workspace settings when workspace is not trusted" time="0.000457185">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle an empty object" time="0.001000179">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should migrate a simple v2 settings object to v1" time="0.000362039">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle nested properties correctly" time="0.00022701">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve security auth provider configuration" time="0.000219405">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve mcpServers at the top level" time="0.000156449">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should carry over unrecognized top-level properties" time="0.000161528">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle a complex object with mixed properties" time="0.000270901">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should not migrate a v1 settings object" time="0.000194329">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should migrate a full v2 settings object to v1" time="0.000296428">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle partial v2 settings" time="0.000140951">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle settings with different data types" time="0.000471221">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should preserve unrecognized top-level keys" time="0.000230627">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should handle an empty v2 settings object" time="0.000164845">
        </testcase>
        <testcase classname="src/config/settings.test.ts" name="Settings Loading and Merging &gt; migrateSettingsToV1 &gt; should correctly handle mcpServers at the top level" time="0.000219766">
        </testcase>
    </testsuite>
    <testsuite name="src/config/settingsSchema.test.ts" timestamp="2025-10-09T09:06:18.937Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.007123699">
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should contain all expected top-level settings" time="0.001185492">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct structure for each setting" time="0.001745597">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have correct nested setting structure" time="0.000281541">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have accessibility nested properties" time="0.000063267">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have checkpointing nested properties" time="0.000052867">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have fileFiltering nested properties" time="0.000050894">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have unique categories" time="0.000721494">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have consistent default values for boolean settings" time="0.000648499">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have showInDialog property configured" time="0.00021111">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should infer Settings type correctly" time="0.000474036">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have includeDirectories setting in schema" time="0.000093262">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have loadMemoryFromIncludeDirectories setting in schema" time="0.000057085">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have folderTrustFeature setting in schema" time="0.000090287">
        </testcase>
        <testcase classname="src/config/settingsSchema.test.ts" name="SettingsSchema &gt; SETTINGS_SCHEMA &gt; should have debugKeystrokeLogging setting in schema" time="0.00012415">
        </testcase>
    </testsuite>
    <testsuite name="src/config/trustedFolders.test.ts" timestamp="2025-10-09T09:06:18.938Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.009903518">
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load empty rules if no files exist" time="0.002918946">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should load user rules if only user file exists" time="0.000818052">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; should handle JSON parsing errors gracefully" time="0.00080626">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="Trusted Folders Loading &gt; setValue should update the user config and save it" time="0.001258075">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a directly trusted folder" time="0.001086168">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted folder" time="0.000287652">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return true for a child of a trusted parent folder" time="0.000157591">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return false for a directly untrusted folder" time="0.000120062">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined for a child of an untrusted folder" time="0.000231098">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should return undefined when no rules match" time="0.000208235">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should prioritize trust over distrust" time="0.000152241">
        </testcase>
        <testcase classname="src/config/trustedFolders.test.ts" name="isWorkspaceTrusted &gt; should handle path normalization" time="0.000215869">
        </testcase>
    </testsuite>
    <testsuite name="src/services/BuiltinCommandLoader.test.ts" timestamp="2025-10-09T09:06:18.938Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.009040091">
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should correctly pass the config object to command factory functions" time="0.005860083">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should filter out null command definitions returned by factories" time="0.000724439">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should handle a null config gracefully when calling factories" time="0.000425927">
        </testcase>
        <testcase classname="src/services/BuiltinCommandLoader.test.ts" name="BuiltinCommandLoader &gt; should return a list of all loaded commands" time="0.000619285">
        </testcase>
    </testsuite>
    <testsuite name="src/services/CommandService.test.ts" timestamp="2025-10-09T09:06:18.938Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.009045702">
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from a single loader" time="0.002836463">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should aggregate commands from multiple loaders" time="0.00035191">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should override commands from earlier loaders with those from later loaders" time="0.00053552">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle loaders that return an empty array of commands gracefully" time="0.000593588">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should load commands from successful loaders even if one fails" time="0.000805499">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; getCommands should return a readonly array that cannot be mutated" time="0.00056301">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should pass the abort signal to all loaders" time="0.001086709">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should rename extension commands when they conflict" time="0.000433301">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle user/project command override correctly" time="0.00032454">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle secondary conflicts when renaming extension commands" time="0.00028171">
        </testcase>
        <testcase classname="src/services/CommandService.test.ts" name="CommandService &gt; should handle multiple secondary conflicts with incrementing suffixes" time="0.000228532">
        </testcase>
    </testsuite>
    <testsuite name="src/services/FileCommandLoader.test.ts" timestamp="2025-10-09T09:06:18.939Z" hostname="uby" tests="36" failures="0" errors="0" skipped="0" time="0.095305611">
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads a single command from a file" time="0.022149295">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked directory" time="0.003290492">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads commands from a symlinked subdirectory" time="0.002296395">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; loads multiple commands" time="0.001807982">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates deeply nested namespaces correctly" time="0.00231521">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; creates namespaces from nested directories" time="0.001873123">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; returns both user and project commands in order" time="0.00276433">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files with TOML syntax errors" time="0.002932681">
            <system-err>
[FileCommandLoader] Failed to parse TOML file /home/atmandk/.qwen/commands/invalid.toml: Invalid character, expected &quot;=&quot; at row 1, col 7, pos 6:
1&gt; this is not valid toml
         ^



            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; ignores files that are semantically invalid (missing prompt)" time="0.002988274">
            <system-err>
[FileCommandLoader] Skipping invalid command file: /home/atmandk/.qwen/commands/no_prompt.toml. Validation errors: {
  formErrors: [],
  fieldErrors: { prompt: [ [32m&quot;The &apos;prompt&apos; field is required.&quot;[39m ] }
}

            </system-err>
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles filename edge cases correctly" time="0.001328777">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; handles file system errors gracefully" time="0.000809887">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses a default description if not provided" time="0.001175943">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; uses the provided description" time="0.001603003">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; should sanitize colons in filenames to prevent namespace conflicts" time="0.001121504">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only DefaultArgumentProcessor if no {{args}} or !{} are present" time="0.001315813">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if {{args}} is present (but not !{})" time="0.000978048">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and DefaultArgumentProcessor if !{} is present (but not {{args}})" time="0.000840704">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor if both {{args}} and !{} are present" time="0.000916023">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates AtFileProcessor and DefaultArgumentProcessor if @{} is present" time="0.001085898">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates ShellProcessor and AtFileProcessor if !{} and @{} are present" time="0.001066622">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Processor Instantiation Logic &gt; instantiates only ShellProcessor and AtFileProcessor if {{args}} and @{} are present" time="0.0010007">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; loads commands from active extensions" time="0.001965463">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; extension commands have extensionName metadata for conflict resolution" time="0.002351067">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; only loads commands from active extensions" time="0.001312146">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles missing extension commands directory gracefully" time="0.000998466">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Extension Command Loading &gt; handles nested command structure in extensions" time="0.002767155">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Argument Handling Integration (via ShellProcessor) &gt; correctly processes a command with {{args}}" time="0.002548861">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Default Argument Processor Integration &gt; correctly processes a command without {{args}}" time="0.003115108">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if {{args}} is present (even without shell trigger)" time="0.002399817">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; instantiates ShellProcessor if the trigger is present" time="0.00188761">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; does not instantiate ShellProcessor if no triggers ({{args}} or !{}) are present" time="0.001770102">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;submit_prompt&quot; action if shell processing succeeds" time="0.002371674">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; returns a &quot;confirm_shell_commands&quot; action if shell processing requires it" time="0.00226671">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; re-throws other errors from the processor" time="0.003598302">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; Shell Processor Integration &gt; assembles the processor pipeline in the correct order (AtFile -&gt; Shell -&gt; Default)" time="0.004949319">
        </testcase>
        <testcase classname="src/services/FileCommandLoader.test.ts" name="FileCommandLoader &gt; @-file Processor Integration &gt; correctly processes a command with @{file}" time="0.002802049">
        </testcase>
    </testsuite>
    <testsuite name="src/services/McpPromptLoader.test.ts" timestamp="2025-10-09T09:06:18.940Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.004792259">
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle multi-word positional arguments" time="0.002074455">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle quoted multi-word positional arguments" time="0.000301888">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a single positional argument with multiple words" time="0.000155748">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped quotes in positional arguments" time="0.000141662">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle escaped backslashes in positional arguments" time="0.000094705">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle named args followed by positional args" time="0.000125552">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args followed by named args" time="0.00010777">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle positional args interspersed with named args" time="0.000119381">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should treat an escaped quote at the start as a literal" time="0.000105595">
        </testcase>
        <testcase classname="src/services/McpPromptLoader.test.ts" name="McpPromptLoader &gt; parseArgs &gt; should handle a complex mix of args" time="0.000123849">
        </testcase>
    </testsuite>
    <testsuite name="src/test-utils/mockCommandContext.test.ts" timestamp="2025-10-09T09:06:18.940Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.006527847">
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should return a valid CommandContext object with default mocks" time="0.003314287">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply top-level overrides correctly" time="0.001051213">
        </testcase>
        <testcase classname="src/test-utils/mockCommandContext.test.ts" name="createMockCommandContext &gt; should apply deeply nested overrides correctly" time="0.00075193">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/cleanup.test.ts" timestamp="2025-10-09T09:06:18.940Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.003482167">
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered synchronous function" time="0.00187172">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run a registered asynchronous function" time="0.000229935">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should run multiple registered functions" time="0.000168311">
        </testcase>
        <testcase classname="src/utils/cleanup.test.ts" name="cleanup &gt; should continue running cleanup functions even if one throws an error" time="0.00017816">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/gitUtils.test.ts" timestamp="2025-10-09T09:06:18.940Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.018900389">
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the git command fails" time="0.0096127">
            <system-out>
Failed to get git remote: Error: oops
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:29:13
    at mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at execSync (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at Module.isGitHubRepository [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.ts:17:7[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:31:12
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:155:11
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:26
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1897:20
    at new Promise (&lt;anonymous&gt;)
    at runWithTimeout (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1863:10)

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns false if the remote is not github.com" time="0.000833049">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="isGitHubRepository &gt; returns true if the remote is github.com" time="0.000395932">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if github repo info cannot be determined" time="0.000970975">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; throws an error if owner/repo could not be determined" time="0.000415789">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitHubRepoInfo &gt; returns the owner and repo" time="0.000964072">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root cannot be determined" time="0.000442748">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; throws an error if git root is empty" time="0.000282923">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getGitRepoRoot &gt; returns the root" time="0.000170775">
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch fails" time="0.001989418">
            <system-out>
Failed to determine latest run-gemini-cli release: nope

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; throws an error if the fetch does not return a json body" time="0.000859679">
            <system-out>
Failed to determine latest run-gemini-cli release: Error: Response did not include tag_name field
    at Module.getLatestGitHubRelease [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.ts:82:13[90m)[39m
[90m    at processTicksAndRejections (node:internal/process/task_queues:105:5)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/utils/gitUtils.test.ts:135:5
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:20

            </system-out>
        </testcase>
        <testcase classname="src/utils/gitUtils.test.ts" name="getLatestRelease &gt; returns the release version" time="0.000545158">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/handleAutoUpdate.test.ts" timestamp="2025-10-09T09:06:18.941Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.020181898">
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update info is null" time="0.001885426">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should do nothing if update nag is disabled" time="0.000317888">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if auto-updates are disabled" time="0.00401929">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-received&quot; but not update if no update command is found" time="0.000444482">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should combine update messages correctly" time="0.000792074">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should attempt to perform an update when conditions are met" time="0.000291458">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the update process fails" time="0.003230171">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-failed&quot; when the spawn function throws an error" time="0.0047008">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should use the &quot;@nightly&quot; tag for nightly updates" time="0.000518659">
        </testcase>
        <testcase classname="src/utils/handleAutoUpdate.test.ts" name="handleAutoUpdate &gt; should emit &quot;update-success&quot; when the update process succeeds" time="0.002643847">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/installationInfo.test.ts" timestamp="2025-10-09T09:06:18.941Z" hostname="uby" tests="16" failures="0" errors="0" skipped="0" time="0.010063613">
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN when cliPath is not available" time="0.001678143">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should return UNKNOWN and log error if realpathSync fails" time="0.001724748">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running from a local git clone" time="0.000293001">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via npx" time="0.000457936">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via pnpx" time="0.00023241">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect running via bunx" time="0.00021609">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect Homebrew installation via execSync" time="0.001389498">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should fall through if brew command fails" time="0.000690687">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global pnpm installation" time="0.000338275">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global yarn installation" time="0.000276201">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect global bun installation" time="0.000248118">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify yarn from lockfile" time="0.000416429">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify pnpm from lockfile" time="0.00024349">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should detect local installation and identify bun from lockfile" time="0.000210449">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to local npm installation if no lockfile is found" time="0.000192456">
        </testcase>
        <testcase classname="src/utils/installationInfo.test.ts" name="getInstallationInfo &gt; should default to global npm installation for unrecognized paths" time="0.000272844">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/readStdin.test.ts" timestamp="2025-10-09T09:06:18.942Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.008939685">
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should read and accumulate data from stdin" time="0.003127241">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should handle empty stdin input" time="0.000354064">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should timeout and resolve with empty string when no input is available" time="0.002936118">
        </testcase>
        <testcase classname="src/utils/readStdin.test.ts" name="readStdin &gt; should clear timeout once when data is received and resolve with data" time="0.000618062">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/settingsUtils.test.ts" timestamp="2025-10-09T09:06:18.942Z" hostname="uby" tests="68" failures="0" errors="0" skipped="0" time="0.009603814">
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should group settings by category" time="0.001064217">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByCategory &gt; should include key property in grouped settings" time="0.000911575">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return definition for valid setting" time="0.000136062">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingDefinition &gt; should return undefined for invalid setting" time="0.00005415">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return true for settings that require restart" time="0.000077384">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for settings that do not require restart" time="0.000074628">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; requiresRestart &gt; should return false for invalid settings" time="0.00005986">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return correct default values" time="0.000090517">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDefaultValue &gt; should return undefined for invalid settings" time="0.00003785">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getRestartRequiredSettings &gt; should return all settings that require restart" time="0.000754465">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from settings when set" time="0.000131212">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return value from merged settings when not set in current scope" time="0.000051204">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return default value when not set anywhere" time="0.000032981">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should handle nested settings correctly" time="0.00003768">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getEffectiveValue &gt; should return undefined for invalid settings" time="0.000036317">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getAllSettingKeys &gt; should return all setting keys" time="0.000152422">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsByType &gt; should return only boolean settings" time="0.000401733">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingsRequiringRestart &gt; should return only settings that require restart" time="0.000363662">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return true for valid setting keys" time="0.000068357">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; isValidSettingKey &gt; should return false for invalid setting keys" time="0.000036618">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return correct category for valid settings" time="0.000046566">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getSettingCategory &gt; should return undefined for invalid settings" time="0.000024997">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for settings marked to show in dialog" time="0.000059019">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return false for settings marked to hide from dialog" time="0.000058328">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; shouldShowInDialog &gt; should return true for invalid settings (default behavior)" time="0.000024876">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should only return settings marked for dialog display" time="0.000212893">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should not include Advanced category settings" time="0.000054361">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByCategory &gt; should include settings with showInDialog=true" time="0.00026521">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only boolean dialog settings" time="0.000191855">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingsByType &gt; should return only string dialog settings" time="0.000126694">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return only settings marked for dialog display" time="0.000325491">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should return fewer keys than getAllSettingKeys" time="0.000084446">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Schema Utilities &gt; getDialogSettingKeys &gt; should handle nested settings display correctly" time="0.000218274">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from settings when set" time="0.000048971">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return value from merged settings when not set in current scope" time="0.000038601">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getSettingValue &gt; should return default value for invalid setting" time="0.000029324">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return true when value differs from default" time="0.000060742">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isSettingModified &gt; should return false when value matches default" time="0.000045164">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for top-level settings that exist" time="0.000031609">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for top-level settings that do not exist" time="0.000025277">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return true for nested settings that exist" time="0.0000273">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false for nested settings that do not exist" time="0.000025928">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; settingExistsInScope &gt; should return false when parent exists but child does not" time="0.000030226">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set top-level setting value" time="0.00004323">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should set nested setting value" time="0.000036287">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should preserve existing nested settings" time="0.000045654">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; setPendingSettingValue &gt; should not mutate original settings" time="0.0004655">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return true when modified settings require restart" time="0.000094755">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false when no modified settings require restart" time="0.000039363">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; hasRestartRequiredSettings &gt; should return false for empty set" time="0.00002741">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return only settings that require restart" time="0.000116775">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getRestartRequiredFromModified &gt; should return empty array when no settings require restart" time="0.000059039">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value without * when setting matches default" time="0.000045995">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value when setting is not in scope" time="0.000045835">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when changed from default" time="0.000034794">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show default value without * when setting does not exist in scope" time="0.000029234">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getDisplayValue &gt; should show value with * when user changes from default" time="0.000034394">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when setting does not exist in scope" time="0.000040785">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when setting exists in scope" time="0.000030396">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return true when nested setting does not exist in scope" time="0.000025758">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isDefaultValue &gt; should return false when nested setting exists in scope" time="0.000026939">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for top-level settings that exist in scope" time="0.000038401">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for top-level settings that do not exist in scope" time="0.000026138">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return false for nested settings that exist in scope" time="0.000027391">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; isValueInherited &gt; should return true for nested settings that do not exist in scope" time="0.000025266">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from settings when available" time="0.00003782">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return value from merged settings when not in scope" time="0.000026639">
        </testcase>
        <testcase classname="src/utils/settingsUtils.test.ts" name="SettingsUtils &gt; Business Logic Utilities &gt; getEffectiveDisplayValue &gt; should return default value for undefined values" time="0.000023974">
        </testcase>
    </testsuite>
    <testsuite name="src/utils/startupWarnings.test.ts" timestamp="2025-10-09T09:06:18.944Z" hostname="uby" tests="4" failures="0" errors="0" skipped="4" time="0">
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return warnings from the file and delete it" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an empty array if the file does not exist" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return an error message if reading the file fails" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/utils/startupWarnings.test.ts" name="startupWarnings &gt; should return a warning if deleting the file fails" time="0">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/utils/userStartupWarnings.test.ts" timestamp="2025-10-09T09:06:18.944Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.014644932">
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should return a warning when running in home directory" time="0.009099762">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; home directory check &gt; should not return a warning when running in a project directory" time="0.001641064">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should return a warning when running in a root directory" time="0.000776205">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; root directory check &gt; should not return a warning when running in a non-root directory" time="0.000610248">
        </testcase>
        <testcase classname="src/utils/userStartupWarnings.test.ts" name="getUserStartupWarnings &gt; error handling &gt; should handle errors when checking directory" time="0.001062654">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp.test.ts" timestamp="2025-10-09T09:06:18.944Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.00952607">
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should have correct command definition" time="0.001380943">
        </testcase>
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should have exactly one option (help flag)" time="0.003808781">
        </testcase>
        <testcase classname="src/commands/mcp.test.ts" name="mcp command &gt; should register add, remove, and list subcommands" time="0.003168036">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/App.test.tsx" timestamp="2025-10-09T09:06:18.944Z" hostname="uby" tests="49" failures="5" errors="0" skipped="0" time="2.026631174">
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not start the update process when running from git" time="0.126850625">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Static inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show a success message when update succeeds" time="0.081650939">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when update fails" time="0.075366972">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should show an error message when spawn fails" time="0.069575727">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; handleAutoUpdate &gt; should not auto-update if GEMINI_CLI_DISABLE_AUTOUPDATER is true" time="0.023295995">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file when available" time="0.015502237">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display any files when not available" time="0.017860627">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other open files" time="0.021618353">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display active file and other context" time="0.025042493">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; in footer when contextFileName is not set and count is 1" time="0.020991605">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display default &quot;QWEN.md&quot; with plural when contextFileName is not set and count is &gt; 1" time="0.023163901">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName in footer when set and count is 1" time="0.026353707">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display a generic message when multiple context files with different names are provided" time="0.018861447">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display custom contextFileName with plural when set and count is &gt; 1" time="0.023468734">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display context file message if count is 0, even if contextFileName is set" time="0.021609577">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display QWEN.md and MCP server count when both are present" time="0.024058534">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display only MCP server count when QWEN.md count is 0" time="0.046058222">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Tips component by default" time="0.02241166">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Tips component when hideTips is true" time="0.021709422">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Header component by default" time="0.023062443">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Header component when hideBanner is true" time="0.024378816">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should display Footer component by default" time="0.034372371">
            <failure message="expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;" type="AssertionError">
AssertionError: expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;

- Expected
+ Received

- /test/dir
+  I&apos;m Feeling Lucky (esc to cancel, 0s)
+
+
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)

 ❯ src/ui/App.test.tsx:951:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should not display Footer component when hideFooter is true" time="0.021767349">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show footer if system says show, but workspace and user settings say hide" time="0.026364607">
            <failure message="expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;" type="AssertionError">
AssertionError: expected &apos; I\&apos;m Feeling Lucky (esc to cancel, 0…&apos; to contain &apos;/test/dir&apos;

- Expected
+ Received

- /test/dir
+  I&apos;m Feeling Lucky (esc to cancel, 0s)
+
+
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)

 ❯ src/ui/App.test.tsx:989:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should show tips if system says show, but workspace and user settings say hide" time="0.019467557">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display theme dialog if NO_COLOR is not set" time="0.016004596">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when no theme is set &gt; should display a message if NO_COLOR is set" time="0.022543154">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render the initial UI correctly" time="0.022945888">
            <failure message="Snapshot `App UI &gt; should render the initial UI correctly 1` mismatched" type="Error">
Error: Snapshot `App UI &gt; should render the initial UI correctly 1` mismatched

- Expected
+ Received

  &quot; I&apos;m Feeling Lucky (esc to cancel, 0s)


- /test/dir                no sandbox (see /docs)                  model (100% context left)&quot;
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)&quot;

 ❯ src/ui/App.test.tsx:1067:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; should render correctly with the prompt input box" time="0.030549153">
            <failure message="Snapshot `App UI &gt; should render correctly with the prompt input box 1` mismatched" type="Error">
Error: Snapshot `App UI &gt; should render correctly with the prompt input box 1` mismatched

- Expected
+ Received

  &quot;

  ╭────────────────────────────────────────────────────────────────────────────────────────╮
  │ &gt;   Type your message or @path/to/file                                                 │
  ╰────────────────────────────────────────────────────────────────────────────────────────╯
- /test/dir                no sandbox (see /docs)                  model (100% context left)&quot;
+ /test/di    no sandbox (see      model (131,072/131,072 tokens available) (100% context
+ r           /docs)              left)&quot;

 ❯ src/ui/App.test.tsx:1088:25
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; with initial prompt from --prompt-interactive &gt; should submit the initial prompt automatically" time="0.130363378">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; errorCount &gt; should correctly sum the counts of error messages" time="0.028501498">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should call validateAuthMethod when useExternalAuth is false" time="0.029838429">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; auth validation &gt; should NOT call validateAuthMethod when useExternalAuth is true" time="0.03013095">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; when in a narrow terminal &gt; should render with a column layout" time="0.029558452">
            <failure message="Snapshot `App UI &gt; when in a narrow terminal &gt; should render with a column layout 1` mismatched" type="Error">
Error: Snapshot `App UI &gt; when in a narrow terminal &gt; should render with a column layout 1` mismatched

- Expected
+ Received

@@ -6,6 +6,6 @@
  ╰────────────────────────────────────────────────────────────────────────────────────────╯
  dir

  no sandbox (see /docs)

- model (100% context left)| ✖ 5 errors (ctrl+o for details)&quot;
+ model (131,072/131,072 tokens available) (100% context left)| ✖ 5 errors (ctrl+o for details)&quot;

 ❯ src/ui/App.test.tsx:1237:27
            </failure>
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; NO_COLOR smoke test &gt; should render without errors when NO_COLOR is set" time="0.028910323">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when isFolderTrustDialogOpen is true" time="0.037517264">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should display the folder trust dialog when the feature is enabled but the folder is not trusted" time="0.058836795">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; FolderTrustDialog &gt; should not display the folder trust dialog when the feature is disabled" time="0.030944053">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should queue messages when handleFinalSubmit is called during streaming" time="0.042651916">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should auto-send queued messages when transitioning from Responding to Idle" time="0.118798138">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should display queued messages with dimmed color" time="0.031556164">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should clear message queue after sending" time="0.03781811">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should handle empty messages by filtering them out" time="0.026494658">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should combine multiple queued messages with double newlines" time="0.05264046">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should limit displayed messages to MAX_DISPLAYED_QUEUED_MESSAGES" time="0.025226433">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Message Queuing &gt; should render message queue display without errors" time="0.030393655">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should pass debugKeystrokeLogging setting to KeypressProvider" time="0.029939105">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; debug keystroke logging &gt; should use default false value when debugKeystrokeLogging is not set" time="0.028167611">
        </testcase>
        <testcase classname="src/ui/App.test.tsx" name="App UI &gt; Ctrl+C behavior &gt; should call cancel but only clear the prompt when a tool is executing" time="0.24555012">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/keyMatchers.test.ts" timestamp="2025-10-09T09:06:18.947Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.007528678">
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match return correctly" time="0.00140112">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match escape correctly" time="0.000233411">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match home correctly" time="0.000160316">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match end correctly" time="0.000185884">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineRight correctly" time="0.000149306">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match killLineLeft correctly" time="0.000121424">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearInput correctly" time="0.000079738">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match clearScreen correctly" time="0.00009761">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyUp correctly" time="0.000115914">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match historyDown correctly" time="0.000104734">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationUp correctly" time="0.000127766">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match navigationDown correctly" time="0.000123338">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestion correctly" time="0.00012955">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionUp correctly" time="0.000119481">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match completionDown correctly" time="0.000154516">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submit correctly" time="0.000166889">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match newline correctly" time="0.00018369">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match openExternalEditor correctly" time="0.000138837">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match pasteClipboardImage correctly" time="0.000103471">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showErrorDetails correctly" time="0.000117037">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleToolDescriptions correctly" time="0.000116405">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleIDEContextDetail correctly" time="0.000107338">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match quit correctly" time="0.0001083">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match exit correctly" time="0.000138566">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match showMoreLines correctly" time="0.000109963">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match toggleYoloMode correctly" time="0.000106036">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match reverseSearch correctly" time="0.000128077">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match submitReverseSearch correctly" time="0.000154726">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should match acceptSuggestionReverseSearch correctly" time="0.000146341">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Data-driven key binding matches original logic &gt; should properly handle ACCEPT_SUGGESTION_REVERSE_SEARCH cases" time="0.000115694">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should work with custom configuration" time="0.000187016">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Custom key bindings &gt; should support multiple key bindings for same command" time="0.000138957">
        </testcase>
        <testcase classname="src/ui/keyMatchers.test.ts" name="keyMatchers &gt; Edge Cases &gt; should handle empty binding arrays" time="0.000096087">
        </testcase>
    </testsuite>
    <testsuite name="src/config/__tests__/env-persist.test.ts" timestamp="2025-10-09T09:06:18.948Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.002528774">
        <testcase classname="src/config/__tests__/env-persist.test.ts" name="env persistence &gt; writes to discovered .env file and returns the path" time="0.001667944">
        </testcase>
    </testsuite>
    <testsuite name="src/config/extensions/variables.test.ts" timestamp="2025-10-09T09:06:18.948Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.003017027">
        <testcase classname="src/config/extensions/variables.test.ts" name="hydrateString &gt; should replace a single variable" time="0.001382546">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/argumentProcessor.test.ts" timestamp="2025-10-09T09:06:18.948Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.004481364">
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should append the full command if args are provided" time="0.002908516">
        </testcase>
        <testcase classname="src/services/prompt-processors/argumentProcessor.test.ts" name="Argument Processors &gt; DefaultArgumentProcessor &gt; should NOT append the full command if no args are provided" time="0.000494004">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/atFileProcessor.test.ts" timestamp="2025-10-09T09:06:18.948Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.01863046">
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if no @{ trigger is present" time="0.003255788">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; should not change the prompt if config service is missing" time="0.001175123">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace a single valid @{path/to/file.txt} placeholder" time="0.001997313">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should replace multiple different @{...} placeholders" time="0.000779271">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should handle placeholders at the beginning, middle, and end" time="0.000533095">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should correctly parse paths that contain balanced braces" time="0.000889103">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Parsing Logic &gt; should throw an error if the prompt contains an unclosed trigger" time="0.002592462">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; Integration and Error Handling &gt; should leave the placeholder unmodified if readPathFromWorkspace throws" time="0.001630735">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{not-found.txt}&apos;: File not found. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with an ERROR on failure" time="0.002537291">
            <system-err>
[AtFileProcessor] Failed to inject content for &apos;@{bad-file.txt}&apos;: Access denied. Leaving placeholder in prompt.

            </system-err>
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should call ui.addItem with a WARNING if the file was ignored" time="0.000976555">
        </testcase>
        <testcase classname="src/services/prompt-processors/atFileProcessor.test.ts" name="AtFileProcessor &gt; UI Feedback &gt; should NOT call ui.addItem on success" time="0.000591213">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/injectionParser.test.ts" timestamp="2025-10-09T09:06:18.948Z" hostname="uby" tests="21" failures="0" errors="0" skipped="0" time="0.007982557">
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should return an empty array if no trigger is present" time="0.001876759">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract a single, simple injection" time="0.000256744">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should extract multiple injections" time="0.00087627">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Basic Functionality &gt; should handle different triggers (e.g., @{)" time="0.000355668">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle injections at the start and end of the prompt" time="0.000254901">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle adjacent injections" time="0.000219226">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should handle empty injections" time="0.00011919">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should trim whitespace within the content" time="0.000116655">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore similar patterns that are not the exact trigger" time="0.000139077">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should ignore extra closing braces before the trigger" time="0.000119671">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Positioning and Edge Cases &gt; should stop parsing at the first balanced closing brace (non-greedy)" time="0.000126784">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with simple nested braces (e.g., JSON)" time="0.000250654">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse content with shell constructs (e.g., awk)" time="0.000201432">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse multiple levels of nesting" time="0.000159435">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly parse paths containing balanced braces" time="0.00014067">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Nested Braces (Balanced) &gt; should correctly handle an injection containing the trigger itself" time="0.000122366">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error for a simple unclosed injection" time="0.000721875">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw an error if the prompt ends inside a nested block" time="0.000159806">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should include the context name in the error message if provided" time="0.000122126">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should throw if content contains unbalanced braces (e.g., missing closing)" time="0.000125142">
        </testcase>
        <testcase classname="src/services/prompt-processors/injectionParser.test.ts" name="extractInjections &gt; Error Handling (Unbalanced/Unclosed) &gt; should clearly state that unbalanced braces in content are not supported in the error" time="0.000121875">
        </testcase>
    </testsuite>
    <testsuite name="src/services/prompt-processors/shellProcessor.test.ts" timestamp="2025-10-09T09:06:18.949Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.051713086">
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw an error if config is missing" time="0.007094184">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not change the prompt if no shell injections are present" time="0.001732573">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process a single valid shell injection if allowed" time="0.004232404">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should process multiple valid shell injections if all are allowed" time="0.001500203">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError if a command is not allowed in default mode" time="0.001268555">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should NOT throw ConfirmationRequiredError if a command is not allowed but approval mode is YOLO" time="0.001064728">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should still throw an error for a hard-denied command even in YOLO mode" time="0.001475267">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with the correct command" time="0.000749906">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should throw ConfirmationRequiredError with multiple commands if multiple are disallowed" time="0.000656523">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should not execute any commands if at least one requires confirmation" time="0.000607063">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should only request confirmation for disallowed commands in a mixed prompt" time="0.000584721">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should execute all commands if they are on the session allowlist" time="0.002086096">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should trim whitespace from the command inside the injection before interpolation" time="0.001113799">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; should handle an empty command inside the injection gracefully (skips execution)" time="0.000776655">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append exit code and command name on failure" time="0.000718548">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should append signal info and command name if terminated by signal" time="0.000593156">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should throw a detailed error if the shell fails to spawn" time="0.00082739">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Error Reporting &gt; should report abort status with command name if aborted" time="0.002674725">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement if no shell injections are present (optimization path)" time="0.000948353">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform raw replacement outside !{} blocks" time="0.000743735">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform escaped replacement inside !{} blocks" time="0.000808124">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should handle both raw (outside) and escaped (inside) injection simultaneously" time="0.001070719">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should perform security checks on the final, resolved (escaped) command" time="0.001767027">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Context-Aware Argument Interpolation ({{args}}) &gt; should report the resolved command if a hard denial occurs" time="0.00078434">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should correctly handle multiline arguments" time="0.000749626">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;spaces&apos;" time="0.000649009">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;double quotes&apos;" time="0.000590712">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;single quotes&apos;" time="0.000690346">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (backticks)&apos;" time="0.000605349">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command substitution (dollar)&apos;" time="0.000602134">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;variable expansion&apos;" time="0.002531109">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (semicolon)&apos;" time="0.003383745">
        </testcase>
        <testcase classname="src/services/prompt-processors/shellProcessor.test.ts" name="ShellProcessor &gt; Real-World Escaping Scenarios &gt; should safely escape args containing &apos;command chaining (ampersand)&apos;" time="0.00184486">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/install.test.ts" timestamp="2025-10-09T09:06:18.950Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.008686558">
        <testcase classname="src/commands/extensions/install.test.ts" name="extensions install command &gt; should fail if no source is provided" time="0.006337626">
        </testcase>
        <testcase classname="src/commands/extensions/install.test.ts" name="extensions install command &gt; should fail if both git source and local path are provided" time="0.001562218">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/extensions/uninstall.test.ts" timestamp="2025-10-09T09:06:18.950Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.006799359">
        <testcase classname="src/commands/extensions/uninstall.test.ts" name="extensions uninstall command &gt; should fail if no source is provided" time="0.006041298">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/add.test.ts" timestamp="2025-10-09T09:06:18.950Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.037323055">
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add a stdio server to project settings" time="0.018981219">
            <system-out>
MCP server &quot;my-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add an sse server to user settings" time="0.003839939">
            <system-out>
MCP server &quot;sse-server&quot; added to user settings. (sse)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should add an http server to project settings" time="0.0041653">
            <system-out>
MCP server &quot;http-server&quot; added to project settings. (http)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should handle MCP server args with -- separator" time="0.004162575">
            <system-out>
MCP server &quot;my-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/add.test.ts" name="mcp add command &gt; should handle unknown options as MCP server args" time="0.004705609">
            <system-out>
MCP server &quot;test-server&quot; added to project settings. (stdio)

            </system-out>
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/list.test.ts" timestamp="2025-10-09T09:06:18.950Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.007629294">
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display message when no servers configured" time="0.00348909">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display different server types with connected status" time="0.001760234">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should display disconnected status when connection fails" time="0.00052474">
        </testcase>
        <testcase classname="src/commands/mcp/list.test.ts" name="mcp list command &gt; should merge extension servers with config servers" time="0.000445955">
        </testcase>
    </testsuite>
    <testsuite name="src/commands/mcp/remove.test.ts" timestamp="2025-10-09T09:06:18.951Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.014900915">
        <testcase classname="src/commands/mcp/remove.test.ts" name="mcp remove command &gt; should remove a server from project settings" time="0.01191201">
            <system-out>
Server &quot;test-server&quot; removed from project settings.

            </system-out>
        </testcase>
        <testcase classname="src/commands/mcp/remove.test.ts" name="mcp remove command &gt; should show a message if server not found" time="0.002075387">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/aboutCommand.test.ts" timestamp="2025-10-09T09:06:18.951Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.012517159">
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should have the correct name and description" time="0.003807088">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should call addItem with all version info" time="0.003571462">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show the correct sandbox environment variable" time="0.001548643">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should show sandbox-exec profile when applicable" time="0.000882061">
        </testcase>
        <testcase classname="src/ui/commands/aboutCommand.test.ts" name="aboutCommand &gt; should not show ide client when it is not detected" time="0.000918368">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/approvalModeCommand.test.ts" timestamp="2025-10-09T09:06:18.951Z" hostname="uby" tests="19" failures="0" errors="0" skipped="0" time="0.018867529">
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should have the correct command properties" time="0.002934896">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should show current mode, options, and usage when no arguments provided" time="0.00102235">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when config is not available" time="0.000803666">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should change approval mode when valid mode is provided" time="0.002265478">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should accept canonical auto-edit mode value" time="0.000588237">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should accept auto-edit alias for compatibility" time="0.000675749">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when invalid mode is provided" time="0.000594209">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when setApprovalMode throws an error" time="0.000511054">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting auto-edit with user scope via nested subcommands" time="0.000774933">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting plan with project scope via nested subcommands" time="0.000780844">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow selecting plan with session scope via nested subcommands" time="0.000668445">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should allow providing a scope argument after selecting a mode subcommand" time="0.000678625">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support --user plan pattern (scope first)" time="0.000565305">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support plan --user pattern (mode first)" time="0.000781936">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should support --project auto-edit pattern" time="0.000781695">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when only scope flag is provided" time="0.000675559">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should display error when multiple scope flags are provided" time="0.000609767">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should surface a helpful error when scope subcommands receive extra arguments" time="0.000568772">
        </testcase>
        <testcase classname="src/ui/commands/approvalModeCommand.test.ts" name="approvalModeCommand &gt; should provide completion for approval modes" time="0.001175813">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/authCommand.test.ts" timestamp="2025-10-09T09:06:18.951Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.004998981">
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should return a dialog action to open the auth dialog" time="0.003204655">
        </testcase>
        <testcase classname="src/ui/commands/authCommand.test.ts" name="authCommand &gt; should have the correct name and description" time="0.000647247">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/bugCommand.test.ts" timestamp="2025-10-09T09:06:18.952Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007374422">
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should generate the default GitHub issue URL" time="0.005186949">
        </testcase>
        <testcase classname="src/ui/commands/bugCommand.test.ts" name="bugCommand &gt; should use a custom URL template from config if provided" time="0.00092548">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/chatCommand.test.ts" timestamp="2025-10-09T09:06:18.952Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.018654925">
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; should have the correct main command definition" time="0.002323615">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should inform when no checkpoints are found" time="0.001229193">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should list found checkpoints" time="0.001261893">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; list subcommand &gt; should handle invalid date formats gracefully" time="0.000724018">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return an error if tag is missing" time="0.00075771">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should inform if conversation history is empty or only contains system context" time="0.001026718">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should return confirm_action if checkpoint already exists" time="0.001895094">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; save subcommand &gt; should save the conversation if overwrite is confirmed" time="0.001067283">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should return an error if tag is missing" time="0.000976355">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should inform if checkpoint is not found" time="0.000917787">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; should resume a conversation" time="0.000970824">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should provide completion suggestions" time="0.000863056">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; resume subcommand &gt; completion &gt; should suggest filenames sorted by modified time (newest first)" time="0.00084418">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if tag is missing" time="0.00064401">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should return an error if checkpoint is not found" time="0.000465531">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; should delete the conversation" time="0.000537965">
        </testcase>
        <testcase classname="src/ui/commands/chatCommand.test.ts" name="chatCommand &gt; delete subcommand &gt; completion &gt; should provide completion suggestions" time="0.000689254">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/clearCommand.test.ts" timestamp="2025-10-09T09:06:18.952Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007279005">
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should set debug message, reset chat, reset telemetry, and clear UI when config is available" time="0.004398862">
        </testcase>
        <testcase classname="src/ui/commands/clearCommand.test.ts" name="clearCommand &gt; should not attempt to reset chat if config service is not available" time="0.001669747">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/compressCommand.test.ts" timestamp="2025-10-09T09:06:18.952Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.017710149">
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should do nothing if a compression is already pending" time="0.005943737">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should set pending item, call tryCompressChat, and add result on success" time="0.006710225">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat returns falsy" time="0.001494302">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should add an error message if tryCompressChat throws" time="0.001426637">
        </testcase>
        <testcase classname="src/ui/commands/compressCommand.test.ts" name="compressCommand &gt; should clear the pending item in a finally block" time="0.000642097">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/copyCommand.test.ts" timestamp="2025-10-09T09:06:18.952Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.01535716">
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no history is available" time="0.003241012">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when history is empty" time="0.000696077">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no AI messages are found in history" time="0.000745568">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should copy last AI message to clipboard successfully" time="0.001463786">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle multiple text parts in AI message" time="0.000800409">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should filter out non-text parts" time="0.000940769">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should get the last AI message when multiple AI messages exist" time="0.000704432">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle clipboard copy error" time="0.002217048">
            <system-out>
Clipboard access denied

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle non-Error clipboard errors" time="0.000934588">
            <system-out>
String error

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should return info message when no text parts found in AI message" time="0.000974231">
        </testcase>
        <testcase classname="src/ui/commands/copyCommand.test.ts" name="copyCommand &gt; should handle unavailable config service" time="0.00121729">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/corgiCommand.test.ts" timestamp="2025-10-09T09:06:18.953Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.004646349">
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should call the toggleCorgiMode function on the UI context" time="0.002792683">
        </testcase>
        <testcase classname="src/ui/commands/corgiCommand.test.ts" name="corgiCommand &gt; should have the correct name and description" time="0.0005947">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/directoryCommand.test.tsx" timestamp="2025-10-09T09:06:18.953Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.008586823">
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; show &gt; should display the list of directories" time="0.003784707">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if no path is provided" time="0.000807884">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory and show a success message for a single path" time="0.000803916">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should call addDirectory for each path and show a success message for multiple paths" time="0.000434463">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should show an error if addDirectory throws an exception" time="0.000476431">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; add &gt; should handle a mix of successful and failed additions" time="0.000675047">
        </testcase>
        <testcase classname="src/ui/commands/directoryCommand.test.tsx" name="directoryCommand &gt; should correctly expand a Windows-style home directory path" time="0.000467844">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/docsCommand.test.ts" timestamp="2025-10-09T09:06:18.953Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.008187816">
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should add an info message and call &apos;open&apos; in a non-sandbox environment" time="0.004904817">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should only add an info message in a sandbox environment" time="0.001424022">
        </testcase>
        <testcase classname="src/ui/commands/docsCommand.test.ts" name="docsCommand &gt; should not open browser for &apos;sandbox-exec&apos;" time="0.000689445">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/editorCommand.test.ts" timestamp="2025-10-09T09:06:18.953Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.004503235">
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should return a dialog action to open the editor dialog" time="0.003038426">
        </testcase>
        <testcase classname="src/ui/commands/editorCommand.test.ts" name="editorCommand &gt; should have the correct name and description" time="0.000315543">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/exportCommand.test.ts" timestamp="2025-10-09T09:06:18.953Z" hostname="uby" tests="8" failures="3" errors="0" skipped="0" time="0.042771888">
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should have correct name and description" time="0.002052945">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should export full conversation with default filename to conversations dir" time="0.028564043">
            <failure message="expected &quot;spy&quot; to be called with arguments: [ &apos;/mock/path/conversations&apos;, …(1) ][90m

Received: 

[1m  1st spy call:

[22m[2m  [[22m
[32m-   &quot;/mock/path/conversations&quot;,[90m
[31m+   &quot;/mock/path/conversations/conversation.md&quot;,[90m
[2m    {[22m
[2m      &quot;recursive&quot;: true,[22m
[2m    },[22m
[2m  ][22m
[39m[90m

Number of calls: [1m1[22m
[39m" type="AssertionError">
AssertionError: expected &quot;spy&quot; to be called with arguments: [ &apos;/mock/path/conversations&apos;, …(1) ]

Received: 

  1st spy call:

  [
-   &quot;/mock/path/conversations&quot;,
+   &quot;/mock/path/conversations/conversation.md&quot;,
    {
      &quot;recursive&quot;: true,
    },
  ]


Number of calls: 1

 ❯ src/ui/commands/exportCommand.test.ts:141:27
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle compact option" time="0.002454247">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle report option" time="0.001064297">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle invalid option" time="0.00192038">
            <failure message="Cannot read properties of undefined (reading &apos;length&apos;)" type="TypeError">
TypeError: Cannot read properties of undefined (reading &apos;length&apos;)
 ❯ action src/ui/commands/exportCommand.ts:20:17
 ❯ src/ui/commands/exportCommand.test.ts:217:11
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle no history" time="0.001546058">
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle custom filename with option" time="0.002141719">
            <failure message="expected &quot;spy&quot; to be called with arguments: [ &apos;/mock/path/reports&apos;, …(1) ][90m

Received: 

[1m  1st spy call:

[22m[2m  [[22m
[32m-   &quot;/mock/path/reports&quot;,[90m
[31m+   &quot;/mock/path/reports/my-report.md&quot;,[90m
[2m    {[22m
[2m      &quot;recursive&quot;: true,[22m
[2m    },[22m
[2m  ][22m
[39m[90m

Number of calls: [1m1[22m
[39m" type="AssertionError">
AssertionError: expected &quot;spy&quot; to be called with arguments: [ &apos;/mock/path/reports&apos;, …(1) ]

Received: 

  1st spy call:

  [
-   &quot;/mock/path/reports&quot;,
+   &quot;/mock/path/reports/my-report.md&quot;,
    {
      &quot;recursive&quot;: true,
    },
  ]


Number of calls: 1

 ❯ src/ui/commands/exportCommand.test.ts:261:27
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/exportCommand.test.ts" name="exportCommand &gt; should handle export error" time="0.001608814">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/extensionsCommand.test.ts" timestamp="2025-10-09T09:06:18.954Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007403175">
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should display &quot;No active extensions.&quot; when none are found" time="0.005047721">
        </testcase>
        <testcase classname="src/ui/commands/extensionsCommand.test.ts" name="extensionsCommand &gt; should list active extensions when they are found" time="0.000964042">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/helpCommand.test.ts" timestamp="2025-10-09T09:06:18.954Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.007322326">
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should add a help message to the UI history" time="0.005278368">
        </testcase>
        <testcase classname="src/ui/commands/helpCommand.test.ts" name="helpCommand &gt; should have the correct command properties" time="0.000801993">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/ideCommand.test.ts" timestamp="2025-10-09T09:06:18.954Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="5.020917461">
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return null if config is not provided" time="0.001897328">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should return the ide command" time="0.001776384">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; should show disable command when connected" time="0.001020095">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connected status" time="0.001375092">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show connecting status" time="0.000391544">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status" time="0.00029727">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; status subcommand &gt; should show disconnected status with details" time="0.000276692">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should install the extension" time="5.012158279">
        </testcase>
        <testcase classname="src/ui/commands/ideCommand.test.ts" name="ideCommand &gt; install subcommand &gt; should show an error if installation fails" time="0.000518709">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/initCommand.test.ts" timestamp="2025-10-09T09:06:18.955Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.010675725">
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should ask for confirmation if QWEN.md already exists and is non-empty" time="0.003707924">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should create QWEN.md and submit a prompt if it does not exist" time="0.002595839">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should proceed to initialize when QWEN.md exists but is empty" time="0.000937683">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should regenerate QWEN.md when overwrite is confirmed" time="0.000966156">
        </testcase>
        <testcase classname="src/ui/commands/initCommand.test.ts" name="initCommand &gt; should return an error if config is not available" time="0.001130229">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/loggingCommand.test.ts" timestamp="2025-10-09T09:06:18.955Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.010481276">
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; enables logging when /logging on is issued" time="0.005645146">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; disables logging when /logging off is issued" time="0.001341921">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; reports status when invoked without arguments" time="0.001237838">
        </testcase>
        <testcase classname="src/ui/commands/loggingCommand.test.ts" name="loggingCommand &gt; shows usage for unknown arguments" time="0.000792956">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/mcpCommand.test.ts" timestamp="2025-10-09T09:06:18.955Z" hostname="uby" tests="35" failures="0" errors="0" skipped="0" time="0.038546036">
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if config is not available" time="0.003481717">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; basic functionality &gt; should show an error if tool registry is not available" time="0.001137924">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; no MCP servers configured &gt; should display a message with a URL when no MCP servers are configured" time="0.000609416">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display configured MCP servers with status indicators and their tools" time="0.00180638">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display tool descriptions when desc argument is used" time="0.000986073">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should not display descriptions when nodesc argument is used" time="0.000647046">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should indicate when a server has no tools" time="0.000644682">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should show startup indicator when servers are connecting" time="0.000654009">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display the extension name for servers from extensions" time="0.000472563">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display blocked MCP servers" time="0.00051913">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; with configured MCP servers &gt; should display both active and blocked servers correctly" time="0.000557731">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should display tool schemas when schema argument is used" time="0.000905023">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; schema functionality &gt; should handle tools without parameter schemas gracefully" time="0.00155207">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;descriptions&quot; as alias for &quot;desc&quot;" time="0.000807423">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodescriptions&quot; as alias for &quot;nodesc&quot;" time="0.000734227">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle mixed case arguments" time="0.000469258">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;schema desc&quot;" time="0.000463116">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle multiple arguments - &quot;desc schema&quot;" time="0.000423182">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;schema&quot; alone showing descriptions" time="0.000402054">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;schema&quot; - &quot;schema nodesc&quot;" time="0.000509973">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding &quot;desc&quot; - &quot;desc nodesc&quot;" time="0.000569222">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle &quot;nodesc&quot; overriding both &quot;desc&quot; and &quot;schema&quot; - &quot;desc schema nodesc&quot;" time="0.000555567">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle extra whitespace in arguments" time="0.000534628">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle empty arguments gracefully" time="0.000588688">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; argument parsing &gt; should handle unknown arguments gracefully" time="0.000472954">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle empty server names gracefully" time="0.000624164">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; edge cases &gt; should handle servers with special characters in names" time="0.000775684">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should list OAuth-enabled servers when no server name is provided" time="0.00155809">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should show message when no OAuth servers are configured" time="0.001148914">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should authenticate with a specific server" time="0.002784537">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle authentication errors" time="0.002022008">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; auth subcommand &gt; should handle non-existent server" time="0.001558421">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should refresh the list of tools and display the status" time="0.002853595">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if config is not available" time="0.00151998">
        </testcase>
        <testcase classname="src/ui/commands/mcpCommand.test.ts" name="mcpCommand &gt; refresh subcommand &gt; should show an error if tool registry is not available" time="0.001356377">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/memoryCommand.test.ts" timestamp="2025-10-09T09:06:18.956Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.017048215">
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display a message if memory is empty" time="0.006224807">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory show &gt; should display the memory content and file count if it exists" time="0.001097949">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return an error message if no arguments are provided" time="0.000888001">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return a tool action and add an info message when arguments are provided" time="0.000711245">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --global flag and add scope to tool args" time="0.000538956">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should handle --project flag and add scope to tool args" time="0.000689494">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory add &gt; should return error if flag is provided but no fact follows" time="0.000549185">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with content" time="0.001355976">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display success message when memory is refreshed with no content" time="0.000758162">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should display an error message if refreshing fails" time="0.001257394">
        </testcase>
        <testcase classname="src/ui/commands/memoryCommand.test.ts" name="memoryCommand &gt; /memory refresh &gt; should not throw if config service is unavailable" time="0.001274586">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/modelCommand.test.ts" timestamp="2025-10-09T09:06:18.956Z" hostname="uby" tests="9" failures="2" errors="0" skipped="0" time="0.023005748">
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should have the correct name and description" time="0.002508076">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when config is not available" time="0.001417941">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when content generator config is not available" time="0.000900034">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error when auth type is not available" time="0.000800019">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for QWEN_OAUTH auth type" time="0.000672212">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return dialog action for USE_OPENAI auth type when model is available" time="0.011214871">
            <failure message="[vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;../models/availableModels.js&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/modelCommand.ts:96:9
 ❯ src/ui/commands/modelCommand.test.ts:126:20
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for USE_OPENAI auth type when no model is available" time="0.001957749">
            <failure message="[vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:
" type="Error">
Error: [vitest] No &quot;getLMStudioConfiguredModels&quot; export is defined on the &quot;../models/availableModels.js&quot; mock. Did you forget to return it from &quot;vi.mock&quot;?
If you need to partially mock a module, you can use &quot;importOriginal&quot; helper inside:

vi.mock(import(&quot;../models/availableModels.js&quot;), async (importOriginal) =&gt; {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})

 ❯ Object.action src/ui/commands/modelCommand.ts:96:9
 ❯ src/ui/commands/modelCommand.test.ts:143:20
            </failure>
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should return error for unsupported auth types" time="0.001471299">
        </testcase>
        <testcase classname="src/ui/commands/modelCommand.test.ts" name="modelCommand &gt; should handle undefined auth type" time="0.000502258">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/privacyCommand.test.ts" timestamp="2025-10-09T09:06:18.957Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.005897502">
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should return a dialog action to open the privacy dialog" time="0.00383514">
        </testcase>
        <testcase classname="src/ui/commands/privacyCommand.test.ts" name="privacyCommand &gt; should have the correct name and description" time="0.00078947">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/quitCommand.test.ts" timestamp="2025-10-09T09:06:18.957Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.007339087">
        <testcase classname="src/ui/commands/quitCommand.test.ts" name="quitCommand &gt; returns a QuitActionReturn object with the correct messages" time="0.006101579">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/restoreCommand.test.ts" timestamp="2025-10-09T09:06:18.957Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.038455408">
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return null if checkpointing is not enabled" time="0.008529848">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return the command if checkpointing is enabled" time="0.002287629">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if temp dir is not found" time="0.001980972">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should inform when no checkpoints are found if no args are passed" time="0.002343372">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should list available checkpoints if no args are passed" time="0.002819983">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should return an error if the specified file is not found" time="0.00211513">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should handle file read errors gracefully" time="0.002387884">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore a tool call and project state" time="0.004339061">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; action &gt; should restore even if only toolCall is present" time="0.002262122">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; should return an error for a checkpoint file missing the toolCall property" time="0.002322363">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array if temp dir is not found" time="0.001742391">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return an empty array on readdir error" time="0.001532183">
        </testcase>
        <testcase classname="src/ui/commands/restoreCommand.test.ts" name="restoreCommand &gt; completion &gt; should return a list of checkpoint names" time="0.001913618">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/settingsCommand.test.ts" timestamp="2025-10-09T09:06:18.958Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.005603839">
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should return a dialog action to open the settings dialog" time="0.003534654">
        </testcase>
        <testcase classname="src/ui/commands/settingsCommand.test.ts" name="settingsCommand &gt; should have the correct name and description" time="0.000647888">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/setupGithubCommand.test.ts" timestamp="2025-10-09T09:06:18.958Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.047425721">
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="setupGithubCommand &gt; returns a tool action to download github workflows and handles paths" time="0.031226465">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; creates a new .gitignore file when none exists" time="0.001172057">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; appends entries to existing .gitignore file" time="0.001089784">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not add duplicate entries" time="0.000782066">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; adds only missing entries when some already exist" time="0.000723507">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; does not get confused by entries in comments or as substrings" time="0.001720501">
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles file system errors gracefully" time="0.005933238">
            <system-out>
Failed to update .gitignore: Error: ENOENT: no such file or directory, open &apos;/tmp/update-gitignore-xITFxz/non-existent/.gitignore&apos;
[90m    at open (node:internal/fs/promises:642:25)[39m
[90m    at Object.writeFile (node:internal/fs/promises:1249:14)[39m
    at Module.updateGitignore [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/commands/setupGithubCommand.ts:71:7[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/commands/setupGithubCommand.test.ts:218:5
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:20 {
  errno: [33m-2[39m,
  code: [32m&apos;ENOENT&apos;[39m,
  syscall: [32m&apos;open&apos;[39m,
  path: [32m&apos;/tmp/update-gitignore-xITFxz/non-existent/.gitignore&apos;[39m
}

            </system-out>
        </testcase>
        <testcase classname="src/ui/commands/setupGithubCommand.test.ts" name="updateGitignore &gt; handles permission errors gracefully" time="0.00349995">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/statsCommand.test.ts" timestamp="2025-10-09T09:06:18.958Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.010832826">
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display general session stats when run with no subcommand" time="0.007956047">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display model stats when using the &quot;model&quot; subcommand" time="0.000801492">
        </testcase>
        <testcase classname="src/ui/commands/statsCommand.test.ts" name="statsCommand &gt; should display tool stats when using the &quot;tools&quot; subcommand" time="0.000847136">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/terminalSetupCommand.test.ts" timestamp="2025-10-09T09:06:18.958Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.005057339">
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should have correct metadata" time="0.001924598">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return success message when terminal setup succeeds" time="0.001116134">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should append restart message when terminal setup requires restart" time="0.000272884">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should return error message when terminal setup fails" time="0.000196603">
        </testcase>
        <testcase classname="src/ui/commands/terminalSetupCommand.test.ts" name="terminalSetupCommand &gt; should handle exceptions from terminal setup" time="0.000289155">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/themeCommand.test.ts" timestamp="2025-10-09T09:06:18.958Z" hostname="uby" tests="2" failures="0" errors="0" skipped="0" time="0.004661056">
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should return a dialog action to open the theme dialog" time="0.003057602">
        </testcase>
        <testcase classname="src/ui/commands/themeCommand.test.ts" name="themeCommand &gt; should have the correct name and description" time="0.000561438">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/commands/toolsCommand.test.ts" timestamp="2025-10-09T09:06:18.958Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.008825515">
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display an error if the tool registry is unavailable" time="0.004726447">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should display &quot;No tools available&quot; when none are found" time="0.001483252">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools without descriptions by default" time="0.000902628">
        </testcase>
        <testcase classname="src/ui/commands/toolsCommand.test.ts" name="toolsCommand &gt; should list tools with descriptions when &quot;desc&quot; arg is passed" time="0.000460581">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/AuthDialog.test.tsx" timestamp="2025-10-09T09:06:18.958Z" hostname="uby" tests="10" failures="2" errors="0" skipped="0" time="0.468847205">
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should show an error if the initial auth type is invalid" time="0.036004337">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should detect GEMINI_API_KEY environment variable" time="0.008212281">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should not show the GEMINI_API_KEY message if QWEN_DEFAULT_AUTH_TYPE is set to something else" time="0.009029722">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; GEMINI_API_KEY environment variable &gt; should show the GEMINI_API_KEY message if QWEN_DEFAULT_AUTH_TYPE is set to use api key" time="0.008580161">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should select the auth type specified by QWEN_DEFAULT_AUTH_TYPE" time="0.00803865">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should fall back to default if QWEN_DEFAULT_AUTH_TYPE is not set" time="0.017611877">
            <failure message="expected &apos;╭────────────────────────────────────…&apos; to contain &apos;● 1. Qwen OAuth&apos;" type="AssertionError">
AssertionError: expected &apos;╭────────────────────────────────────…&apos; to contain &apos;● 1. Qwen OAuth&apos;

- Expected
+ Received

- ● 1. Qwen OAuth
+ ╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
+ │                                                                                                  │
+ │ Get started                                                                                      │
+ │                                                                                                  │
+ │ How would you like to authenticate for this project?                                             │
+ │                                                                                                  │
+ │ ● 1. OpenRouter (OpenAI-compatible)                                                              │
+ │   2. LM Studio (local)                                                                           │
+ │                                                                                                  │
+ │ (Use Enter to Set Auth)                                                                          │
+ │                                                                                                  │
+ │ Terms of Services and Privacy Notice for Qwen Code                                               │
+ │                                                                                                  │
+ │ https://github.com/QwenLM/Qwen3-Coder/blob/main/README.md                                        │
+ │                                                                                                  │
+ ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯

 ❯ src/ui/components/AuthDialog.test.tsx:262:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; QWEN_DEFAULT_AUTH_TYPE environment variable &gt; should show an error and fall back to default if QWEN_DEFAULT_AUTH_TYPE is invalid" time="0.017219862">
            <failure message="expected &apos;╭────────────────────────────────────…&apos; to contain &apos;● 1. Qwen OAuth&apos;" type="AssertionError">
AssertionError: expected &apos;╭────────────────────────────────────…&apos; to contain &apos;● 1. Qwen OAuth&apos;

- Expected
+ Received

- ● 1. Qwen OAuth
+ ╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
+ │                                                                                                  │
+ │ Get started                                                                                      │
+ │                                                                                                  │
+ │ How would you like to authenticate for this project?                                             │
+ │                                                                                                  │
+ │ ● 1. OpenRouter (OpenAI-compatible)                                                              │
+ │   2. LM Studio (local)                                                                           │
+ │                                                                                                  │
+ │ (Use Enter to Set Auth)                                                                          │
+ │                                                                                                  │
+ │ Terms of Services and Privacy Notice for Qwen Code                                               │
+ │                                                                                                  │
+ │ https://github.com/QwenLM/Qwen3-Coder/blob/main/README.md                                        │
+ │                                                                                                  │
+ ╰──────────────────────────────────────────────────────────────────────────────────────────────────╯

 ❯ src/ui/components/AuthDialog.test.tsx:300:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should prevent exiting when no auth method is selected and show error message" time="0.127488053">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should not exit if there is already an error message" time="0.113484747">
        </testcase>
        <testcase classname="src/ui/components/AuthDialog.test.tsx" name="AuthDialog &gt; should allow exiting when auth method is already selected" time="0.121544165">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ContextSummaryDisplay.test.tsx" timestamp="2025-10-09T09:06:18.959Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.026460735">
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on a single line on a wide screen" time="0.016116893">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should render on multiple lines on a narrow screen" time="0.004561272">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should switch layout at the 80-column breakpoint" time="0.003323984">
        </testcase>
        <testcase classname="src/ui/components/ContextSummaryDisplay.test.tsx" name="&lt;ContextSummaryDisplay /&gt; &gt; should not render empty parts" time="0.001244501">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/FolderTrustDialog.test.tsx" timestamp="2025-10-09T09:06:18.959Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.120879927">
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should render the dialog with title and description" time="0.029995489">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call onSelect with DO_NOT_TRUST when escape is pressed and not restarting" time="0.058791431">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call onSelect when escape is pressed and is restarting" time="0.008560444">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should display restart message when isRestarting is true" time="0.006479228">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should call process.exit when &quot;r&quot; is pressed and isRestarting is true" time="0.008397824">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/FolderTrustDialog.test.tsx" name="FolderTrustDialog &gt; should not call process.exit when &quot;r&quot; is pressed and isRestarting is false" time="0.007401483">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Footer.test.tsx" timestamp="2025-10-09T09:06:18.960Z" hostname="uby" tests="13" failures="4" errors="0" skipped="0" time="0.133276574">
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; renders the component" time="0.035148555">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display shortened path on a wide terminal" time="0.018420933">
            <failure message="expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;...bar/and/some/more/directories/to/m…&apos;" type="AssertionError">
AssertionError: expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;...bar/and/some/more/directories/to/m…&apos;

- Expected
+ Received

- ...bar/and/some/more/directories/to/make/it/long
+ ...bar/and/some/more/directories/to/ma  no sandbox      gemini-pro (130,972/131,072 tokens
+ ke/it/long (main*)                      (see /docs)    available) (100% context left)

 ❯ src/ui/components/Footer.test.tsx:62:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should display only the base directory name on a narrow terminal" time="0.004140143">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use wide layout at 80 columns" time="0.00605871">
            <failure message="expected &apos;...e/directories/to/make/it/lo  no sa…&apos; to contain &apos;...e/directories/to/make/it/long&apos;" type="AssertionError">
AssertionError: expected &apos;...e/directories/to/make/it/lo  no sa…&apos; to contain &apos;...e/directories/to/make/it/long&apos;

- Expected
+ Received

- ...e/directories/to/make/it/long
+ ...e/directories/to/make/it/lo  no sandbox (see   gemini-pro (130,972/131,072 tokens available)
+ ng (main*)                      /docs)           (100% context left)

 ❯ src/ui/components/Footer.test.tsx:75:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; path display &gt; should use narrow layout at 79 columns" time="0.003639087">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the branch name when provided" time="0.005617755">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; does not display the branch name when not provided" time="0.00645868">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; displays the model name and context percentage" time="0.007077914">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display untrusted when isTrustedFolder is false" time="0.014897299">
            <failure message="expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;" type="AssertionError">
AssertionError: expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;

- Expected
+ Received

- untrusted
+ ...bar/and/some/more/directories/to/make/i untrus  gemini-pro (130,972/131,072 tokens available)
+ t/long (main*)                             ted    (100% context left)

 ❯ src/ui/components/Footer.test.tsx:113:27
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display custom sandbox info when SANDBOX env is set" time="0.008818041">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display macOS Seatbelt info when SANDBOX is sandbox-exec" time="0.006574534">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should display &quot;no sandbox&quot; when SANDBOX is not set and folder is trusted" time="0.00424664">
        </testcase>
        <testcase classname="src/ui/components/Footer.test.tsx" name="&lt;Footer /&gt; &gt; sandbox and trust info &gt; should prioritize untrusted message over sandbox info" time="0.006368002">
            <failure message="expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;" type="AssertionError">
AssertionError: expected &apos;...bar/and/some/more/directories/to/m…&apos; to contain &apos;untrusted&apos;

- Expected
+ Received

- untrusted
+ ...bar/and/some/more/directories/to/make/i untrus  gemini-pro (130,972/131,072 tokens available)
+ t/long (main*)                             ted    (100% context left)

 ❯ src/ui/components/Footer.test.tsx:154:27
            </failure>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/Header.test.tsx" timestamp="2025-10-09T09:06:18.960Z" hostname="uby" tests="4" failures="1" errors="0" skipped="0" time="0.066754081">
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders the long logo on a wide terminal" time="0.04072854">
            <failure message="expected &apos;\n █████                             …&apos; to contain &apos;\n █████                             …&apos;" type="AssertionError">
AssertionError: expected &apos;\n █████                             …&apos; to contain &apos;\n █████                             …&apos;

- Expected
+ Received


-  █████                                  █████████            ████       █████████               █████         
+  █████                                  █████████            ████       █████████               █████
- ░░███                                  ███░░░░░███          ░░███      ███░░░░░███             ░░███          
+ ░░███                                  ███░░░░░███          ░░███      ███░░░░░███             ░░███
-  ░███         ██████  █████ ███ █████ ███     ░░░   ██████   ░███     ███     ░░░   ██████   ███████   ██████ 
+  ░███         ██████  █████ ███ █████ ███     ░░░   ██████   ░███     ███     ░░░   ██████   ███████   ██████
   ░███        ███░░███░░███ ░███░░███ ░███          ░░░░░███  ░███    ░███          ███░░███ ███░░███  ███░░███
-  ░███       ░███ ░███ ░███ ░███ ░███ ░███           ███████  ░███    ░███         ░███ ░███░███ ░███ ░███████ 
+  ░███       ░███ ░███ ░███ ░███ ░███ ░███           ███████  ░███    ░███         ░███ ░███░███ ░███ ░███████
-  ░███      █░███ ░███ ░░███████████  ░░███     ███ ███░░███  ░███    ░░███     ███░███ ░███░███ ░███ ░███░░░  
+  ░███      █░███ ░███ ░░███████████  ░░███     ███ ███░░███  ░███    ░░███     ███░███ ░███░███ ░███ ░███░░░
-  ███████████░░██████   ░░████░████    ░░█████████ ░░████████ █████    ░░█████████ ░░██████ ░░████████░░██████ 
+  ███████████░░██████   ░░████░████    ░░█████████ ░░████████ █████    ░░█████████ ░░██████ ░░████████░░██████
- ░░░░░░░░░░░  ░░░░░░     ░░░░ ░░░░      ░░░░░░░░░   ░░░░░░░░ ░░░░░      ░░░░░░░░░   ░░░░░░   ░░░░░░░░  ░░░░░░   
-                                                                                                    
+ ░░░░░░░░░░░  ░░░░░░     ░░░░ ░░░░      ░░░░░░░░░   ░░░░░░░░ ░░░░░      ░░░░░░░░░   ░░░░░░   ░░░░░░░░  ░░░░░░
+


 ❯ src/ui/components/Header.test.tsx:25:25
            </failure>
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; renders custom ASCII art when provided" time="0.002339906">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; displays the version number when nightly is true" time="0.011081164">
        </testcase>
        <testcase classname="src/ui/components/Header.test.tsx" name="&lt;Header /&gt; &gt; does not display the version number when nightly is false" time="0.011356083">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/HistoryItemDisplay.test.tsx" timestamp="2025-10-09T09:06:18.961Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.069275642">
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type" time="0.021553855">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders UserMessage for &quot;user&quot; type with slash command" time="0.002760684">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders StatsDisplay for &quot;stats&quot; type" time="0.011279992">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders AboutBox for &quot;about&quot; type" time="0.008232499">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ModelStatsDisplay for &quot;model_stats&quot; type" time="0.004074963">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders ToolStatsDisplay for &quot;tool_stats&quot; type" time="0.003918904">
        </testcase>
        <testcase classname="src/ui/components/HistoryItemDisplay.test.tsx" name="&lt;HistoryItemDisplay /&gt; &gt; renders SessionSummaryDisplay for &quot;quit&quot; type" time="0.016083151">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/InputPrompt.test.tsx" timestamp="2025-10-09T09:06:18.961Z" hostname="uby" tests="61" failures="0" errors="0" skipped="0" time="6.628394663">
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getPreviousCommand on up arrow in shell mode" time="0.137219512">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.getNextCommand on down arrow in shell mode" time="0.109307234">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should set the buffer text when a shell history command is retrieved" time="0.112263539">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call shellHistory.addCommandToHistory on submit in shell mode" time="0.115654096">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call shell history methods when not in shell mode" time="0.219756459">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateUp for both up arrow and Ctrl+P when suggestions are showing" time="0.166333562">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should call completion.navigateDown for both down arrow and Ctrl+N when suggestions are showing" time="0.175303414">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT call completion navigation when suggestions are not showing" time="0.267710787">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle Ctrl+V when clipboard has an image" time="0.116803391">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should not insert anything when clipboard has no image" time="0.12337514">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle image save failure gracefully" time="0.11217736">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should insert image path at cursor position with proper spacing" time="0.116909056">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; clipboard image paste &gt; should handle errors during clipboard operations" time="0.119823234">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial parent command" time="0.116078912">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should append a sub-command when the parent command is already complete" time="0.117532429">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should handle the &quot;backspace&quot; edge case correctly" time="0.119606883">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a partial argument for a command" time="0.112574493">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete on Enter when suggestions are active, without submitting" time="0.112566388">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should complete a command based on its altNames" time="0.115216026">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should not submit on Enter when the buffer is empty or only contains whitespace" time="0.116228328">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when isPerfectMatch is true" time="0.114246385">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should submit directly on Enter when a complete leaf command is typed" time="0.115489873">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should autocomplete an @-path on Enter without submitting" time="0.111687815">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should add a newline on enter when the line ends with a backslash" time="0.113737433">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should clear the buffer on Ctrl+C if it has text" time="0.116740605">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; should NOT clear the buffer on Ctrl+C if it is empty" time="0.113690747">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after @ without spaces" time="0.069785054">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should trigger completion when cursor is after / without spaces" time="0.062378392">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following @" time="0.062158846">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is after space following /" time="0.060328562">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion when cursor is not after @ or /" time="0.08646568">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiline text correctly" time="0.062568644">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle single line slash command correctly" time="0.060151896">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters (emojis) correctly in paths" time="0.062862026">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with spaces after them" time="0.061891512">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in paths correctly" time="0.067252542">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should NOT trigger completion after unescaped space following escaped space" time="0.063862074">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle multiple escaped spaces in paths" time="0.067510709">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle escaped spaces in slash commands" time="0.069103093">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; cursor-based completion trigger &gt; should handle Unicode characters with escaped spaces" time="0.069591726">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should not call buffer.handleInput when vim mode is enabled and vim handles the input" time="0.116324546">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call buffer.handleInput when vim mode is enabled but vim does not handle the input" time="0.109081486">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; vim mode &gt; should call handleInput when vim mode is disabled" time="0.106504493">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should handle bracketed paste when not focused" time="0.109479903">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; unfocused paste &gt; should ignore regular keypresses when not focused" time="0.111736434">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \n newlines&apos;" time="0.108677119">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with extra slashes before \n newlines&apos;" time="0.107578127">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; multiline paste &gt; should handle multiline paste &apos;with \r\n newlines&apos;" time="0.108498118">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should clear buffer on second ESC press" time="0.156509511">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should reset escape state on any non-ESC key" time="0.060514026">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC in shell mode by disabling shell mode" time="0.106161859">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should handle ESC when completion suggestions are showing" time="0.108016097">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not call onEscapePromptChange when not provided" time="0.107526261">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; enhanced input UX - double ESC clear functionality &gt; should not interfere with existing keyboard shortcuts" time="0.156396503">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; invokes reverse search on Ctrl+R" time="0.106667264">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; resets reverse search state on Escape" time="0.158708015">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; completes the highlighted entry on Tab and exits reverse-search" time="0.084720263">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; submits the highlighted entry on Enter and exits reverse-search" time="0.063444924">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; reverse search &gt; text and cursor position should be restored after reverse search" time="0.10899163">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line in multiline input" time="0.108503428">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/InputPrompt.test.tsx" name="InputPrompt &gt; Ctrl+E keyboard shortcut &gt; should move cursor to end of current line for single line input" time="0.106784951">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to InputPrompt inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/LoadingIndicator.test.tsx" timestamp="2025-10-09T09:06:18.965Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.088882147">
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should not render when streamingState is Idle" time="0.019746493">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner, phrase, and time when streamingState is Responding" time="0.011458552">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render spinner (static), phrase but no time/cancel when streamingState is WaitingForConfirmation" time="0.004293457">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the currentLoadingPhrase correctly" time="0.004295391">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly when Responding" time="0.004000445">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the elapsedTime correctly in human-readable format" time="0.007222892">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should render rightContent when provided" time="0.003493939">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should transition correctly between states using rerender" time="0.008313037">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display fallback phrase if thought is empty" time="0.002965151">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should display the subject of a thought" time="0.002822007">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; should prioritize thought.subject over currentLoadingPhrase" time="0.005995544">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on a single line on a wide terminal" time="0.003378826">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should render on multiple lines on a narrow terminal" time="0.003599644">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use wide layout at 80 columns" time="0.002948671">
        </testcase>
        <testcase classname="src/ui/components/LoadingIndicator.test.tsx" name="&lt;LoadingIndicator /&gt; &gt; responsive layout &gt; should use narrow layout at 79 columns" time="0.00210441">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSelectionDialog.test.tsx" timestamp="2025-10-09T09:06:18.965Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.122140267">
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should setup escape key handler to call onCancel" time="0.038728152">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should not call onCancel for non-escape keys" time="0.008687891">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set correct initial index for current model" time="0.007033322">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should set initial index to 0 when current model is not found" time="0.00707037">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should call onSelect when a model is selected" time="0.0060858">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle empty models array" time="0.004455417">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should create correct option items with proper labels" time="0.006100908">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show vision indicator for vision models" time="0.008753121">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should show current indicator for the current model" time="0.013416351">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.006677604">
        </testcase>
        <testcase classname="src/ui/components/ModelSelectionDialog.test.tsx" name="ModelSelectionDialog &gt; should handle multiple onSelect calls correctly" time="0.013137556">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelStatsDisplay.test.tsx" timestamp="2025-10-09T09:06:18.966Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.106336743">
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should render &quot;no API calls&quot; message when there are no active models" time="0.02166541">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should not display conditional rows if no model has data for them" time="0.019625579">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display conditional rows if at least one model has data" time="0.019964787">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display stats for multiple models correctly" time="0.017295853">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.012455726">
        </testcase>
        <testcase classname="src/ui/components/ModelStatsDisplay.test.tsx" name="&lt;ModelStatsDisplay /&gt; &gt; should display a single model correctly" time="0.013107851">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ModelSwitchDialog.test.tsx" timestamp="2025-10-09T09:06:18.966Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.082102343">
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup RadioButtonSelect with correct options" time="0.026541855">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect when an option is selected" time="0.007391604">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with SwitchSessionToVL when second option is selected" time="0.0059016">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should call onSelect with ContinueWithCurrentModel when third option is selected" time="0.006429685">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should setup escape key handler to call onSelect with ContinueWithCurrentModel" time="0.006851005">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should not call onSelect for non-escape keys" time="0.005879298">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should set initial index to 0 (first option)" time="0.006500768">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; VisionSwitchOutcome enum &gt; should have correct enum values" time="0.000316244">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle multiple onSelect calls correctly" time="0.006880709">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should pass isFocused prop to RadioButtonSelect" time="0.004102624">
        </testcase>
        <testcase classname="src/ui/components/ModelSwitchDialog.test.tsx" name="ModelSwitchDialog &gt; should handle escape key multiple times" time="0.00370005">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/OpenAIKeyPrompt.test.tsx" timestamp="2025-10-09T09:06:18.966Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.138811956">
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should render the prompt correctly" time="0.063471493">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should show the component with proper styling" time="0.011314416">
        </testcase>
        <testcase classname="src/ui/components/OpenAIKeyPrompt.test.tsx" name="OpenAIKeyPrompt &gt; should handle paste with control characters" time="0.062525674">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/QwenOAuthProgress.test.tsx" timestamp="2025-10-09T09:06:18.966Z" hostname="uby" tests="22" failures="0" errors="0" skipped="0" time="0.254931333">
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state when deviceAuth is not provided" time="0.023754693">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Loading state (no deviceAuth) &gt; should render loading state with gray border" time="0.003242815">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should render authentication flow when deviceAuth is provided" time="0.003571332">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should display correct URL in Static component when QR code is generated" time="0.009897306">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format time correctly" time="0.003312123">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Authenticated state (with deviceAuth) &gt; should format single digit seconds with leading zero" time="0.004583163">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should countdown and call onTimeout when timer expires" time="0.040379706">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should update time remaining display" time="0.021466603">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timer functionality &gt; should use default 300 second timeout when deviceAuth is null" time="0.007473565">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Animated dots &gt; should cycle through animated dots" time="0.040889368">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should generate QR code when deviceAuth is provided" time="0.006829686">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should display QR code in Static component when available" time="0.020700166">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should handle QR code generation errors gracefully" time="0.006780885">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; QR Code functionality &gt; should not generate QR code when deviceAuth is null" time="0.004730184">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC key is pressed" time="0.017093068">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should call onCancel when ESC is pressed in loading state" time="0.005065735">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; User interactions &gt; should not call onCancel for other key presses" time="0.004152296">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should display initial timer value from deviceAuth" time="0.003369599">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Props changes &gt; should reset to loading state when deviceAuth becomes null" time="0.009363269">
            <system-err>
Failed to generate QR code: Error: QR Code generation failed
    at Object.&lt;anonymous&gt; [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.test.tsx:386:15[90m)[39m
    at Object.mockCall (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/spy[24m/dist/index.js:96:15)
    at Object.spy [as generate] (file:///home/atmandk/LowCal-dev/node_modules/[4mtinyspy[24m/dist/index.js:47:103)
    at generateQR [90m(/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:148:16[90m)[39m
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/QwenOAuthProgress.tsx:161:5
    at Object.react-stack-bottom-frame (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:15945:20)
    at runWithFiberInDEV (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:1738:13)
    at commitHookEffectListMount (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9516:29)
    at commitHookPassiveMountEffects (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:9639:11)
    at commitPassiveMountOnFiber (/home/atmandk/LowCal-dev/node_modules/[4mreact-reconciler[24m/cjs/react-reconciler.development.js:11364:13)

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render timeout state when authStatus is timeout" time="0.00412213">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should render default timeout message when no authMessage provided" time="0.005722028">
        </testcase>
        <testcase classname="src/ui/components/QwenOAuthProgress.test.tsx" name="QwenOAuthProgress &gt; Timeout state &gt; should call onCancel for any key press in timeout state" time="0.006564204">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SessionSummaryDisplay.test.tsx" timestamp="2025-10-09T09:06:18.967Z" hostname="uby" tests="1" failures="0" errors="0" skipped="0" time="0.042770134">
        <testcase classname="src/ui/components/SessionSummaryDisplay.test.tsx" name="&lt;SessionSummaryDisplay /&gt; &gt; renders the summary display with a title" time="0.041957532">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/SettingsDialog.test.tsx" timestamp="2025-10-09T09:06:18.967Z" hostname="uby" tests="39" failures="0" errors="0" skipped="0" time="3.596431797">
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should render the settings dialog with default state" time="0.046817756">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should show settings list with default values" time="0.01516298">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Initial Rendering &gt; should highlight first setting by default" time="0.016502826">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate down with arrow key" time="0.084727917">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate up with arrow key" time="0.120761729">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should navigate with vim keys (j/k)" time="0.122830373">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Navigation &gt; should not navigate beyond bounds" time="0.074186701">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should toggle setting with Enter key" time="0.077814446">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should toggle setting with Space key" time="0.083089468">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Toggling &gt; should handle vim mode setting specially" time="0.069065023">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Scope Selection &gt; should switch between scopes" time="0.118033174">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Scope Selection &gt; should reset to settings focus when scope is selected" time="0.043704652">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Restart Prompt &gt; should show restart prompt for restart-required settings" time="0.082458542">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Restart Prompt &gt; should handle restart request when r is pressed" time="0.070662145">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Escape Key Behavior &gt; should call onSelect with undefined when Escape is pressed" time="0.032195827">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Persistence &gt; should persist settings across scope changes" time="0.128606941">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Persistence &gt; should show different values for different scopes" time="0.01186872">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Handling &gt; should handle vim mode toggle errors gracefully" time="0.072753892">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
Failed to toggle vim mode: Error: Toggle failed
    at [90m/home/atmandk/LowCal-dev/packages/cli/[39msrc/ui/components/SettingsDialog.test.tsx:540:46
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:155:11
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:752:26
    at file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1897:20
    at new Promise (&lt;anonymous&gt;)
    at runWithTimeout (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1863:10)
    at runTest (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1574:12)
    at runSuite (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1729:8)
    at runSuite (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1729:8)
    at runSuite (file:///home/atmandk/LowCal-dev/node_modules/[4m@vitest/runner[24m/dist/chunk-hooks.js:1729:8)

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex State Management &gt; should track modified settings correctly" time="0.175805531">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Saving general.disableAutoUpdate immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex State Management &gt; should handle scrolling when there are many settings" time="0.171189348">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; VimMode Integration &gt; should sync with VimModeContext when vim mode is toggled" time="0.076951321">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should show correct display values for settings with different states" time="0.013694615">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should handle immediate settings save for non-restart-required settings" time="0.087898197">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should show restart prompt for restart-required settings" time="0.070677293">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Specific Settings Behavior &gt; should clear restart prompt when switching scopes" time="0.018019741">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Display Values &gt; should show correct values for inherited settings" time="0.011463922">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Settings Display Values &gt; should show override indicator for overridden settings" time="0.00974791">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle rapid key presses gracefully" time="0.120394861">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle Ctrl+C to reset current setting to default" time="0.071612152">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle Ctrl+L to reset current setting to default" time="0.070287262">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should handle navigation when only one setting exists" time="0.129720279">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Keyboard Shortcuts Edge Cases &gt; should properly handle Tab navigation between sections" time="0.025479881">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Recovery &gt; should handle malformed settings gracefully" time="0.013042921">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Error Recovery &gt; should handle missing setting definitions gracefully" time="0.013967891">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should handle complete user workflow: navigate, toggle, change scope, exit" time="0.035017483">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should allow changing multiple settings without losing pending changes" time="0.273317121">
            <system-out>
[DEBUG SettingsDialog] Saving general.vimMode immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Saving general.disableAutoUpdate immediately with value: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [ [32m&apos;general.enablePromptCompletion&apos;[39m ] Needs restart: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should maintain state consistency during complex interactions" time="0.268136493">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; Complex User Interactions &gt; should handle restart workflow correctly" time="0.070931433">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/SettingsDialog.test.tsx" name="SettingsDialog &gt; String Settings Editing &gt; should allow editing and committing a string setting" time="0.593990042">
            <system-out>
[DEBUG SettingsDialog] Modified settings: [ [32m&apos;ui.accessibility.screenReader&apos;[39m ] Needs restart: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [ [32m&apos;ui.accessibility.screenReader&apos;[39m, [32m&apos;ide.enabled&apos;[39m ] Needs restart: [33mtrue[39m

[DEBUG SettingsDialog] Modified settings: [ [32m&apos;ui.accessibility.screenReader&apos;[39m, [32m&apos;ide.enabled&apos;[39m ] Needs restart: [33mtrue[39m

            </system-out>
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SettingsDialog inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ShellConfirmationDialog.test.tsx" timestamp="2025-10-09T09:06:18.970Z" hostname="uby" tests="4" failures="0" errors="0" skipped="0" time="0.045973987">
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; renders correctly" time="0.024037055">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedOnce when &quot;Yes, allow once&quot; is selected" time="0.007250052">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with ProceedAlways when &quot;Yes, allow always for this session&quot; is selected" time="0.006310285">
        </testcase>
        <testcase classname="src/ui/components/ShellConfirmationDialog.test.tsx" name="ShellConfirmationDialog &gt; calls onConfirm with Cancel when &quot;No (esc)&quot; is selected" time="0.007433872">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/StatsDisplay.test.tsx" timestamp="2025-10-09T09:06:18.971Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.198993757">
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders only the Performance section in its zero state" time="0.056554867">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders a table with two models correctly" time="0.026438744">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; renders all sections when all data is present" time="0.016366876">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides User Agreement when no decisions are made" time="0.01188477">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Rendering Tests &gt; hides Efficiency section when cache is not used" time="0.013683906">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in green for high values" time="0.00978046">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in yellow for medium values" time="0.008504331">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Conditional Color Tests &gt; renders success rate in red for low values" time="0.009130348">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; displays Code Changes when line counts are present" time="0.01946325">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Code Changes Display &gt; hides Code Changes when no lines are added or removed" time="0.006698553">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the default title when no title prop is provided" time="0.006715084">
        </testcase>
        <testcase classname="src/ui/components/StatsDisplay.test.tsx" name="&lt;StatsDisplay /&gt; &gt; Title Rendering &gt; renders the custom title when a title prop is provided" time="0.011385948">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/TodoDisplay.test.tsx" timestamp="2025-10-09T09:06:18.971Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.040030119">
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render todo list" time="0.024757977">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should display correct status icons" time="0.006718419">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle empty todo list" time="0.001111264">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should handle undefined todos" time="0.000759895">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with different statuses" time="0.00246668">
        </testcase>
        <testcase classname="src/ui/components/TodoDisplay.test.tsx" name="TodoDisplay &gt; should render tasks with mixed statuses" time="0.00281287">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/ToolStatsDisplay.test.tsx" timestamp="2025-10-09T09:06:18.971Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.086447486">
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should render &quot;no tool calls&quot; message when there are no active tools" time="0.023955314">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for a single tool correctly" time="0.019386699">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should display stats for multiple tools correctly" time="0.015099092">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle large values without wrapping or overlapping" time="0.014796763">
        </testcase>
        <testcase classname="src/ui/components/ToolStatsDisplay.test.tsx" name="&lt;ToolStatsDisplay /&gt; &gt; should handle zero decisions gracefully" time="0.011713283">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/color-utils.test.ts" timestamp="2025-10-09T09:06:18.971Z" hostname="uby" tests="16" failures="0" errors="0" skipped="0" time="0.005977419">
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate hex colors" time="0.001039892">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names" time="0.000669277">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate Ink-supported color names case insensitive" time="0.000160847">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names" time="0.000136462">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should validate CSS color names case insensitive" time="0.000056734">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; isValidColor &gt; should reject invalid color names" time="0.000089215">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve hex colors" time="0.000142123">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve Ink-supported color names" time="0.000115644">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should resolve CSS color names to hex" time="0.000160306">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should handle case insensitive color names" time="0.00006481">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; resolveColor &gt; should return undefined for invalid colors" time="0.000917907">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should contain expected CSS color mappings" time="0.00012443">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; CSS_NAME_TO_HEX_MAP &gt; should not contain Ink-supported color names" time="0.000090457">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should contain all Ink-supported color names" time="0.000214998">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; INK_SUPPORTED_NAMES &gt; should not contain CSS color names" time="0.000073576">
        </testcase>
        <testcase classname="src/ui/themes/color-utils.test.ts" name="Color Utils &gt; Consistency between validation and resolution &gt; should have consistent behavior between isValidColor and resolveColor" time="0.00068723">
            <system-err>
[ColorUtils] Could not resolve color &quot;invalidcolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;notacolor&quot; to an Ink-compatible format.
[ColorUtils] Could not resolve color &quot;&quot; to an Ink-compatible format.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme-manager.test.ts" timestamp="2025-10-09T09:06:18.972Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.033467798">
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should load valid custom themes" time="0.004011425">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get the active theme" time="0.001405639">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should set and get a custom active theme" time="0.00114112">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return false when setting a non-existent theme" time="0.000692881">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should list available themes including custom themes" time="0.012740913">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should get a theme by name" time="0.00100053">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should fall back to default theme if active theme is invalid" time="0.0006551">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; should return NoColorTheme if NO_COLOR is set" time="0.000722225">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should load a theme from a valid file path" time="0.004889249">
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme if the file does not exist" time="0.001984278">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from a file with invalid JSON" time="0.001373048">
            <system-err>
Theme file at &quot;./my-theme.json&quot; is outside your home directory. Only load themes from trusted sources.

            </system-err>
        </testcase>
        <testcase classname="src/ui/themes/theme-manager.test.ts" name="ThemeManager &gt; when loading a theme from a file &gt; should not load a theme from an untrusted file path and log a message" time="0.001147822">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/themes/theme.test.ts" timestamp="2025-10-09T09:06:18.972Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.005522448">
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a valid theme" time="0.001178688">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with an invalid name" time="0.000181766">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: true for a theme missing optional DiffAdded and DiffRemoved colors" time="0.000106627">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="validateCustomTheme &gt; should return isValid: false for a theme with a very long name" time="0.000096448">
        </testcase>
        <testcase classname="src/ui/themes/theme.test.ts" name="themeManager.loadCustomThemes &gt; should use values from DEFAULT_THEME when DiffAdded and DiffRemoved are not provided" time="0.002836554">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/MarkdownDisplay.test.tsx" timestamp="2025-10-09T09:06:18.972Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.212545138">
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders nothing for empty text" time="0.014953884">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a simple paragraph" time="0.011457591">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders headers with correct levels" time="0.006764915">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a fenced code block with a language" time="0.017703657">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders a fenced code block without a language" time="0.09409386">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; handles unclosed (pending) code blocks" time="0.004024479">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders unordered lists with different markers" time="0.003787842">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders nested unordered lists" time="0.003372995">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders ordered lists" time="0.00333764">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders horizontal rules" time="0.002996519">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; renders tables correctly" time="0.011382181">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; handles a table at the end of the input" time="0.00585319">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; inserts a single space between paragraphs" time="0.003258604">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; correctly parses a mix of markdown elements" time="0.017879733">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; hides line numbers in code blocks when showLineNumbers is false" time="0.003666859">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; shows line numbers in code blocks by default" time="0.002735447">
        </testcase>
        <testcase classname="src/ui/utils/MarkdownDisplay.test.tsx" name="&lt;MarkdownDisplay /&gt; &gt; correctly splits lines using \n regardless of platform EOL" time="0.003076277">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/clipboardUtils.test.ts" timestamp="2025-10-09T09:06:18.973Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.006138026">
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return false on non-macOS platforms" time="0.001496867">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; clipboardHasImage &gt; should return boolean on macOS" time="0.000170716">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should return null on non-macOS platforms" time="0.000239272">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; saveClipboardImage &gt; should handle errors gracefully" time="0.000138285">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should not throw errors" time="0.002349493">
        </testcase>
        <testcase classname="src/ui/utils/clipboardUtils.test.ts" name="clipboardUtils &gt; cleanupOldClipboardImages &gt; should complete without errors on valid directory" time="0.000268597">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/commandUtils.test.ts" timestamp="2025-10-09T09:06:18.973Z" hostname="uby" tests="26" failures="0" errors="0" skipped="0" time="0.028831668">
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query starts with @" time="0.001603665">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return true when query contains @ preceded by whitespace" time="0.000426769">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when query does not start with @ and has no spaced @" time="0.000202504">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isAtCommand &gt; should return false when @ is not preceded by whitespace" time="0.000123388">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return true when query starts with /" time="0.000239262">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false when query does not start with /" time="0.000179642">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for line comments starting with //" time="0.000198938">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; isSlashCommand &gt; should return false for block comments starting with /*" time="0.000114903">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should successfully copy text to clipboard using pbcopy" time="0.002729115">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle pbcopy command failure" time="0.00108179">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle spawn error" time="0.000280519">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on macOS (darwin) &gt; should handle stdin write error" time="0.001314129">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Windows (win32) &gt; should successfully copy text to clipboard using clip" time="0.001458075">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should successfully copy text to clipboard using xclip" time="0.001577727">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should fall back to xsel when xclip fails" time="0.002913156">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should throw error when both xclip and xsel are not found" time="0.003079633">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on Linux &gt; should emit error when xclip or xsel fail with stderr output (command installed)" time="0.002999154">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; on unsupported platform &gt; should throw error for unsupported platform" time="0.000308962">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle command exit without stderr" time="0.001396011">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle empty text" time="0.001317916">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle multiline text" time="0.001289343">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; copyToClipboard &gt; error handling &gt; should handle special characters" time="0.001305673">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on macOS (darwin) &gt; should return open" time="0.000174713">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Windows (win32) &gt; should return start" time="0.000100756">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on Linux (linux) &gt; should return xdg-open" time="0.000097791">
        </testcase>
        <testcase classname="src/ui/utils/commandUtils.test.ts" name="commandUtils &gt; getUrlOpenCommand &gt; on unmatched OS &gt; should return xdg-open" time="0.000791172">
            <system-err>
Unknown platform: unmatched. Attempting to open URLs with: xdg-open.

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/computeStats.test.ts" timestamp="2025-10-09T09:06:18.974Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.006058099">
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should return 0 if totalRequests is 0" time="0.002315501">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateErrorRate &gt; should calculate the error rate correctly" time="0.000184692">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should return 0 if totalRequests is 0" time="0.000172169">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateAverageLatency &gt; should calculate the average latency correctly" time="0.000191804">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should return 0 if prompt tokens is 0" time="0.00012446">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="calculateCacheHitRate &gt; should calculate the cache hit rate correctly" time="0.000075229">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should return all zeros for initial empty metrics" time="0.000804728">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate API and tool time percentages" time="0.000246615">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate cache efficiency" time="0.000186925">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly calculate success and agreement rates" time="0.000126403">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should handle division by zero gracefully" time="0.00019492">
        </testcase>
        <testcase classname="src/ui/utils/computeStats.test.ts" name="computeSessionStats &gt; should correctly include line counts" time="0.000107779">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/displayUtils.test.ts" timestamp="2025-10-09T09:06:18.974Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.005121859">
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return green for values &gt;= green threshold" time="0.001813162">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return yellow for values &lt; green and &gt;= yellow threshold" time="0.000246586">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return red for values &lt; yellow threshold" time="0.000158503">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; getStatusColor &gt; should return defaultColor for values &lt; yellow threshold when provided" time="0.000167589">
        </testcase>
        <testcase classname="src/ui/utils/displayUtils.test.ts" name="displayUtils &gt; Threshold Constants &gt; should have the correct values" time="0.000721784">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/formatters.test.ts" timestamp="2025-10-09T09:06:18.975Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.003809792">
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into KB" time="0.001303149">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into MB" time="0.000178039">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatMemoryUsage &gt; should format bytes into GB" time="0.000088523">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format milliseconds less than a second" time="0.00025935">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration of 0" time="0.000095307">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of seconds" time="0.000068667">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in seconds with one decimal place" time="0.000063728">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of minutes" time="0.00006474">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in minutes and seconds" time="0.000086289">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format an exact number of hours" time="0.000056204">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours and seconds" time="0.000051405">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should format a duration in hours, minutes, and seconds" time="0.00005995">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle large durations" time="0.000057005">
        </testcase>
        <testcase classname="src/ui/utils/formatters.test.ts" name="formatters &gt; formatDuration &gt; should handle negative durations" time="0.000053208">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/markdownUtilities.test.ts" timestamp="2025-10-09T09:06:18.975Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.00355955">
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should split at the last double newline if not in a code block" time="0.001689894">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if no safe split point is found" time="0.000159696">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should prioritize splitting at 

 over being at the very end of the string if the end is not in a code block" time="0.00009164">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if the only 

 is inside a code block and the end of content is not" time="0.000084696">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should correctly identify the last 

 even if it is followed by text not in a code block" time="0.000077494">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content is empty" time="0.000062495">
        </testcase>
        <testcase classname="src/ui/utils/markdownUtilities.test.ts" name="markdownUtilities &gt; findLastSafeSplitPoint &gt; should return content.length if content has no newlines and no code blocks" time="0.000061954">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/utils/updateCheck.test.ts" timestamp="2025-10-09T09:06:18.975Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.012062719">
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null when running from source (DEV=true)" time="0.003033929">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if package.json is missing" time="0.000499774">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if there is no update" time="0.000413134">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return a message if a newer version is available" time="0.001483582">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is the same as the current version" time="0.00044398">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if the latest version is older than the current version" time="0.000298592">
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should return null if fetchInfo rejects" time="0.001512967">
            <system-err>
Failed to check for updates: Error: Timeout

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; should handle errors gracefully" time="0.001524889">
            <system-err>
Failed to check for updates: Error: test error

            </system-err>
        </testcase>
        <testcase classname="src/ui/utils/updateCheck.test.ts" name="checkForUpdates &gt; nightly updates &gt; should notify for a newer nightly version when current is nightly" time="0.001437627">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/atCommandProcessor.test.ts" timestamp="2025-10-09T09:06:18.976Z" hostname="uby" tests="39" failures="0" errors="0" skipped="0" time="0.438441467">
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through query if no @ command is present" time="0.003550143">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should pass through original query if only a lone @ symbol is present" time="0.002059768">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid text file path" time="0.054695579">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process a valid directory path and convert to glob" time="0.029145007">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle query with text before and after @command" time="0.021093643">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should correctly unescape paths with escaped spaces" time="0.011780898">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references" time="0.017747708">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle multiple @file references with interleaved text" time="0.01378361">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle a mix of valid, invalid, and lone @ references" time="0.015539116">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should return original query if all @paths are invalid or lone @" time="0.003836603">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should skip git-ignored files in @ commands" time="0.004775117">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-Sozqs4/node_modules/package.json

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should process non-git-ignored files normally" time="0.012483727">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should handle mixed git-ignored and valid files" time="0.013547333">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-qYedM0/.env

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; git-aware filtering &gt; should always ignore .git directory files" time="0.003295191">
            <system-out>
Ignored 1 files:
Git-ignored: /tmp/folder-structure-test-djq6cj/.git/config

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; when recursive file search is disabled &gt; should not use glob search for a nonexistent file" time="0.001940047">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; gemini-ignore filtering &gt; should skip gemini-ignored files in @ commands" time="0.003723413">
            <system-out>
Ignored 1 files:
Gemini-ignored: /tmp/folder-structure-test-9bqYx4/build/output.js

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should process non-ignored files when .qwenignore is present" time="0.009739113">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should handle mixed gemini-ignored and valid files" time="0.009386892">
            <system-out>
Ignored 1 files:
Gemini-ignored: /tmp/folder-structure-test-3hs1FS/dist/bundle.js

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;comma&apos;" time="0.008489864">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;period&apos;" time="0.015024134">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;semicolon&apos;" time="0.008874416">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;exclamation mark&apos;" time="0.008347721">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;question mark&apos;" time="0.007084517">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening parenthesis&apos;" time="0.006506057">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing parenthesis&apos;" time="0.009116333">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening square bracket&apos;" time="0.012375277">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing square bracket&apos;" time="0.008387215">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;opening curly brace&apos;" time="0.009863043">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should terminate @path at &apos;closing curly brace&apos;" time="0.009897918">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle multiple @paths terminated by different punctuation" time="0.008952229">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should still handle escaped spaces in paths before punctuation" time="0.010857662">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not break file paths with periods in extensions" time="0.009099361">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle file paths ending with period followed by space" time="0.008543974">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle comma termination with complex file paths" time="0.008575603">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should not terminate at period within file name" time="0.012806324">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle end of string termination for period and comma" time="0.008678493">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle files with special characters in names" time="0.009740066">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; punctuation termination in @ commands &gt; should handle basic file names without special characters" time="0.010134073">
        </testcase>
        <testcase classname="src/ui/hooks/atCommandProcessor.test.ts" name="handleAtCommand &gt; should not add the user&apos;s turn to history, as that is the caller&apos;s responsibility" time="0.012640807">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/shellCommandProcessor.test.ts" timestamp="2025-10-09T09:06:18.977Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.071926582">
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should initiate command execution and set pending state" time="0.02128108">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle successful execution and update history correctly" time="0.006059171">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command failure and display error status" time="0.004976389">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should throttle pending UI updates for text streams" time="0.006674869">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; UI Streaming and Throttling &gt; should show binary progress messages correctly" time="0.007552672">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should not wrap the command on Windows" time="0.002987723">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle command abort and display cancelled status" time="0.004196327">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle binary output result correctly" time="0.002688971">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle promise rejection and show an error" time="0.005483747">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; should handle synchronous errors during execution and clean up resources" time="0.003262922">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should show a warning if the working directory changes" time="0.002325328">
        </testcase>
        <testcase classname="src/ui/hooks/shellCommandProcessor.test.ts" name="useShellCommandProcessor &gt; Directory Change Warning &gt; should NOT show a warning if the directory does not change" time="0.002611137">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/slashCommandProcessor.test.ts" timestamp="2025-10-09T09:06:18.977Z" hostname="uby" tests="35" failures="0" errors="0" skipped="0" time="2.026252845">
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should initialize CommandService with all required loaders" time="0.020743567">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should call loadCommands and populate state after mounting" time="0.063230657">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should provide an immutable array of commands to consumers" time="0.062741813">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Initialization and Command Loading &gt; should override built-in commands with file-based commands of the same name" time="0.056878635">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display an error for an unknown command" time="0.004296412">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should display help for a parent command invoked without a subcommand" time="0.05627533">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should correctly find and execute a nested subcommand" time="0.056905415">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the the input is not a command" time="0.003625111">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; sets isProcessing to false if the command has an error" time="0.00300223">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Execution Logic &gt; should set isProcessing to true during execution and false afterwards" time="0.105609559">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: theme&quot; action" time="0.055431691">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;dialog: model&quot; action" time="0.055523711">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;load_history&quot; action" time="0.061006395">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should handle a &quot;quit&quot; action" time="0.058300523">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; with fake timers &gt; should call runExitCleanup when handling a &quot;quit&quot; action" time="0.055790163">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a file-based command" time="0.055055415">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Action Result Handling &gt; should handle &quot;submit_prompt&quot; action returned from a mcp-based command" time="0.056812914">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should set confirmation request when action returns confirm_shell_commands" time="0.106534528">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should do nothing if user cancels confirmation" time="0.106763612">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command with one-time allowlist on &quot;Proceed Once&quot;" time="0.111277296">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Shell Command Confirmation Flow &gt; should re-run command and update session allowlist on &quot;Proceed Always&quot;" time="0.115789807">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should be case-sensitive" time="0.056375565">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should correctly match an altName" time="0.056376386">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle extra whitespace around the command" time="0.055718841">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Parsing and Matching &gt; should handle `?` as a command prefix" time="0.055981747">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should override mcp-based commands with file-based commands of the same name" time="0.067405875">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should prioritize a command with a primary name over a command with a matching alias" time="0.055977469">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Command Precedence &gt; should add an overridden command to the history" time="0.057763652">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Lifecycle &gt; should abort command loading when the hook unmounts" time="0.004200525">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a simple slash command" time="0.058047756">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs nothing for a bogus command" time="0.05663234">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; logs a failure event for a failed command" time="0.05583713">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log a slash command with a subcommand" time="0.059433549">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should log the command path when an alias is used" time="0.056352041">
        </testcase>
        <testcase classname="src/ui/hooks/slashCommandProcessor.test.ts" name="useSlashCommandProcessor &gt; Slash Command Logging &gt; should not log for unknown commands" time="0.055874799">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAtCompletion.test.ts" timestamp="2025-10-09T09:06:18.978Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="1.061532274">
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should perform a recursive search for an empty pattern" time="0.081076287">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should correctly filter the recursive list based on a pattern" time="0.057456754">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; File Search Logic &gt; should append a trailing slash to directory paths in suggestions" time="0.060192391">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should be in a loading state during initial file system crawl" time="0.060232304">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should NOT show a loading indicator for subsequent searches that complete under 200ms" time="0.112337996">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should show a loading indicator and clear old suggestions for subsequent searches that take longer than 200ms" time="0.116102576">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; UI State and Loading Behavior &gt; should abort the previous search when a new one starts" time="0.161455584">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in a READY state" time="0.0588506">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; State Management &gt; should reset the state when disabled after being in an ERROR state" time="0.059657322">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should respect .gitignore files" time="0.063016411">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should work correctly when config is undefined" time="0.05675112">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should reset and re-initialize when the cwd changes" time="0.113243019">
        </testcase>
        <testcase classname="src/ui/hooks/useAtCompletion.test.ts" name="useAtCompletion &gt; Filtering and Configuration &gt; should perform a non-recursive search when enableRecursiveFileSearch is false" time="0.058748511">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useAutoAcceptIndicator.test.ts" timestamp="2025-10-09T09:06:18.979Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.031911311">
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.AUTO_EDIT if config.getApprovalMode returns ApprovalMode.AUTO_EDIT" time="0.011572132">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.DEFAULT if config.getApprovalMode returns ApprovalMode.DEFAULT" time="0.002177336">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.YOLO if config.getApprovalMode returns ApprovalMode.YOLO" time="0.001563069">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should initialize with ApprovalMode.PLAN if config.getApprovalMode returns ApprovalMode.PLAN" time="0.001549775">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should cycle approval modes when Shift+Tab is pressed" time="0.003815544">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should not toggle if only one key or other keys combinations are pressed" time="0.001561807">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; should update indicator when config value changes externally (useEffect dependency)" time="0.001593826">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from DEFAULT to AUTO_EDIT" time="0.002599015">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should show a warning when cycling from AUTO_EDIT to YOLO" time="0.002225544">
        </testcase>
        <testcase classname="src/ui/hooks/useAutoAcceptIndicator.test.ts" name="useAutoAcceptIndicator &gt; in untrusted folders &gt; should cycle from YOLO to PLAN when Shift+Tab is pressed" time="0.001800819">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useCommandCompletion.test.ts" timestamp="2025-10-09T09:06:18.979Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.095292166">
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.023399055">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when completion mode becomes IDLE" time="0.012057159">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset all state to default values" time="0.003400035">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should call useAtCompletion with the correct query for an escaped space" time="0.003953007">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; State Management &gt; should correctly identify the completion context with multiple @ symbols" time="0.003650037">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.002171645">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.002325789">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.002833017">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.004141717">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.006930691">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; Core Hook Behavior &gt; Navigation &gt; should automatically select the first item when suggestions are available" time="0.004704507">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a partial command" time="0.00511755">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path" time="0.007680478">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; handleAutocomplete &gt; should complete a file path when cursor is not at the end of the line" time="0.004729432">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for line comments" time="0.002247896">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should not trigger prompt completion for block comments" time="0.001873934">
        </testcase>
        <testcase classname="src/ui/hooks/useCommandCompletion.test.ts" name="useCommandCompletion &gt; prompt completion filtering &gt; should trigger prompt completion for regular text when enabled" time="0.00169325">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useConsoleMessages.test.ts" timestamp="2025-10-09T09:06:18.980Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.043343615">
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should initialize with an empty array of console messages" time="0.018059044">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should add a new message when log is called" time="0.00613464">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should batch and count identical consecutive messages" time="0.003880153">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should not batch different messages" time="0.004064774">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear all messages when clearConsoleMessages is called" time="0.005677606">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clear the pending timeout when clearConsoleMessages is called" time="0.002601318">
        </testcase>
        <testcase classname="src/ui/hooks/useConsoleMessages.test.ts" name="useConsoleMessages &gt; should clean up the timeout on unmount" time="0.001275327">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useEditorSettings.test.ts" timestamp="2025-10-09T09:06:18.980Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.043928496">
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should initialize with dialog closed" time="0.013415399">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should open editor dialog when openEditorDialog is called" time="0.003158649">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should close editor dialog when exitEditorDialog is called" time="0.003070847">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle editor selection successfully" time="0.006456996">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle clearing editor preference (undefined editor)" time="0.003816185">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different editor types" time="0.002536039">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle different setting scopes" time="0.002476307">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for unavailable editors" time="0.002097257">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should not set preference for editors not allowed in sandbox" time="0.002566414">
        </testcase>
        <testcase classname="src/ui/hooks/useEditorSettings.test.ts" name="useEditorSettings &gt; should handle errors during editor selection" time="0.002377414">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFocus.test.ts" timestamp="2025-10-09T09:06:18.980Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.035029655">
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should initialize with focus and enable focus reporting" time="0.020092963">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to false when a focus-out event is received" time="0.003074764">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should set isFocused to true when a focus-in event is received" time="0.003011226">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should clean up and disable focus reporting on unmount" time="0.002571193">
        </testcase>
        <testcase classname="src/ui/hooks/useFocus.test.ts" name="useFocus &gt; should handle multiple focus events correctly" time="0.004350251">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useFolderTrust.test.ts" timestamp="2025-10-09T09:06:18.980Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.040874911">
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already trusted" time="0.019035309">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not open dialog when folder is already untrusted" time="0.002703178">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should open dialog when folder trust is undefined" time="0.002325249">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_FOLDER choice" time="0.002869294">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle TRUST_PARENT choice" time="0.00263466">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should handle DO_NOT_TRUST choice and trigger restart" time="0.002742199">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should do nothing for default choice" time="0.001888191">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should set isRestarting to true when trust status changes from false to true" time="0.001780852">
        </testcase>
        <testcase classname="src/ui/hooks/useFolderTrust.test.ts" name="useFolderTrust &gt; should not set isRestarting to true when trust status does not change" time="0.003006668">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGeminiStream.test.tsx" timestamp="2025-10-09T09:06:18.981Z" hostname="uby" tests="33" failures="0" errors="0" skipped="0" time="0.515869019">
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not submit tool responses if not all tool calls are completed" time="0.014771676">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should submit tool responses when all tool calls are completed and ready" time="0.011813428">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should handle all tool calls being cancelled" time="0.005137296">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should group multiple cancelled tool call responses into a single history entry" time="0.007386634">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should not flicker streaming state to Idle between tool completion and submission" time="0.007757771">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should cancel an in-progress stream when escape is pressed" time="0.013444193">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should call onCancelSubmit handler when escape is pressed" time="0.010151416">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not do anything if escape is pressed when not responding" time="0.010523594">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should prevent further processing after cancellation" time="0.058964911">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; User Cancellation &gt; should not cancel if a tool call is in progress (not just responding)" time="0.003830661">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should schedule a tool call when the command processor returns a schedule_tool action" time="0.004746284">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should stop processing and not call Gemini when a command is handled without a tool call" time="0.004997388">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should call Gemini with prompt content when slash command returns a `submit_prompt` action" time="0.005454633">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should correctly handle a submit_prompt action with empty content" time="0.005218286">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for line comments" time="0.003932099">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Slash Command Handling &gt; should not call handleSlashCommand for block comments" time="0.003509197">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Memory Refresh on save_memory &gt; should call performMemoryRefresh when a save_memory tool call completes successfully" time="0.004381529">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Error Handling &gt; should call parseAndFormatApiError with the correct authType on stream initialization failure" time="0.007868195">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add info message for MAX_TOKENS finish reason" time="0.004946273">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for STOP finish reason" time="0.103658632">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should not add message for FINISH_REASON_UNSPECIFIED" time="0.103708284">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; handleFinishedEvent &gt; should add appropriate messages for other finish reasons" time="0.03944645">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; should process @include commands, adding user turn after processing to prevent race conditions" time="0.007341341">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when starting a new prompt" time="0.007959754">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when user cancels" time="0.006072746">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Thought Reset &gt; should reset thought to null when there is an error" time="0.005433675">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should prevent concurrent submitQuery calls" time="0.014703009">
            <system-err>
You called act(async () =&gt; ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () =&gt; ...);

            </system-err>
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should allow subsequent calls after first call completes" time="0.01201423">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Concurrent Execution Prevention &gt; should reset execution flag even when query preparation fails" time="0.004028237">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should call handleVisionSwitch and proceed to send when allowed" time="0.004347216">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Vision Auto Switch Integration &gt; should gate submission when handleVisionSwitch returns shouldProceed=false" time="0.005643352">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model after successful stream completion" time="0.004929683">
        </testcase>
        <testcase classname="src/ui/hooks/useGeminiStream.test.tsx" name="useGeminiStream &gt; Model restore on completion and errors &gt; should restore model when an error occurs during streaming" time="0.004999843">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useGitBranchName.test.ts" timestamp="2025-10-09T09:06:18.982Z" hostname="uby" tests="7" failures="0" errors="0" skipped="2" time="0.044010958">
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return branch name" time="0.022667763">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if git command fails" time="0.004219711">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return short commit hash if branch is HEAD (detached state)" time="0.004247572">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should return undefined if branch is HEAD and getting commit hash fails" time="0.003185128">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should update branch name when .git/HEAD changes" time="0.000954735">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should handle watcher setup error silently" time="0.00631307">
        </testcase>
        <testcase classname="src/ui/hooks/useGitBranchName.test.ts" name="useGitBranchName &gt; should cleanup watcher on unmount" time="0.000875599">
            <skipped/>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useHistoryManager.test.ts" timestamp="2025-10-09T09:06:18.982Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.033867507">
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should initialize with an empty history" time="0.014051595">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add an item to history with a unique ID" time="0.004367022">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should generate unique IDs for items added with the same base timestamp" time="0.003355342">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should update an existing history item" time="0.002649878">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not change history if updateHistoryItem is called with a nonexistent ID" time="0.002086707">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should clear the history" time="0.001697318">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should not add consecutive duplicate user messages" time="0.002185931">
        </testcase>
        <testcase classname="src/ui/hooks/useHistoryManager.test.ts" name="useHistoryManager &gt; should add duplicate user messages if they are not consecutive" time="0.001740868">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useInputHistory.test.ts" timestamp="2025-10-09T09:06:18.982Z" hostname="uby" tests="11" failures="0" errors="0" skipped="0" time="0.034340973">
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; should initialize with historyIndex -1 and empty originalQueryBeforeNav" time="0.01348074">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should call onSubmit with trimmed value and reset history" time="0.002906493">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; handleSubmit &gt; should not call onSubmit if value is empty after trimming" time="0.001883932">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if isActive is false" time="0.001954844">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should not navigate if userMessages is empty" time="0.002525499">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should call onChange with the last message when navigating up from initial state" time="0.002356767">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should store currentQuery as originalQueryBeforeNav on first navigateUp" time="0.001513769">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateUp &gt; should navigate through history messages on subsequent navigateUp calls" time="0.001537422">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if isActive is false" time="0.00148752">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should not navigate if historyIndex is -1 (not in history navigation)" time="0.001167689">
        </testcase>
        <testcase classname="src/ui/hooks/useInputHistory.test.ts" name="useInputHistory &gt; navigateDown &gt; should restore originalQueryBeforeNav when navigating down to initial state" time="0.001546198">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useKeypress.test.ts" timestamp="2025-10-09T09:06:18.983Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.065588727">
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should not listen if isActive is false" time="0.015357159">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;a&apos;" time="0.003255768">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;left&apos;" time="0.001456061">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;right&apos;" time="0.001169101">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;up&apos;" time="0.00131441">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should listen for keypress when active for key &apos;down&apos;" time="0.000965645">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should set and release raw mode" time="0.001217812">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should stop listening after being unmounted" time="0.001020085">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; should correctly identify alt+enter (meta key)" time="0.002024082">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should process a paste as a single event" time="0.005537928">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should handle keypress interspersed with pastes" time="0.009153451">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;Modern Node (&gt;= v20)&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.002792792">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should process a paste as a single event" time="0.004463191">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should handle keypress interspersed with pastes" time="0.010925146">
        </testcase>
        <testcase classname="src/ui/hooks/useKeypress.test.ts" name="useKeypress &gt; in &apos;PasteWorkaround Environment Variable&apos; &gt; should emit partial paste content if unmounted mid-paste" time="0.003052783">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useLoadingIndicator.test.ts" timestamp="2025-10-09T09:06:18.983Z" hostname="uby" tests="5" failures="0" errors="0" skipped="0" time="0.046029529">
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should initialize with default values when Idle" time="0.013681652">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reflect values when Responding" time="0.006008497">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should show waiting phrase and retain elapsedTime when WaitingForConfirmation" time="0.012378533">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset elapsedTime and use a witty phrase when transitioning from WaitingForConfirmation to Responding" time="0.007798406">
        </testcase>
        <testcase classname="src/ui/hooks/useLoadingIndicator.test.ts" name="useLoadingIndicator &gt; should reset timer and phrase when streamingState changes from Responding to Idle" time="0.004595285">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useMessageQueue.test.ts" timestamp="2025-10-09T09:06:18.983Z" hostname="uby" tests="9" failures="0" errors="0" skipped="0" time="0.049219045">
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should initialize with empty queue" time="0.019497653">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should add messages to queue" time="0.003891053">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should filter out empty messages" time="0.003102706">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should clear queue" time="0.004562995">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should return queued messages as text with double newlines" time="0.002545425">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should auto-submit queued messages when transitioning to Idle" time="0.003200025">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when queue is empty" time="0.00505771">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should not auto-submit when not transitioning to Idle" time="0.00220695">
        </testcase>
        <testcase classname="src/ui/hooks/useMessageQueue.test.ts" name="useMessageQueue &gt; should handle multiple state transitions correctly" time="0.003081195">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePhraseCycler.test.ts" timestamp="2025-10-09T09:06:18.984Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.043944886">
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should initialize with the first witty phrase when not active and not waiting" time="0.019648822">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should show &quot;Waiting for user confirmation...&quot; when isWaiting is true" time="0.005558896">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should not cycle phrases if isActive is false and not waiting" time="0.003311772">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should cycle through witty phrases when isActive is true and not waiting" time="0.002352489">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when isActive becomes true after being false (and not waiting)" time="0.007102279">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should clear phrase interval on unmount when active" time="0.00156369">
        </testcase>
        <testcase classname="src/ui/hooks/usePhraseCycler.test.ts" name="usePhraseCycler &gt; should reset to a witty phrase when transitioning from waiting to active" time="0.002631064">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/usePrivacySettings.test.ts" timestamp="2025-10-09T09:06:18.984Z" hostname="uby" tests="6" failures="0" errors="0" skipped="0" time="0.299394177">
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle LoggingContentGenerator wrapper correctly and not throw &quot;Oauth not being used&quot; error" time="0.065112576">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should work with direct CodeAssistServer (no wrapper)" time="0.054476044">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should handle paid tier users correctly" time="0.054778904">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when content generator is not a CodeAssistServer" time="0.00754659">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should throw error when CodeAssistServer has no projectId" time="0.004561101">
        </testcase>
        <testcase classname="src/ui/hooks/usePrivacySettings.test.ts" name="usePrivacySettings &gt; should update data collection opt-in setting" time="0.111424859">
            <system-err>
An update to TestComponent inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useQwenAuth.test.ts" timestamp="2025-10-09T09:06:18.984Z" hostname="uby" tests="17" failures="0" errors="0" skipped="0" time="0.036098772">
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when not Qwen auth" time="0.012745411">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should initialize with default state when Qwen auth but not authenticating" time="0.002047134">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set up event listeners when Qwen auth and authenticating" time="0.003205606">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle device auth event" time="0.001745186">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - success" time="0.001564573">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - error" time="0.000942522">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - polling" time="0.000975974">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event - rate_limit" time="0.000825947">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle auth progress event without message" time="0.000890857">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when auth type changes" time="0.001138174">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners when authentication stops" time="0.000988127">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should clean up event listeners on unmount" time="0.000937333">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when switching from Qwen auth to another auth type" time="0.001077732">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should reset state when authentication stops" time="0.001669867">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should handle cancelQwenAuth function" time="0.001136732">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should maintain isQwenAuth flag correctly" time="0.00204486">
        </testcase>
        <testcase classname="src/ui/hooks/useQwenAuth.test.ts" name="useQwenAuth &gt; should set isQwenAuthenticating to true when starting authentication with Qwen auth" time="0.000752451">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useReverseSearchCompletion.test.tsx" timestamp="2025-10-09T09:06:18.985Z" hostname="uby" tests="10" failures="0" errors="0" skipped="0" time="0.045265918">
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should initialize with default state" time="0.015813703">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; should reset state when reverseSearchActive becomes false" time="0.0038737">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateUp with no suggestions" time="0.002967276">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigateDown with no suggestions" time="0.002553179">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate up through suggestions with wrap-around" time="0.005209841">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should navigate down through suggestions with wrap-around" time="0.003908095">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with multiple suggestions" time="0.00345131">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Core Hook Behavior &gt; State Management &gt; Navigation &gt; should handle navigation with large suggestion lists and scrolling" time="0.001923997">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; filters history by buffer.text and sets showSuggestions" time="0.001736079">
        </testcase>
        <testcase classname="src/ui/hooks/useReverseSearchCompletion.test.tsx" name="useReverseSearchCompletion &gt; Filtering &gt; hides suggestions when there are no matches" time="0.001994177">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useShellHistory.test.ts" timestamp="2025-10-09T09:06:18.985Z" hostname="uby" tests="7" failures="0" errors="0" skipped="0" time="0.575956236">
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should initialize and read the history file from the correct path" time="0.071822099">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should handle a nonexistent history file gracefully" time="0.060294931">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should add a command and write to the history file" time="0.107988276">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should navigate history correctly with previous/next commands" time="0.060755893">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should not add empty or whitespace-only commands to history" time="0.056833982">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should truncate history to MAX_HISTORY_LENGTH (100)" time="0.106258558">
        </testcase>
        <testcase classname="src/ui/hooks/useShellHistory.test.ts" name="useShellHistory &gt; should move an existing command to the top when re-added" time="0.109470986">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useSlashCompletion.test.ts" timestamp="2025-10-09T09:06:18.985Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.096817205">
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest all top-level commands for the root slash" time="0.01218215">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should filter commands based on partial input" time="0.001528175">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should suggest commands based on partial altNames" time="0.001247246">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should NOT provide suggestions for a perfectly typed command that is a leaf node" time="0.003002531">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.001967237">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not suggest commands when altNames is fully typed" time="0.001055892">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for a fully typed command that has no sub-commands or argument completion" time="0.000796382">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Top-Level Commands &gt; should not provide suggestions for an unknown command" time="0.000730009">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest sub-commands for a parent command" time="0.00097878">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should suggest all sub-commands when the query ends with the parent command and a space" time="0.001005399">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should filter sub-commands by prefix" time="0.000980022">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Sub-Commands &gt; should provide no suggestions for an invalid sub-command" time="0.001009026">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call the command.completion function for argument suggestions" time="0.060696032">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should call command.completion with an empty string when args start with a space" time="0.005456597">
        </testcase>
        <testcase classname="src/ui/hooks/useSlashCompletion.test.ts" name="useSlashCompletion &gt; Argument Completion &gt; should handle completion function that returns null" time="0.002070958">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useTimer.test.ts" timestamp="2025-10-09T09:06:18.986Z" hostname="uby" tests="8" failures="0" errors="0" skipped="0" time="0.040700458">
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should initialize with 0" time="0.016642976">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should not increment time if isActive is false" time="0.002660808">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should increment time every second if isActive is true" time="0.005798439">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 and start incrementing when isActive becomes true from false" time="0.002598524">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should reset to 0 when resetKey changes while active" time="0.00321876">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should be 0 if isActive is false, regardless of resetKey changes" time="0.002014253">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should clear timer on unmount" time="0.002611157">
        </testcase>
        <testcase classname="src/ui/hooks/useTimer.test.ts" name="useTimer &gt; should preserve elapsedTime when isActive becomes false, and reset to 0 when it becomes active again" time="0.003135806">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useToolScheduler.test.ts" timestamp="2025-10-09T09:06:18.986Z" hostname="uby" tests="21" failures="0" errors="0" skipped="4" time="0.065618501">
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler in YOLO Mode &gt; should skip confirmation and execute tool directly when yoloMode is true" time="0.027660212">
            <system-out>
[Tool] Starting: mockToolRequiresConfirmation (yoloCall...)
[Tool] Args: {
  &quot;data&quot;: &quot;any data&quot;
}

[Tool] Completed: mockToolRequiresConfirmation in 0ms
[Tool] Success: mockToolRequiresConfirmation

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; initial state should be empty" time="0.002377315">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute a tool call successfully" time="0.006390193">
            <system-out>
[Tool] Starting: mockTool (call1...)
[Tool] Args: {
  &quot;param&quot;: &quot;value&quot;
}

[Tool] Completed: mockTool in 0ms
[Tool] Success: mockTool

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool not found" time="0.004588281">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during shouldConfirmExecute" time="0.004481194">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle error during execute" time="0.003399685">
            <system-out>
[Tool] Starting: mockTool (call1...)

[Tool] Exception: mockTool after 0ms - Execution failed

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - approved" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle tool requiring confirmation - cancelled by user" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should handle live output updates" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should schedule and execute multiple tool calls" time="0.008865589">
            <system-out>
[Tool] Starting: tool1 (multi1...)
[Tool] Args: {
  &quot;p&quot;: 1
}
[Tool] Starting: tool2 (multi2...)
[Tool] Args: {
  &quot;p&quot;: 2
}
[Tool] Completed: tool1 in 0ms
[Tool] Success: tool1
[Tool] Completed: tool2 in 0ms
[Tool] Success: tool2

            </system-out>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="useReactToolScheduler &gt; should throw error if scheduling while already running" time="0">
            <skipped/>
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;validating&apos; (validating) correctly" time="0.000596172">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;awaiting_approval&apos; (awaiting_approval) correctly" time="0.000201693">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;scheduled&apos; (scheduled) correctly" time="0.000152342">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing no live output) correctly" time="0.000139859">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;executing&apos; (executing with live output) correctly" time="0.00014564">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;success&apos; (success) correctly" time="0.000147854">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool not found) correctly" time="0.000146601">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;error&apos; (error tool execution failed) correctly" time="0.000142043">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map ToolCall with status &apos;cancelled&apos; (cancelled) correctly" time="0.000170696">
        </testcase>
        <testcase classname="src/ui/hooks/useToolScheduler.test.ts" name="mapToDisplay &gt; should map an array of ToolCalls correctly" time="0.004056008">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/useVisionAutoSwitch.test.ts" timestamp="2025-10-09T09:06:18.987Z" hostname="uby" tests="36" failures="8" errors="0" skipped="0" time="0.07335892">
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH" time="0.001266401">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when current model is already a vision model" time="0.000229213">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist, QWEN_OAUTH, and model is not vision" time="0.000166488">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; detects image when provided as a single Part object (non-array)" time="0.000207894">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts contain no images" time="0.000104954">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when parts is a plain string" time="0.000066523">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when visionModelPreviewEnabled is false" time="0.000060993">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns true when image parts exist in YOLO mode context" time="0.000076732">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when no image parts exist in YOLO mode context" time="0.000363392">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when already using vision model in YOLO mode context" time="0.000103532">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; shouldOfferVisionSwitch &gt; returns false when authType is not QWEN_OAUTH in YOLO mode context" time="0.000128909">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchOnce to a one-time model override" time="0.000721825">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps SwitchSessionToVL to a persistent session model" time="0.000121043">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; processVisionSwitchOutcome &gt; maps ContinueWithCurrentModel to empty result" time="0.000076752">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch helpers &gt; getVisionSwitchGuidanceMessage &gt; returns the expected guidance message" time="0.000168011">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true immediately for continuations" time="0.015445893">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when authType is not QWEN_OAUTH" time="0.003912422">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when there are no image parts" time="0.003308887">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; continues with current model when dialog returns empty result" time="0.003351396">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; applies a one-time override and returns originalModel, then restores" time="0.009586662">
            <failure message="expected { shouldProceed: false } to deeply equal { shouldProceed: true, …(1) }" type="AssertionError">
AssertionError: expected { shouldProceed: false } to deeply equal { shouldProceed: true, …(1) }

- Expected
+ Received

  {
-   &quot;originalModel&quot;: &quot;qwen3-coder-plus&quot;,
-   &quot;shouldProceed&quot;: true,
+   &quot;shouldProceed&quot;: false,
  }

 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:352:17
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; persists session model when dialog requests persistence" time="0.002464376">
            <failure message="expected { shouldProceed: false } to deeply equal { shouldProceed: true }" type="AssertionError">
AssertionError: expected { shouldProceed: false } to deeply equal { shouldProceed: true }

- Expected
+ Received

  {
-   &quot;shouldProceed&quot;: true,
+   &quot;shouldProceed&quot;: false,
  }

 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:386:17
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; returns shouldProceed=true when dialog returns no special flags" time="0.001409015">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; blocks when dialog throws or is cancelled" time="0.001769781">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; does nothing when visionModelPreviewEnabled is false" time="0.002087629">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; automatically switches to vision model in YOLO mode without showing dialog" time="0.00313218">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:259:16
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:483:36
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ Proxy.&lt;anonymous&gt; node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:482:13
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when no images are present" time="0.001917614">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when already using vision model" time="0.001830163">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; restores original model after YOLO mode auto-switch" time="0.002197101">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:259:16
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:579:30
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ Proxy.&lt;anonymous&gt; node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:578:13
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when authType is not QWEN_OAUTH" time="0.002171504">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; does not switch in YOLO mode when visionModelPreviewEnabled is false" time="0.001932222">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; YOLO mode behavior &gt; handles multiple image formats in YOLO mode" time="0.002160123">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:259:16
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:686:36
 ❯ node_modules/@testing-library/react/dist/act-compat.js:48:24
 ❯ process.env.NODE_ENV.exports.act ../../node_modules/react/cjs/react.development.js:789:22
 ❯ Proxy.&lt;anonymous&gt; node_modules/@testing-library/react/dist/act-compat.js:47:25
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:685:13
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should automatically switch once when vlmSwitchMode is &quot;once&quot;" time="0.001673975">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:296:18
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:723:49
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should switch session when vlmSwitchMode is &quot;session&quot;" time="0.001616038">
            <failure message="config.setModelContextLimit is not a function" type="TypeError">
TypeError: config.setModelContextLimit is not a function
 ❯ Object.handleVisionSwitch src/ui/hooks/useVisionAutoSwitch.ts:310:18
 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:759:49
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should continue with current model when vlmSwitchMode is &quot;persist&quot;" time="0.001692569">
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to user prompt when vlmSwitchMode is not set" time="0.002100784">
            <failure message="expected false to be true // Object.is equality" type="AssertionError">
AssertionError: expected false to be true // Object.is equality

- Expected
+ Received

- true
+ false

 ❯ src/ui/hooks/useVisionAutoSwitch.test.ts:836:42
            </failure>
        </testcase>
        <testcase classname="src/ui/hooks/useVisionAutoSwitch.test.ts" name="useVisionAutoSwitch hook &gt; VLM switch mode default behavior &gt; should fall back to persist behavior when vlmSwitchMode has invalid value" time="0.001275488">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/hooks/vim.test.ts" timestamp="2025-10-09T09:06:18.988Z" hostname="uby" tests="87" failures="0" errors="0" skipped="0" time="0.453669879">
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should start in NORMAL mode" time="0.014748474">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch to INSERT mode with i command" time="0.005088667">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should switch back to NORMAL mode with Escape" time="0.004887525">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching &gt; should properly handle escape followed immediately by a command" time="0.005422855">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle h (left movement)" time="0.004090241">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle l (right movement)" time="0.002006088">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle j (down movement)" time="0.00251032">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle k (up movement)" time="0.00543631">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle 0 (move to start of line)" time="0.00759488">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Navigation commands &gt; should handle $ (move to end of line)" time="0.003196438">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle a (append after cursor)" time="0.003062682">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle A (append at end of line)" time="0.003766563">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle o (open line below)" time="0.004177733">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Mode switching commands &gt; should handle O (open line above)" time="0.005521356">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle x (delete character)" time="0.004926257">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should move cursor left when deleting last character on line (vim behavior)" time="0.003650579">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Edit commands &gt; should handle first d key (sets pending state)" time="0.007368331">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should handle count input and return to count 0 after command" time="0.004351684">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Count handling &gt; should only delete 1 character with x command when no count is specified" time="0.004097966">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should properly initialize vim hook with word movement support" time="0.007472504">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should support vim mode and basic operations across multiple lines" time="0.005953486">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w (next word)" time="0.003871577">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle b (previous word)" time="0.003836442">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle e (end of word)" time="0.004309116">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle w when cursor is on the last word" time="0.004540573">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should handle first c key (sets pending change state)" time="0.004764167">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state on invalid command sequence (df)" time="0.003905239">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Word movement &gt; should clear pending state with Escape in NORMAL mode" time="0.003650308">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Disabled vim mode &gt; should not respond to vim commands when disabled" time="0.002103308">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat x command from current cursor position" time="0.002815655">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat dd command from current position" time="0.007360065">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat ce command from current position" time="0.01496814">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cc command from current position" time="0.004325206">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat cw command from current position" time="0.004244215">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat D command from current position" time="0.006056506">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat C command from current position" time="0.005070133">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should repeat command after cursor movement" time="0.005252319">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Command repeat system &gt; should move cursor to the correct position after exiting INSERT mode with &quot;a&quot;" time="0.003771602">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle ^ (move to first non-whitespace character)" time="0.003958537">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle G without count (go to last line)" time="0.002958489">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle gg (go to first line)" time="0.003034059">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Special characters and edge cases &gt; should handle count with movement commands" time="0.003281606">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete from cursor to start of next word" time="0.002793083">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should actually delete the complete word including trailing space" time="0.004537458">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete word from middle of word correctly" time="0.002589256">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should handle dw at end of line" time="0.001887179">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should delete multiple words with count" time="0.00450098">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; dw (delete word forward) &gt; should record command for repeat with dot" time="0.007496148">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.00489596">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; de (delete word end) &gt; should handle count with de" time="0.005358635">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should change from cursor to start of next word and enter INSERT mode" time="0.004786508">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should handle count with cw" time="0.003434488">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cw (change word forward) &gt; should be repeatable with dot" time="0.005489167">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should change from cursor to end of word and enter INSERT mode" time="0.00410034">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; ce (change word end) &gt; should handle count with ce" time="0.003641572">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change entire line and enter INSERT mode" time="0.004632744">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should change multiple lines with count" time="0.004754579">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cc (change line) &gt; should be repeatable with dot" time="0.019372232">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.004625942">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; db (delete word backward) &gt; should handle count with db" time="0.005325395">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should change from cursor to start of previous word and enter INSERT mode" time="0.008755565">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; cb (change word backward) &gt; should handle count with cb" time="0.00563707">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending delete state after dw" time="0.005732026">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending change state after cw" time="0.006289026">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; Pending state handling &gt; should clear pending state with escape" time="0.004939651">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should pass escape through when no pending operator is active" time="0.005427023">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Vim word operations &gt; NORMAL mode escape behavior &gt; should handle escape and clear pending operator" time="0.005248182">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ctrl+r in INSERT mode" time="0.004633055">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should pass through ! in INSERT mode when buffer is empty" time="0.005397898">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Shell command pass-through &gt; should handle ! as input in INSERT mode when buffer is not empty" time="0.006836599">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete from cursor to end of current word" time="0.004199794">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; de (delete word end) &gt; should delete multiple word ends with count" time="0.00414892">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete from cursor to start of previous word" time="0.004906059">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; db (delete word backward) &gt; should delete multiple words backward with count" time="0.003814261">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should delete from cursor to start of next word" time="0.003922271">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cw (change word forward) &gt; should change multiple words with count" time="0.004063071">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change from cursor to end of current word" time="0.004665665">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; ce (change word end) &gt; should change multiple word ends with count" time="0.006073617">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cb (change word backward) &gt; should change from cursor to start of previous word" time="0.004977371">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; cc (change line) &gt; should clear the line and place cursor at the start" time="0.006643521">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete the current line" time="0.005407416">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should delete multiple lines with count" time="0.005120175">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; dd (delete line) &gt; should handle deleting last line" time="0.006315776">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should delete from cursor to end of line" time="0.005004781">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; D (delete to end of line) &gt; should handle D at end of line" time="0.006216061">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should change from cursor to end of line" time="0.006427442">
        </testcase>
        <testcase classname="src/ui/hooks/vim.test.ts" name="useVim hook &gt; Reducer-based integration tests &gt; C (change to end of line) &gt; should handle C at beginning of line" time="0.006322919">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/KeypressContext.test.tsx" timestamp="2025-10-09T09:06:18.991Z" hostname="uby" tests="32" failures="0" errors="0" skipped="0" time="0.096804161">
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize regular enter key (keycode 13) in kitty protocol" time="0.01730512">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should recognize numpad enter key (keycode 57414) in kitty protocol" time="0.002939694">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with modifiers" time="0.002720599">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Ctrl modifier" time="0.001680507">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should handle numpad enter with Alt modifier" time="0.001667092">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Enter key handling &gt; should not process kitty sequences when kitty protocol is disabled" time="0.001188557">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Escape key handling &gt; should recognize escape key (keycode 27) in kitty protocol" time="0.001030495">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Tab key in kitty protocol" time="0.001326453">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Shift+Tab in kitty protocol" time="0.001706585">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Backspace key in kitty protocol" time="0.001899702">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Tab and Backspace handling &gt; should recognize Option+Backspace in kitty protocol" time="0.001495415">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; should handle multiline paste as a single event" time="0.003698968">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complete paste sequence with markers" time="0.004302474">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle empty paste sequence" time="0.003617347">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data before paste markers" time="0.004529353">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle data after paste markers" time="0.002207461">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle complex sequence with multiple paste blocks" time="0.003264806">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle fragmented paste markers across multiple data events" time="0.004053503">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle multiline content within paste markers" time="0.004313143">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; paste mode markers &gt; should handle paste markers split across buffer boundaries" time="0.004056669">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; paste mode &gt; buffers fragmented paste chunks before emitting newlines" time="0.003654796">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should buffer input data and wait for timeout" time="0.002361014">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should concatenate new data and reset timeout" time="0.001766476">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should flush immediately when buffer exceeds limit" time="0.002725138">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should clear timeout when new data arrives" time="0.001870418">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle multiple separate keypress events" time="0.001792684">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; Raw keypress pipeline &gt; should handle rapid sequential data within buffer limit" time="0.001493981">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should not log keystrokes when debugKeystrokeLogging is false" time="0.001954874">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer accumulation when debugKeystrokeLogging is true" time="0.00211515">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer overflow when debugKeystrokeLogging is true" time="0.002346798">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should log kitty buffer clear on Ctrl+C when debugKeystrokeLogging is true" time="0.001786463">
        </testcase>
        <testcase classname="src/ui/contexts/KeypressContext.test.tsx" name="KeypressContext - Kitty Protocol &gt; debug keystroke logging &gt; should show char codes when debugKeystrokeLogging is true even without debug mode" time="0.001742281">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/contexts/SessionContext.test.tsx" timestamp="2025-10-09T09:06:18.992Z" hostname="uby" tests="3" failures="0" errors="0" skipped="0" time="0.06001355">
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should provide the correct initial state" time="0.02857304">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SessionStatsProvider inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should update metrics when the uiTelemetryService emits an update" time="0.007917656">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to SessionStatsProvider inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. Import `act` from `react` instead of `react-dom/test-utils`. See https://react.dev/warnings/react-dom-test-utils for more info.

            </system-err>
        </testcase>
        <testcase classname="src/ui/contexts/SessionContext.test.tsx" name="SessionStatsContext &gt; should throw an error when useSessionStats is used outside of a provider" time="0.021740769">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/MaxSizedBox.test.tsx" timestamp="2025-10-09T09:06:18.992Z" hostname="uby" tests="21" failures="0" errors="0" skipped="0" time="0.067626925">
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders children without truncation when they fit" time="0.020227312">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines when content exceeds maxHeight" time="0.004793111">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; hides lines at the end when content exceeds maxHeight and overflowDirection is bottom" time="0.002529626">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text that exceeds maxWidth" time="0.003402941">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles mixed wrapping and non-wrapping segments" time="0.007704783">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles words longer than maxWidth by splitting them" time="0.00423021">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; does not truncate when maxHeight is undefined" time="0.00187196">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden" time="0.001358431">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows plural &quot;lines&quot; when more than one line is hidden and overflowDirection is bottom" time="0.001741108">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; renders an empty box for empty children" time="0.000634553">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte unicode characters correctly" time="0.001067914">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; wraps text with multi-byte emoji characters correctly" time="0.000977728">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; falls back to an ellipsis when width is extremely small" time="0.000855722">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates long non-wrapping text with ellipsis" time="0.000772958">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates non-wrapping text containing line breaks" time="0.00082196">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; truncates emoji characters correctly with ellipsis" time="0.000742893">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; shows ellipsis for multiple rows with long non-wrapping text" time="0.001425475">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; accounts for additionalHiddenLinesCount" time="0.001642306">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; handles React.Fragment as a child" time="0.001465699">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the top" time="0.003052904">
        </testcase>
        <testcase classname="src/ui/components/shared/MaxSizedBox.test.tsx" name="&lt;MaxSizedBox /&gt; &gt; clips a long single text child from the bottom" time="0.004160752">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/RadioButtonSelect.test.tsx" timestamp="2025-10-09T09:06:18.993Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.322934443">
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list of items and matches snapshot" time="0.029296958">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with the second item selected and matches snapshot" time="0.005764056">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with numbers hidden and matches snapshot" time="0.008423091">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with scroll arrows and matches snapshot" time="0.00793547">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders with special theme display and matches snapshot" time="0.004668861">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders a list with &gt;10 items and matches snapshot" time="0.012275002">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="&lt;RadioButtonSelect /&gt; &gt; renders nothing when no items are provided" time="0.002577014">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; should call onSelect when &quot;enter&quot; is pressed" time="0.010584306">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; when isFocused is false &gt; should not handle any keyboard input" time="0.00578293">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate down with arrow key and select with enter" time="0.059379718">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is true&apos; &gt; should navigate up with arrow key and select with enter" time="0.056305426">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate down with arrow key and select with enter" time="0.057280267">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/RadioButtonSelect.test.tsx" name="keyboard navigation &gt; &apos;when isFocused is omitted&apos; &gt; should navigate up with arrow key and select with enter" time="0.056352413">
            <system-err>
An update to Root inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act
An update to RadioButtonSelect inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() =&gt; {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you&apos;re testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act

            </system-err>
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/text-buffer.test.ts" timestamp="2025-10-09T09:06:18.993Z" hostname="uby" tests="103" failures="0" errors="0" skipped="0" time="0.190959455">
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; should return the initial state if state is undefined" time="0.004060726">
            <system-err>
Unknown action encountered: [object Object]

            </system-err>
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should set new text and move cursor to the end" time="0.000677102">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; set_text action &gt; should not create an undo snapshot if pushToUndo is false" time="0.000199168">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a character" time="0.000445944">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; insert action &gt; should insert a newline" time="0.000214847">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should remove a character" time="0.000194941">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; backspace action &gt; should join lines if at the beginning of a line" time="0.000220027">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; undo/redo actions &gt; should undo and redo a change" time="0.000478725">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer &gt; create_undo_snapshot action &gt; should create a snapshot without changing state" time="0.000272914">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with empty text and cursor at (0,0) by default" time="0.017596799">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with provided initialText" time="0.003612668">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with initialText and initialCursorOffset" time="0.004256068">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines" time="0.003566854">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines with multiple spaces" time="0.00417578">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should wrap visual lines even without spaces" time="0.002633929">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Initialization &gt; should initialize with multi-byte unicode characters and correct cursor offset" time="0.003300882">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert a character and update cursor" time="0.002445421">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; insert: should insert text in the middle of a line" time="0.002264907">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; newline: should create a new line and move cursor" time="0.003163778">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; backspace: should delete char to the left or merge lines" time="0.002641934">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Basic Editing &gt; del: should delete char to the right or merge lines" time="0.002563168">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should prepend @ to a valid file path on insert" time="0.002122023">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to an invalid file path on insert" time="0.001747681">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should handle quoted paths" time="0.001674465">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Drag and Drop File Paths &gt; should not prepend @ to short text that is not a path" time="0.001512927">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to valid file paths when shellModeActive is true" time="0.001663325">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should not prepend @ to quoted paths when shellModeActive is true" time="0.001595619">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with invalid paths when shellModeActive is true" time="0.00159054">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Shell Mode Behavior &gt; should behave normally with short text when shellModeActive is true" time="0.001374521">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: left/right should work within and across visual lines (due to wrapping)" time="0.006299104">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: up/down should preserve preferred visual column" time="0.00563698">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Cursor Movement &gt; move: home/end should go to visual line start/end" time="0.004259904">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should wrap long lines correctly into visualLines" time="0.001810117">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Visual Layout &amp; Viewport &gt; should update visualScrollRow when visualCursor moves out of viewport" time="0.006281202">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo an insert operation" time="0.003071819">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Undo/Redo &gt; should undo and redo a newline operation" time="0.004404462">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; insert: should correctly handle multi-byte unicode characters" time="0.001889453">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; backspace: should correctly delete multi-byte unicode characters" time="0.002534545">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Unicode Handling &gt; move: left/right should treat multi-byte chars as single units for visual cursor" time="0.002100132">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should insert printable characters" time="0.001740347">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Enter&quot; key as newline" time="0.00184504">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle &quot;Backspace&quot; key" time="0.001644069">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle multiple delete characters in one input" time="0.001721452">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts that contain delete characters" time="0.001946428">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle inserts with a mix of regular and delete characters" time="0.001863044">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle arrow keys for movement" time="0.001934015">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should strip ANSI escape codes when pasting text" time="0.00153661">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should handle VSCode terminal Shift+Enter as newline" time="0.001281299">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; handleInput &gt; should correctly handle repeated pasting of long text" time="0.026099197">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with single-line text" time="0.002470377">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a multi-line range with single-line text" time="0.00219082">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should delete a range when replacing with an empty string" time="0.001953651">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the beginning of the text" time="0.001914189">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing at the end of the text" time="0.002214323">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle replacing the entire buffer content" time="0.002069485">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should correctly replace with unicode characters" time="0.001281799">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should handle invalid range by returning false and not changing text" time="0.001589498">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; replaceRange: multiple lines with a single character" time="0.001456111">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; replaceRange &gt; should replace a single-line range with multi-line text" time="0.001151127">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip ANSI escape codes from input" time="0.000891518">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip control characters from input" time="0.001549966">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should strip mixed ANSI and control characters from input" time="0.001325921">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip standard characters or newlines" time="0.001659398">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should sanitize pasted text via handleInput" time="0.00203419">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; Input Sanitization &gt; should not strip popular emojis" time="0.001714039">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should correctly strip ANSI escape codes" time="0.000140139">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle multiple ANSI codes" time="0.000102559">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should not modify text without ANSI codes" time="0.000059169">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="useTextBuffer &gt; stripAnsi &gt; should handle empty string" time="0.000053008">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should return [0,0] for offset 0" time="0.00009747">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle single line text" time="0.000145239">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-line text" time="0.00030815">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty lines" time="0.00016238">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text ending with a newline" time="0.000106226">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle text starting with a newline" time="0.00050819">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle empty string input" time="0.000099584">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle multi-byte unicode characters correctly" time="0.000201633">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset exactly at newline character" time="0.000084756">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="offsetToLogicalPos &gt; should handle offset in the middle of a multi-byte character (should place at start of that char)" time="0.000099304">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should convert row/col position to offset correctly" time="0.00026494">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle empty lines" time="0.000117327">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle single empty line" time="0.000049091">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should be inverse of offsetToLogicalPos" time="0.000303201">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="logicalPosToOffset &gt; should handle out-of-bounds positions" time="0.00008621">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete a single line including newline in multi-line text" time="0.000975383">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should delete multiple lines when count &gt; 1" time="0.000169414">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should clear single line content when only one line exists" time="0.000443921">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting the last line properly" time="0.000166728">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="textBufferReducer vim operations &gt; vim_delete_line &gt; should handle deleting all lines and maintain valid state for subsequent paste" time="0.000263306">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle combining characters" time="0.001518216">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000123498">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findWordEndInLine with Unicode &gt; should return null when no word end found" time="0.000165135">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle right-to-left text" time="0.000161829">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle Chinese characters" time="0.00006513">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should return null at end of line" time="0.000048299">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle combining characters" time="0.00015654">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; findNextWordStartInLine with Unicode &gt; should handle precomposed characters with diacritics" time="0.000049051">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for ASCII word characters" time="0.000073606">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for punctuation" time="0.00005409">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return true for non-Latin scripts" time="0.000042649">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; isWordCharStrict with Unicode &gt; should return false for whitespace" time="0.000038571">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle combining characters" time="0.000095557">
        </testcase>
        <testcase classname="src/ui/components/shared/text-buffer.test.ts" name="Unicode helper functions &gt; cpLen with Unicode &gt; should handle Chinese and Arabic text" time="0.000047288">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/shared/vim-buffer-actions.test.ts" timestamp="2025-10-09T09:06:18.996Z" hostname="uby" tests="74" failures="0" errors="0" skipped="0" time="0.016360394">
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should move cursor left by count" time="0.002137581">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should not move past beginning of line" time="0.000244462">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should wrap to previous line when at beginning" time="0.000177899">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should handle multiple line wrapping" time="0.000309923">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_left &gt; should correctly handle h/l movement between lines" time="0.000142644">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should move cursor right by count" time="0.000283374">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should not move past last character of line" time="0.000090077">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should wrap to next line when at end" time="0.000077834">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_right &gt; should skip over combining marks to avoid cursor disappearing" time="0.000246386">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should move cursor up by count" time="0.000113089">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should not move past first line" time="0.000093793">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_up &gt; should adjust column for shorter lines" time="0.000061694">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should move cursor down by count" time="0.000063578">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_down &gt; should not move past last line" time="0.000184711">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move to start of next word" time="0.00134111">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle multiple words" time="0.000103462">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should handle punctuation correctly" time="0.000087892">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_forward &gt; should move across empty lines when starting from within a word" time="0.000104694">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should move to start of previous word" time="0.000188638">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_backward &gt; should handle multiple words" time="0.000069528">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of current word" time="0.000161759">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move to end of next word if already at word end" time="0.000056935">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should move across empty lines when at word end" time="0.00005948">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle consecutive word-end movements across empty lines" time="0.00011346">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle combining characters - advance from end of base character" time="0.000371076">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; vim_move_word_end &gt; should handle precomposed characters with diacritics" time="0.000139468">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_start should move to column 0" time="0.000068066">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line_end should move to last character" time="0.000048049">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_nonwhitespace should skip leading whitespace" time="0.000072384">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_first_line should move to row 0" time="0.000104063">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_last_line should move to last row" time="0.000088273">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should move to specific line" time="0.000066022">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Movement commands &gt; Position commands &gt; vim_move_to_line should clamp to valid range" time="0.000040024">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete single character" time="0.000339298">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should delete multiple characters" time="0.00009755">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should not delete past end of line" time="0.000063788">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_char &gt; should do nothing at end of line" time="0.000051025">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete from cursor to next word start" time="0.000089184">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete multiple words" time="0.00010851">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_forward &gt; should delete to end if no more words" time="0.000159445">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete from cursor to previous word start" time="0.000148996">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_word_backward &gt; should delete multiple words backward" time="0.000085899">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete current line" time="0.000654389">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should delete multiple lines" time="0.000183569">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_line &gt; should leave empty line when deleting all lines" time="0.000137735">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should delete from cursor to end of line" time="0.000146411">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edit commands &gt; vim_delete_to_end_of_line &gt; should do nothing at end of line" time="0.000083394">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_cursor &gt; should not change cursor position" time="0.00011913">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should move cursor right by one" time="0.000082642">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_cursor &gt; should not move past end of line" time="0.000082222">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_append_at_line_end &gt; should move cursor to end of line" time="0.00011369">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to first non-whitespace character" time="0.000105475">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_insert_at_line_start &gt; should move to column 0 for line with only whitespace" time="0.000080268">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_below &gt; should insert a new line below the current one" time="0.000186625">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_open_line_above &gt; should insert a new line above the current one" time="0.000152673">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should move cursor left" time="0.000074869">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Insert mode commands &gt; vim_escape_insert_mode &gt; should not move past beginning of line" time="0.00006492">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_word_forward &gt; should delete from cursor to next word start" time="0.00040015">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_line &gt; should delete entire line content" time="0.000313219">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the left" time="0.000111506">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change characters to the right" time="0.000084206">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Change commands &gt; vim_change_movement &gt; should change multiple lines down" time="0.000224846">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty text" time="0.000073356">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle single character line" time="0.000042759">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should handle empty lines in multi-line text" time="0.00005361">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; Edge cases &gt; should preserve undo stack in operations" time="0.000767098">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Right-to-left text handling &gt; should handle Arabic text in word movements" time="0.000387747">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Chinese character handling &gt; should handle Chinese characters in word movements" time="0.000103441">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word end commands" time="0.00008099">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word forward commands" time="0.000083935">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle mixed Latin and non-Latin scripts with word backward commands" time="0.000127415">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle Unicode block characters consistently with w and e commands" time="0.000247427">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Chinese characters" time="0.000196704">
        </testcase>
        <testcase classname="src/ui/components/shared/vim-buffer-actions.test.ts" name="vim-buffer-actions &gt; UTF-32 character handling in word/line operations &gt; Mixed script handling &gt; should handle strings starting with Arabic characters" time="0.00012974">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/DiffRenderer.test.tsx" timestamp="2025-10-09T09:06:18.999Z" hostname="uby" tests="13" failures="0" errors="0" skipped="0" time="0.289233383">
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with correct language for new file with known extension" time="0.041979593">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file with unknown extension" time="0.116857361">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should call colorizeCode with null language for new file if no filename is provided" time="0.012180276">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render diff content for existing file (not calling colorizeCode directly for the whole block)" time="0.004769176">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle diff with only header and no changes" time="0.004562374">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should handle empty diff content" time="0.001561136">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should render a gap indicator for skipped lines" time="0.006879077">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should not render a gap indicator for small gaps (&lt;= MAX_CONTEXT_LINES_WITHOUT_GAP)" time="0.010504999">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height undefined" time="0.017702575">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 80 and height 6" time="0.010975519">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with multiple hunks and a gap indicator &gt; with terminalWidth 30 and height 6" time="0.007927525">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a diff with a SVN diff format" time="0.023747158">
        </testcase>
        <testcase classname="src/ui/components/messages/DiffRenderer.test.tsx" name="&lt;OverflowProvider&gt;&lt;DiffRenderer /&gt;&lt;/OverflowProvider&gt; &gt; should correctly render a new file with no file extension correctly" time="0.027244694">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolConfirmationMessage.test.tsx" timestamp="2025-10-09T09:06:18.999Z" hostname="uby" tests="15" failures="0" errors="0" skipped="0" time="0.15588635">
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should not display urls if prompt and url are the same" time="0.043138105">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should display urls if prompt and url are different" time="0.010254857">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; should render plan confirmation with markdown plan content" time="0.007945969">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.00862261">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.008094243">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for edit confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.007592936">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.006974813">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.005113102">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for exec confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.00531172">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.006027552">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.006495708">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for info confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.004824128">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder is trusted" time="0.018259865">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should show &quot;allow always&quot; when folder trust is undefined" time="0.010342749">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolConfirmationMessage.test.tsx" name="ToolConfirmationMessage &gt; with folder trust &gt; &apos;for mcp confirmations&apos; &gt; should NOT show &quot;allow always&quot; when folder is untrusted" time="0.004075484">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolGroupMessage.test.tsx" timestamp="2025-10-09T09:06:18.999Z" hostname="uby" tests="14" failures="0" errors="0" skipped="0" time="0.11592091">
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders single successful tool call" time="0.023836543">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders multiple tool calls with different statuses" time="0.007353895">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders tool call awaiting confirmation" time="0.005055976">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders shell command with yellow border" time="0.003021195">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders mixed tool calls including shell command" time="0.005894025">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with limited terminal height" time="0.005267347">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders when not focused" time="0.004347267">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders with narrow terminal width" time="0.009602592">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Golden Snapshots &gt; renders empty tool calls array" time="0.005491412">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border when tools are pending" time="0.004152607">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses yellow border for shell commands even when successful" time="0.007823322">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Border Color Logic &gt; uses gray border when all tools are successful and no shell commands" time="0.010075746">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Height Calculation &gt; calculates available height correctly with multiple tools with results" time="0.013572911">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolGroupMessage.test.tsx" name="&lt;ToolGroupMessage /&gt; &gt; Confirmation Handling &gt; shows confirmation dialog for first confirming tool only" time="0.00804389">
        </testcase>
    </testsuite>
    <testsuite name="src/ui/components/messages/ToolMessage.test.tsx" timestamp="2025-10-09T09:06:19.000Z" hostname="uby" tests="12" failures="0" errors="0" skipped="0" time="0.071612903">
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders basic tool information" time="0.024919435">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows ✓ for Success status" time="0.003583785">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows o for Pending status" time="0.003096434">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows ? for Confirming status" time="0.003075305">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows - for Canceled status" time="0.002419903">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows x for Error status" time="0.00305641">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is Idle" time="0.003165622">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows paused spinner for Executing status when streamingState is WaitingForConfirmation" time="0.003086666">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; ToolStatusIndicator rendering &gt; shows MockRespondingSpinner for Executing status when streamingState is Responding" time="0.004290962">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders DiffRenderer for diff results" time="0.004096803">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; renders emphasis correctly" time="0.007111426">
        </testcase>
        <testcase classname="src/ui/components/messages/ToolMessage.test.tsx" name="&lt;ToolMessage /&gt; &gt; shows subagent execution display for task tool with proper result display" time="0.007896838">
        </testcase>
    </testsuite>
</testsuites>
